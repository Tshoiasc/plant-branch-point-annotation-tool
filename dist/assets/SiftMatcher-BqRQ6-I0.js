class S{constructor(){this.searchConfigs=[{boxSize:30,searchRadius:40},{boxSize:40,searchRadius:60},{boxSize:50,searchRadius:80},{boxSize:60,searchRadius:100}],this.qualityThreshold=.7,this.ratioThreshold=.7,this.minMatches=3}async calibrateAnnotations(o,n,c,i){if(!o||!n||!c||!i)throw new Error("缺少必要的参数：需要基准标注、目标标注和图像数据");console.log("[SIFT] 开始标注点校准",{referenceCount:o.length,targetCount:n.length});const h=[...o].sort((t,a)=>(t.order||0)-(a.order||0)),r=[...n].sort((t,a)=>(t.order||0)-(a.order||0)),s=[],e=new Map(h.map(t=>[t.order,t]));for(const t of r){const a=e.get(t.order);if(!a){console.log("[SIFT] 保留新标注点 #".concat(t.order,"（上一帧不存在）")),s.push({...t,calibrationData:{originalX:t.x,originalY:t.y,confidence:1,method:"preserve",offset:0,note:"New annotation not in previous frame"}});continue}try{const l=await this.adaptiveMatching(c,a.x,a.y,i,a.x,a.y),f={...t,x:l.x,y:l.y,calibrationData:{originalX:t.x,originalY:t.y,confidence:l.confidence,method:l.method,offset:Math.sqrt(Math.pow(l.x-t.x,2)+Math.pow(l.y-t.y,2))}};s.push(f),console.log("[SIFT] 校准点 ".concat(t.order||"unknown",":"),{original:"(".concat(t.x.toFixed(1),", ").concat(t.y.toFixed(1),")"),calibrated:"(".concat(l.x.toFixed(1),", ").concat(l.y.toFixed(1),")"),offset:"".concat(f.calibrationData.offset.toFixed(2),"px"),confidence:"".concat((l.confidence*100).toFixed(1),"%"),method:l.method})}catch(l){console.warn("[SIFT] 校准点 ".concat(t.order||"unknown"," 失败:"),l.message),s.push({...t,calibrationData:{originalX:t.x,originalY:t.y,confidence:0,method:"none",offset:0,error:l.message}})}}return s}async adaptiveMatching(o,n,c,i,h,r){let s={x:h,y:r,confidence:0,method:"none"},e=0;for(const t of this.searchConfigs)try{const a=await this.findBestMatch(o,n,c,i,h,r,t.boxSize,t.searchRadius);if(a.confidence>e&&(e=a.confidence,s=a),a.confidence>this.qualityThreshold)break}catch(a){console.warn("[SIFT] 配置 ".concat(JSON.stringify(t)," 匹配失败:"),a.message);continue}return s}async findBestMatch(o,n,c,i,h,r,s,e){const t=this.extractRegion(o,n,c,s),a=this.extractRegion(i,h,r,e*2);if(!t||!a)return{x:h,y:r,confidence:0,method:"none"};const l=[];try{const d=await this.templateMatching(t,a,h-e,r-e);l.push(d)}catch(d){console.warn("[SIFT] 模板匹配失败:",d.message)}try{const d=await this.simplifiedSiftMatching(t,a,h-e,r-e);l.push(d)}catch(d){console.warn("[SIFT] 简化SIFT匹配失败:",d.message)}return l.length===0?{x:h,y:r,confidence:0,method:"none"}:l.reduce((d,u)=>u.confidence>d.confidence?u:d)}extractRegion(o,n,c,i){const{width:h,height:r,data:s}=o,e=Math.floor(i/2),t=Math.max(0,Math.floor(n-e)),a=Math.max(0,Math.floor(c-e)),l=Math.min(h,Math.floor(n+e)),f=Math.min(r,Math.floor(c+e)),d=l-t,u=f-a;if(d<5||u<5)return null;const g=new Uint8ClampedArray(d*u*4);for(let y=0;y<u;y++)for(let M=0;M<d;M++){const m=((a+y)*h+(t+M))*4,x=(y*d+M)*4;g[x]=s[m],g[x+1]=s[m+1],g[x+2]=s[m+2],g[x+3]=s[m+3]}return{x:t,y:a,width:d,height:u,data:g}}async templateMatching(o,n,c,i){const h=this.toGrayscale(o),r=this.toGrayscale(n),s=this.normalizedCorrelation(h,r);if(!s)return{x:c+n.width/2,y:i+n.height/2,confidence:0,method:"template"};const e=s.x+o.width/2+c,t=s.y+o.height/2+i;return{x:e,y:t,confidence:s.confidence,method:"template"}}async simplifiedSiftMatching(o,n,c,i){const h=this.toGrayscale(o),r=this.toGrayscale(n),s=this.detectHarrisCorners(h),e=this.detectHarrisCorners(r);if(s.length<3||e.length<3)return this.templateMatching(o,n,c,i);const t=this.matchCorners(s,e);if(t.length<this.minMatches)return this.templateMatching(o,n,c,i);const a=this.calculateTransformation(t),l=o.width/2+a.dx+c,f=o.height/2+a.dy+i;return{x:l,y:f,confidence:Math.min(a.confidence,1),method:"sift"}}toGrayscale(o){const{width:n,height:c,data:i}=o,h=new Uint8Array(n*c);for(let r=0;r<n*c;r++){const s=i[r*4],e=i[r*4+1],t=i[r*4+2];h[r]=Math.round(.299*s+.587*e+.114*t)}return{width:n,height:c,data:h}}normalizedCorrelation(o,n){const{width:c,height:i,data:h}=o,{width:r,height:s,data:e}=n;if(c>r||i>s)return null;let t=-1,a=0,l=0;for(let f=0;f<=s-i;f++)for(let d=0;d<=r-c;d++){const u=this.calculateNCC(h,e,c,i,d,f,r);u>t&&(t=u,a=d,l=f)}return{x:a,y:l,confidence:Math.max(0,Math.min(t,.9))}}calculateNCC(o,n,c,i,h,r,s){let e=0,t=0,a=0,l=0,f=0;const d=c*i;for(let m=0;m<i;m++)for(let x=0;x<c;x++){const p=o[m*c+x],w=n[(r+m)*s+(h+x)];e+=p,t+=w,a+=p*w,l+=p*p,f+=w*w}const u=e/d,g=t/d,y=a-d*u*g,M=Math.sqrt((l-d*u*u)*(f-d*g*g));return M>0?y/M:0}detectHarrisCorners(o){const{width:n,height:c,data:i}=o,h=[],r=.01;for(let s=1;s<c-1;s++)for(let e=1;e<n-1;e++){const t=this.calculateHarrisResponse(i,e,s,n,c);t>r&&h.push({x:e,y:s,response:t})}return h.sort((s,e)=>e.response-s.response).slice(0,20)}calculateHarrisResponse(o,n,c,i,h){let s=0,e=0,t=0;for(let f=-1;f<=1;f++)for(let d=-1;d<=1;d++){const u=(c+f)*i+(n+d),g=o[u+1]-o[u-1],y=o[u+i]-o[u-i];s+=g*g,e+=y*y,t+=g*y}const a=s*e-t*t,l=s+e;return a-.04*l*l}matchCorners(o,n){const c=[];for(let i=0;i<o.length;i++){const h=o[i];let r=null,s=1/0;for(let e=0;e<n.length;e++){const t=n[e],a=Math.sqrt(Math.pow(h.x-t.x,2)+Math.pow(h.y-t.y,2));a<s&&(s=a,r={corner1:h,corner2:t,distance:a})}r&&s<50&&c.push(r)}return c}calculateTransformation(o){if(o.length===0)return{dx:0,dy:0,confidence:0};const n=o.map(e=>e.corner2.x-e.corner1.x),c=o.map(e=>e.corner2.y-e.corner1.y),i=this.median(n),h=this.median(c),r=Math.min(refCorners.length,searchCorners.length),s=r>0?o.length/r*.8:0;return{dx:i,dy:h,confidence:Math.min(s,.8)}}median(o){const n=[...o].sort((i,h)=>i-h),c=Math.floor(n.length/2);return n.length%2===0?(n[c-1]+n[c])/2:n[c]}calculateMatchingQuality(o){if(!o||o.length===0)return{averageConfidence:0,averageOffset:0,successfulMatches:0,totalAnnotations:0,qualityScore:0};const n=o.filter(e=>e.calibrationData&&e.calibrationData.confidence>0),c=n.reduce((e,t)=>e+t.calibrationData.confidence,0),i=n.reduce((e,t)=>e+t.calibrationData.offset,0),h=n.length>0?c/n.length:0,r=n.length>0?i/n.length:0,s=h*(n.length/o.length);return{averageConfidence:h,averageOffset:r,successfulMatches:n.length,totalAnnotations:o.length,qualityScore:s}}}export{S as SiftMatcher};
//# sourceMappingURL=SiftMatcher-BqRQ6-I0.js.map
