{"version":3,"file":"SiftMatcher-legacy-OvzYr5fk.js","sources":["../../src/core/SiftMatcher.js"],"sourcesContent":["/**\n * SIFT 图像匹配算法\n * \n * 基于JavaScript的SIFT特征匹配实现，用于标注点精确匹配\n * 支持SIFT特征检测、模板匹配和自适应匹配策略\n */\n\nexport class SiftMatcher {\n  constructor() {\n    this.searchConfigs = [\n      { boxSize: 30, searchRadius: 40 },\n      { boxSize: 40, searchRadius: 60 },\n      { boxSize: 50, searchRadius: 80 },\n      { boxSize: 60, searchRadius: 100 }\n    ];\n    \n    this.qualityThreshold = 0.7;\n    this.ratioThreshold = 0.7;\n    this.minMatches = 3;\n  }\n\n  /**\n   * 校准标注点位置\n   * @param {Array} referenceAnnotations - 基准标注点\n   * @param {Array} targetAnnotations - 目标标注点\n   * @param {ImageData} referenceImageData - 基准图像数据\n   * @param {ImageData} targetImageData - 目标图像数据\n   * @returns {Array} 校准后的标注点\n   */\n  async calibrateAnnotations(referenceAnnotations, targetAnnotations, referenceImageData, targetImageData) {\n    if (!referenceAnnotations || !targetAnnotations || !referenceImageData || !targetImageData) {\n      throw new Error('缺少必要的参数：需要基准标注、目标标注和图像数据');\n    }\n\n    console.log('[SIFT] 开始标注点校准', {\n      referenceCount: referenceAnnotations.length,\n      targetCount: targetAnnotations.length\n    });\n\n    // 按order排序\n    const refAnnotations = [...referenceAnnotations].sort((a, b) => (a.order || 0) - (b.order || 0));\n    const targetAnnotationsSorted = [...targetAnnotations].sort((a, b) => (a.order || 0) - (b.order || 0));\n\n    const calibratedAnnotations = [];\n    \n    // 🔧 FIX: 按order创建映射，保留目标图像中上一帧没有的新标注点\n    const refAnnotationMap = new Map(refAnnotations.map(ann => [ann.order, ann]));\n    \n    for (const targetAnn of targetAnnotationsSorted) {\n      const refAnn = refAnnotationMap.get(targetAnn.order);\n      \n      if (!refAnn) {\n        // 🔧 FIX: 上一帧没有的标注点，直接保留原位置\n        console.log(`[SIFT] 保留新标注点 #${targetAnn.order}（上一帧不存在）`);\n        calibratedAnnotations.push({\n          ...targetAnn,\n          calibrationData: {\n            originalX: targetAnn.x,\n            originalY: targetAnn.y,\n            confidence: 1.0,\n            method: 'preserve',\n            offset: 0,\n            note: 'New annotation not in previous frame'\n          }\n        });\n        continue;\n      }\n\n      try {\n        // 🔧 FIX: 使用参考点位置作为搜索中心（而非当前目标点位置）\n        // 这是正确的SIFT匹配算法：在目标图像中围绕参考点位置搜索\n        const matchResult = await this.adaptiveMatching(\n          referenceImageData,\n          refAnn.x,\n          refAnn.y,\n          targetImageData,\n          refAnn.x,  // 🔧 FIX: 使用参考点位置作为搜索中心\n          refAnn.y   // 🔧 FIX: 而非目标点当前位置\n        );\n\n        // 复制目标标注的所有属性\n        const calibratedAnn = {\n          ...targetAnn,\n          x: matchResult.x,\n          y: matchResult.y,\n          calibrationData: {\n            originalX: targetAnn.x,\n            originalY: targetAnn.y,\n            confidence: matchResult.confidence,\n            method: matchResult.method,\n            offset: Math.sqrt(Math.pow(matchResult.x - targetAnn.x, 2) + Math.pow(matchResult.y - targetAnn.y, 2))\n          }\n        };\n\n        calibratedAnnotations.push(calibratedAnn);\n\n        console.log(`[SIFT] 校准点 ${targetAnn.order || 'unknown'}:`, {\n          original: `(${targetAnn.x.toFixed(1)}, ${targetAnn.y.toFixed(1)})`,\n          calibrated: `(${matchResult.x.toFixed(1)}, ${matchResult.y.toFixed(1)})`,\n          offset: `${calibratedAnn.calibrationData.offset.toFixed(2)}px`,\n          confidence: `${(matchResult.confidence * 100).toFixed(1)}%`,\n          method: matchResult.method\n        });\n\n      } catch (error) {\n        console.warn(`[SIFT] 校准点 ${targetAnn.order || 'unknown'} 失败:`, error.message);\n        // 保持原始位置\n        calibratedAnnotations.push({\n          ...targetAnn,\n          calibrationData: {\n            originalX: targetAnn.x,\n            originalY: targetAnn.y,\n            confidence: 0,\n            method: 'none',\n            offset: 0,\n            error: error.message\n          }\n        });\n      }\n    }\n\n    return calibratedAnnotations;\n  }\n\n  /**\n   * 自适应匹配算法\n   * @param {ImageData} refImageData - 基准图像数据\n   * @param {number} refX - 基准X坐标\n   * @param {number} refY - 基准Y坐标\n   * @param {ImageData} targetImageData - 目标图像数据\n   * @param {number} searchCenterX - 搜索中心X坐标（通常是参考点位置）\n   * @param {number} searchCenterY - 搜索中心Y坐标（通常是参考点位置）\n   * @returns {Object} 匹配结果\n   */\n  async adaptiveMatching(refImageData, refX, refY, targetImageData, searchCenterX, searchCenterY) {\n    let bestResult = { x: searchCenterX, y: searchCenterY, confidence: 0.0, method: 'none' };\n    let bestQuality = 0.0;\n\n    for (const config of this.searchConfigs) {\n      try {\n        const result = await this.findBestMatch(\n          refImageData, refX, refY,\n          targetImageData, searchCenterX, searchCenterY,\n          config.boxSize, config.searchRadius\n        );\n\n        if (result.confidence > bestQuality) {\n          bestQuality = result.confidence;\n          bestResult = result;\n        }\n\n        // 如果质量足够好，停止搜索\n        if (result.confidence > this.qualityThreshold) {\n          break;\n        }\n      } catch (error) {\n        console.warn(`[SIFT] 配置 ${JSON.stringify(config)} 匹配失败:`, error.message);\n        continue;\n      }\n    }\n\n    return bestResult;\n  }\n\n  /**\n   * 寻找最佳匹配\n   * @param {ImageData} refImageData - 基准图像数据\n   * @param {number} refX - 基准X坐标\n   * @param {number} refY - 基准Y坐标\n   * @param {ImageData} targetImageData - 目标图像数据\n   * @param {number} searchCenterX - 搜索中心X坐标\n   * @param {number} searchCenterY - 搜索中心Y坐标\n   * @param {number} boxSize - 匹配框大小\n   * @param {number} searchRadius - 搜索半径\n   * @returns {Object} 匹配结果\n   */\n  async findBestMatch(refImageData, refX, refY, targetImageData, searchCenterX, searchCenterY, boxSize, searchRadius) {\n    const refBox = this.extractRegion(refImageData, refX, refY, boxSize);\n    const searchRegion = this.extractRegion(targetImageData, searchCenterX, searchCenterY, searchRadius * 2);\n\n    if (!refBox || !searchRegion) {\n      return { x: searchCenterX, y: searchCenterY, confidence: 0.0, method: 'none' };\n    }\n\n    // 尝试多种匹配方法\n    const results = [];\n\n    // 1. 模板匹配\n    try {\n      const templateResult = await this.templateMatching(\n        refBox, searchRegion,\n        searchCenterX - searchRadius, searchCenterY - searchRadius\n      );\n      results.push(templateResult);\n    } catch (error) {\n      console.warn('[SIFT] 模板匹配失败:', error.message);\n    }\n\n    // 2. 简化的SIFT匹配（使用Harris角点检测）\n    try {\n      const siftResult = await this.simplifiedSiftMatching(\n        refBox, searchRegion,\n        searchCenterX - searchRadius, searchCenterY - searchRadius\n      );\n      results.push(siftResult);\n    } catch (error) {\n      console.warn('[SIFT] 简化SIFT匹配失败:', error.message);\n    }\n\n    // 选择最佳结果\n    if (results.length === 0) {\n      return { x: searchCenterX, y: searchCenterY, confidence: 0.0, method: 'none' };\n    }\n\n    const bestResult = results.reduce((best, current) => \n      current.confidence > best.confidence ? current : best\n    );\n\n    return bestResult;\n  }\n\n  /**\n   * 提取图像区域\n   * @param {ImageData} imageData - 图像数据\n   * @param {number} centerX - 中心X坐标\n   * @param {number} centerY - 中心Y坐标\n   * @param {number} size - 区域大小\n   * @returns {Object} 提取的区域数据\n   */\n  extractRegion(imageData, centerX, centerY, size) {\n    const { width, height, data } = imageData;\n    const halfSize = Math.floor(size / 2);\n    \n    const x1 = Math.max(0, Math.floor(centerX - halfSize));\n    const y1 = Math.max(0, Math.floor(centerY - halfSize));\n    const x2 = Math.min(width, Math.floor(centerX + halfSize));\n    const y2 = Math.min(height, Math.floor(centerY + halfSize));\n    \n    const regionWidth = x2 - x1;\n    const regionHeight = y2 - y1;\n    \n    if (regionWidth < 5 || regionHeight < 5) {\n      return null;\n    }\n\n    const regionData = new Uint8ClampedArray(regionWidth * regionHeight * 4);\n    \n    for (let y = 0; y < regionHeight; y++) {\n      for (let x = 0; x < regionWidth; x++) {\n        const srcIndex = ((y1 + y) * width + (x1 + x)) * 4;\n        const dstIndex = (y * regionWidth + x) * 4;\n        \n        regionData[dstIndex] = data[srcIndex];     // R\n        regionData[dstIndex + 1] = data[srcIndex + 1]; // G\n        regionData[dstIndex + 2] = data[srcIndex + 2]; // B\n        regionData[dstIndex + 3] = data[srcIndex + 3]; // A\n      }\n    }\n\n    return {\n      x: x1,\n      y: y1,\n      width: regionWidth,\n      height: regionHeight,\n      data: regionData\n    };\n  }\n\n  /**\n   * 模板匹配\n   * @param {Object} refBox - 基准框\n   * @param {Object} searchRegion - 搜索区域\n   * @param {number} searchX - 搜索区域X偏移\n   * @param {number} searchY - 搜索区域Y偏移\n   * @returns {Object} 匹配结果\n   */\n  async templateMatching(refBox, searchRegion, searchX, searchY) {\n    const refGray = this.toGrayscale(refBox);\n    const searchGray = this.toGrayscale(searchRegion);\n    \n    // 使用归一化相关匹配\n    const result = this.normalizedCorrelation(refGray, searchGray);\n    \n    if (!result) {\n      return { \n        x: searchX + searchRegion.width / 2, \n        y: searchY + searchRegion.height / 2, \n        confidence: 0.0, \n        method: 'template' \n      };\n    }\n\n    const centerX = result.x + refBox.width / 2 + searchX;\n    const centerY = result.y + refBox.height / 2 + searchY;\n\n    return {\n      x: centerX,\n      y: centerY,\n      confidence: result.confidence,\n      method: 'template'\n    };\n  }\n\n  /**\n   * 简化的SIFT匹配（使用Harris角点检测）\n   * @param {Object} refBox - 基准框\n   * @param {Object} searchRegion - 搜索区域\n   * @param {number} searchX - 搜索区域X偏移\n   * @param {number} searchY - 搜索区域Y偏移\n   * @returns {Object} 匹配结果\n   */\n  async simplifiedSiftMatching(refBox, searchRegion, searchX, searchY) {\n    const refGray = this.toGrayscale(refBox);\n    const searchGray = this.toGrayscale(searchRegion);\n    \n    // 检测Harris角点\n    const refCorners = this.detectHarrisCorners(refGray);\n    const searchCorners = this.detectHarrisCorners(searchGray);\n    \n    if (refCorners.length < 3 || searchCorners.length < 3) {\n      // 回退到模板匹配\n      return this.templateMatching(refBox, searchRegion, searchX, searchY);\n    }\n\n    // 简化的描述子匹配\n    const matches = this.matchCorners(refCorners, searchCorners);\n    \n    if (matches.length < this.minMatches) {\n      return this.templateMatching(refBox, searchRegion, searchX, searchY);\n    }\n\n    // 计算变换\n    const transformation = this.calculateTransformation(matches);\n    \n    const centerX = refBox.width / 2 + transformation.dx + searchX;\n    const centerY = refBox.height / 2 + transformation.dy + searchY;\n\n    return {\n      x: centerX,\n      y: centerY,\n      confidence: Math.min(transformation.confidence, 1.0),\n      method: 'sift'\n    };\n  }\n\n  /**\n   * 转换为灰度图\n   * @param {Object} imageRegion - 图像区域\n   * @returns {Object} 灰度图像数据\n   */\n  toGrayscale(imageRegion) {\n    const { width, height, data } = imageRegion;\n    const grayData = new Uint8Array(width * height);\n    \n    for (let i = 0; i < width * height; i++) {\n      const r = data[i * 4];\n      const g = data[i * 4 + 1];\n      const b = data[i * 4 + 2];\n      grayData[i] = Math.round(0.299 * r + 0.587 * g + 0.114 * b);\n    }\n    \n    return { width, height, data: grayData };\n  }\n\n  /**\n   * 归一化相关匹配\n   * @param {Object} template - 模板图像\n   * @param {Object} image - 搜索图像\n   * @returns {Object} 匹配结果\n   */\n  normalizedCorrelation(template, image) {\n    const { width: tWidth, height: tHeight, data: tData } = template;\n    const { width: iWidth, height: iHeight, data: iData } = image;\n    \n    if (tWidth > iWidth || tHeight > iHeight) {\n      return null;\n    }\n    \n    let bestScore = -1;\n    let bestX = 0;\n    let bestY = 0;\n    \n    for (let y = 0; y <= iHeight - tHeight; y++) {\n      for (let x = 0; x <= iWidth - tWidth; x++) {\n        const score = this.calculateNCC(tData, iData, tWidth, tHeight, x, y, iWidth);\n        \n        if (score > bestScore) {\n          bestScore = score;\n          bestX = x;\n          bestY = y;\n        }\n      }\n    }\n    \n    return {\n      x: bestX,\n      y: bestY,\n      confidence: Math.max(0, Math.min(bestScore, 0.9)) // 🔧 FIX: 限制最大置信度，避免虚假的100%\n    };\n  }\n\n  /**\n   * 计算归一化相关系数\n   * @param {Uint8Array} template - 模板数据\n   * @param {Uint8Array} image - 图像数据\n   * @param {number} tWidth - 模板宽度\n   * @param {number} tHeight - 模板高度\n   * @param {number} x - 图像中的X位置\n   * @param {number} y - 图像中的Y位置\n   * @param {number} iWidth - 图像宽度\n   * @returns {number} 相关系数\n   */\n  calculateNCC(template, image, tWidth, tHeight, x, y, iWidth) {\n    let sumT = 0, sumI = 0, sumTI = 0, sumT2 = 0, sumI2 = 0;\n    const n = tWidth * tHeight;\n    \n    for (let dy = 0; dy < tHeight; dy++) {\n      for (let dx = 0; dx < tWidth; dx++) {\n        const tVal = template[dy * tWidth + dx];\n        const iVal = image[(y + dy) * iWidth + (x + dx)];\n        \n        sumT += tVal;\n        sumI += iVal;\n        sumTI += tVal * iVal;\n        sumT2 += tVal * tVal;\n        sumI2 += iVal * iVal;\n      }\n    }\n    \n    const meanT = sumT / n;\n    const meanI = sumI / n;\n    \n    const numerator = sumTI - n * meanT * meanI;\n    const denominator = Math.sqrt((sumT2 - n * meanT * meanT) * (sumI2 - n * meanI * meanI));\n    \n    return denominator > 0 ? numerator / denominator : 0;\n  }\n\n  /**\n   * 检测Harris角点\n   * @param {Object} grayImage - 灰度图像\n   * @returns {Array} 角点列表\n   */\n  detectHarrisCorners(grayImage) {\n    const { width, height, data } = grayImage;\n    const corners = [];\n    const threshold = 0.01;\n    \n    // 简化的Harris角点检测\n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        const response = this.calculateHarrisResponse(data, x, y, width, height);\n        \n        if (response > threshold) {\n          corners.push({ x, y, response });\n        }\n      }\n    }\n    \n    // 返回最强的角点\n    return corners.sort((a, b) => b.response - a.response).slice(0, 20);\n  }\n\n  /**\n   * 计算Harris响应\n   * @param {Uint8Array} data - 图像数据\n   * @param {number} x - X坐标\n   * @param {number} y - Y坐标\n   * @param {number} width - 图像宽度\n   * @param {number} height - 图像高度\n   * @returns {number} Harris响应值\n   */\n  calculateHarrisResponse(data, x, y, width, height) {\n    // 简化的Harris响应计算\n    const k = 0.04;\n    let Ixx = 0, Iyy = 0, Ixy = 0;\n    \n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        const idx = (y + dy) * width + (x + dx);\n        const Ix = data[idx + 1] - data[idx - 1]; // 简化的梯度计算\n        const Iy = data[idx + width] - data[idx - width];\n        \n        Ixx += Ix * Ix;\n        Iyy += Iy * Iy;\n        Ixy += Ix * Iy;\n      }\n    }\n    \n    const det = Ixx * Iyy - Ixy * Ixy;\n    const trace = Ixx + Iyy;\n    \n    return det - k * trace * trace;\n  }\n\n  /**\n   * 匹配角点\n   * @param {Array} corners1 - 第一组角点\n   * @param {Array} corners2 - 第二组角点\n   * @returns {Array} 匹配结果\n   */\n  matchCorners(corners1, corners2) {\n    const matches = [];\n    \n    for (let i = 0; i < corners1.length; i++) {\n      const c1 = corners1[i];\n      let bestMatch = null;\n      let bestDistance = Infinity;\n      \n      for (let j = 0; j < corners2.length; j++) {\n        const c2 = corners2[j];\n        const distance = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));\n        \n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = { corner1: c1, corner2: c2, distance };\n        }\n      }\n      \n      if (bestMatch && bestDistance < 50) { // 距离阈值\n        matches.push(bestMatch);\n      }\n    }\n    \n    return matches;\n  }\n\n  /**\n   * 计算变换\n   * @param {Array} matches - 匹配结果\n   * @returns {Object} 变换参数\n   */\n  calculateTransformation(matches) {\n    if (matches.length === 0) {\n      return { dx: 0, dy: 0, confidence: 0 };\n    }\n    \n    // 计算平均偏移\n    const dxList = matches.map(m => m.corner2.x - m.corner1.x);\n    const dyList = matches.map(m => m.corner2.y - m.corner1.y);\n    \n    const dx = this.median(dxList);\n    const dy = this.median(dyList);\n    \n    // 🔧 FIX: 改进置信度计算，避免虚假的高置信度\n    const maxExpectedMatches = Math.min(refCorners.length, searchCorners.length);\n    const confidence = maxExpectedMatches > 0 ? (matches.length / maxExpectedMatches) * 0.8 : 0; // 限制最大置信度为0.8\n    \n    return { dx, dy, confidence: Math.min(confidence, 0.8) }; // 确保置信度不超过0.8\n  }\n\n  /**\n   * 计算中位数\n   * @param {Array} values - 数值数组\n   * @returns {number} 中位数\n   */\n  median(values) {\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    \n    return sorted.length % 2 === 0 ? \n      (sorted[mid - 1] + sorted[mid]) / 2 : \n      sorted[mid];\n  }\n\n  /**\n   * 计算匹配质量\n   * @param {Array} calibrationResults - 校准结果\n   * @returns {Object} 质量指标\n   */\n  calculateMatchingQuality(calibrationResults) {\n    if (!calibrationResults || calibrationResults.length === 0) {\n      return {\n        averageConfidence: 0,\n        averageOffset: 0,\n        successfulMatches: 0,\n        totalAnnotations: 0,\n        qualityScore: 0\n      };\n    }\n\n    const successfulMatches = calibrationResults.filter(r => r.calibrationData && r.calibrationData.confidence > 0);\n    const totalConfidence = successfulMatches.reduce((sum, r) => sum + r.calibrationData.confidence, 0);\n    const totalOffset = successfulMatches.reduce((sum, r) => sum + r.calibrationData.offset, 0);\n\n    const averageConfidence = successfulMatches.length > 0 ? totalConfidence / successfulMatches.length : 0;\n    const averageOffset = successfulMatches.length > 0 ? totalOffset / successfulMatches.length : 0;\n    const qualityScore = averageConfidence * (successfulMatches.length / calibrationResults.length);\n\n    return {\n      averageConfidence,\n      averageOffset,\n      successfulMatches: successfulMatches.length,\n      totalAnnotations: calibrationResults.length,\n      qualityScore\n    };\n  }\n}"],"names":["exports","constructor","this","searchConfigs","boxSize","searchRadius","qualityThreshold","ratioThreshold","minMatches","calibrateAnnotations","referenceAnnotations","targetAnnotations","referenceImageData","targetImageData","Error","console","log","referenceCount","length","targetCount","refAnnotations","sort","a","b","order","targetAnnotationsSorted","calibratedAnnotations","refAnnotationMap","Map","map","ann","targetAnn","refAnn","get","matchResult","adaptiveMatching","x","y","calibratedAnn","calibrationData","originalX","originalY","confidence","method","offset","Math","sqrt","pow","push","original","toFixed","calibrated","error","warn","message","note","refImageData","refX","refY","searchCenterX","searchCenterY","bestResult","bestQuality","config","result","findBestMatch","JSON","stringify","refBox","extractRegion","searchRegion","results","templateResult","templateMatching","siftResult","simplifiedSiftMatching","reduce","best","current","imageData","centerX","centerY","size","width","height","data","halfSize","floor","x1","max","y1","regionWidth","min","regionHeight","regionData","Uint8ClampedArray","srcIndex","dstIndex","searchX","searchY","refGray","toGrayscale","searchGray","normalizedCorrelation","refCorners","detectHarrisCorners","searchCorners","matches","matchCorners","transformation","calculateTransformation","dx","dy","imageRegion","grayData","Uint8Array","i","r","g","round","template","image","tWidth","tHeight","tData","iWidth","iHeight","iData","bestScore","bestX","bestY","score","calculateNCC","sumT","sumI","sumTI","sumT2","sumI2","n","tVal","iVal","meanT","meanI","numerator","denominator","grayImage","corners","response","calculateHarrisResponse","slice","Ixx","Iyy","Ixy","idx","Ix","Iy","trace","corners1","corners2","c1","bestMatch","bestDistance","Infinity","j","c2","distance","corner1","corner2","dxList","m","dyList","median","maxExpectedMatches","values","sorted","mid","calculateMatchingQuality","calibrationResults","averageConfidence","averageOffset","successfulMatches","totalAnnotations","qualityScore","filter","totalConfidence","sum","totalOffset"],"mappings":"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"}