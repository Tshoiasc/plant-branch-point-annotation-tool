{"version":3,"file":"index-legacy-DPzU8gji.js","sources":["../../src/core/HttpFileSystemManager.js","../../src/core/AnnotationStorageManager.js","../../src/core/TimeSeriesAnnotationManager.js","../../src/core/PlantDataManager.js","../../src/core/AnnotationTool.js","../../src/core/BranchPointPreviewManager.js","../../src/core/NoteManager.js","../../src/core/NoteUI.js","../../src/core/AnnotationManager.js","../../src/utils/BulkLoadingPerformanceMonitor.js","../../src/core/RealTimeSyncManager.js","../../src/core/CustomAnnotationToolbarController.js","../../src/core/CustomAnnotationSettingsController.js","../../src/main.js"],"sourcesContent":["/**\n * HTTP文件系统管理器\n * \n * 功能：\n * - 通过HTTP请求与后端通信\n * - 替代直接文件系统访问\n * - 支持植物数据和标注文件管理\n */\n\nexport class HttpFileSystemManager {\n  constructor() {\n    this.baseUrl = 'http://localhost:3003/api';\n    this.datasetPath = '/Users/tshoiasc/Brassica napus dataset/dataset';\n    this.isInitialized = false;\n    this.maxRetries = 3;\n    this.retryDelay = 1000;\n    this.connectionTimeout = 5000;\n    this.lastConnectionCheck = 0;\n    this.connectionCheckInterval = 30000;\n  }\n\n  /**\n   * 初始化管理器，带重试机制\n   */\n  async initialize() {\n    return this.withRetry(async () => {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.connectionTimeout);\n      \n      try {\n        const response = await fetch(`${this.baseUrl}/health`, {\n          signal: controller.signal,\n          headers: { 'Cache-Control': 'no-cache' }\n        });\n        \n        clearTimeout(timeoutId);\n        \n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n        \n        const result = await response.json();\n        \n        if (result.success) {\n          this.isInitialized = true;\n          this.lastConnectionCheck = Date.now();\n          console.log('HttpFileSystemManager 初始化成功');\n          return true;\n        }\n        \n        throw new Error('Backend server responded but reported failure');\n      } catch (error) {\n        clearTimeout(timeoutId);\n        if (error.name === 'AbortError') {\n          throw new Error(`连接超时 (${this.connectionTimeout}ms)`);\n        }\n        throw error;\n      }\n    }, '初始化管理器');\n  }\n\n  /**\n   * 检查是否支持（始终返回true，因为使用HTTP）\n   */\n  static isSupported() {\n    return true;\n  }\n\n  /**\n   * 重试机制包装器\n   */\n  async withRetry(operation, operationName = '操作', maxRetries = this.maxRetries) {\n    let lastError;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        if (attempt > 1) {\n          console.log(`${operationName} 重试第 ${attempt - 1} 次...`);\n          await this.delay(this.retryDelay * attempt);\n        }\n        \n        return await operation();\n      } catch (error) {\n        lastError = error;\n        \n        if (this.isConnectionError(error) && attempt < maxRetries) {\n          console.warn(`${operationName} 失败 (尝试 ${attempt}/${maxRetries}):`, error.message);\n          continue;\n        }\n        \n        console.error(`${operationName} 最终失败:`, error);\n        throw error;\n      }\n    }\n    \n    throw lastError;\n  }\n  \n  /**\n   * 检查是否为连接错误\n   */\n  isConnectionError(error) {\n    return error.message.includes('Failed to fetch') ||\n           error.message.includes('ERR_CONNECTION_REFUSED') ||\n           error.message.includes('网络错误') ||\n           error.message.includes('连接超时') ||\n           error.name === 'TypeError' && error.message.includes('fetch');\n  }\n  \n  /**\n   * 延迟函数\n   */\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  /**\n   * 检查连接状态\n   */\n  async checkConnection() {\n    const now = Date.now();\n    if (now - this.lastConnectionCheck < this.connectionCheckInterval) {\n      return this.isInitialized;\n    }\n    \n    try {\n      const controller = new AbortController();\n      setTimeout(() => controller.abort(), 2000);\n      \n      const response = await fetch(`${this.baseUrl}/health`, {\n        signal: controller.signal,\n        headers: { 'Cache-Control': 'no-cache' }\n      });\n      \n      const isConnected = response.ok;\n      this.isInitialized = isConnected;\n      this.lastConnectionCheck = now;\n      \n      return isConnected;\n    } catch (error) {\n      this.isInitialized = false;\n      this.lastConnectionCheck = now;\n      return false;\n    }\n  }\n  \n  /**\n   * 获取数据集信息\n   */\n  async getDatasetInfo() {\n    await this.ensureConnection();\n    \n    return this.withRetry(async () => {\n      const response = await fetch(`${this.baseUrl}/dataset-info`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        return result.data;\n      }\n      \n      throw new Error(result.error || '获取数据集信息失败');\n    }, '获取数据集信息');\n  }\n  \n  /**\n   * 确保连接可用\n   */\n  async ensureConnection() {\n    if (!(await this.checkConnection())) {\n      throw new Error('后端服务连接不可用，请确保服务器正在运行在 http://localhost:3003');\n    }\n  }\n\n  /**\n   * 遍历植物文件夹\n   */\n  async traversePlantDirectories() {\n    await this.ensureConnection();\n    \n    return this.withRetry(async () => {\n      const response = await fetch(`${this.baseUrl}/plant-directories`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`找到 ${result.data.length} 个有效植物文件夹`);\n        return result.data;\n      }\n      \n      throw new Error(result.error || '遍历植物文件夹失败');\n    }, '遍历植物文件夹');\n  }\n\n  /**\n   * 读取植物的图像文件\n   */\n  async readPlantImages(plantId) {\n    if (!plantId) {\n      throw new Error('植物ID不能为空');\n    }\n    \n    await this.ensureConnection();\n    \n    return this.withRetry(async () => {\n      const response = await fetch(`${this.baseUrl}/plant-images/${encodeURIComponent(plantId)}`);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        const imagesByView = result.data;\n        \n        const totalImages = Object.values(imagesByView).reduce((total, images) => total + images.length, 0);\n        console.log(`植物 ${plantId} 总共 ${totalImages} 张图像`);\n        \n        return imagesByView;\n      }\n      \n      throw new Error(result.error || '读取植物图像失败');\n    }, `读取植物 ${plantId} 图像`);\n  }\n\n  /**\n   * 获取图像文件URL\n   */\n  getImageUrl(plantId, viewAngle, imageName) {\n    return `${this.baseUrl}/image/${plantId}/${viewAngle}/${imageName}`;\n  }\n\n  /**\n   * 创建图像URL (替代createImageURL)\n   */\n  async createImageURL(imageData) {\n    try {\n      console.log('创建图像URL，imageData:', imageData);\n      \n      // 从imageData中提取信息\n      const parts = imageData.id.split('_');\n      console.log('图像ID分割结果:', parts);\n      \n      if (parts.length >= 3) {\n        const plantId = parts[0];\n        const viewAngle = parts[1];\n        const imageName = parts.slice(2).join('_'); // 处理文件名中可能包含下划线的情况\n        \n        const imageUrl = this.getImageUrl(plantId, viewAngle, imageName);\n        console.log('生成的图像URL:', imageUrl);\n        \n        return imageUrl;\n      }\n      \n      throw new Error(`Invalid image data format. ID: ${imageData.id}, expected format: plantId_viewAngle_imageName`);\n    } catch (error) {\n      console.error(`创建图像URL失败 ${imageData.name}:`, error);\n      console.error('imageData:', imageData);\n      throw error;\n    }\n  }\n\n  /**\n   * 保存标注文件\n   */\n  async saveAnnotationFile(imageId, annotationData) {\n    if (!imageId) {\n      throw new Error('图像ID不能为空');\n    }\n    if (!annotationData) {\n      throw new Error('标注数据不能为空');\n    }\n    \n    await this.ensureConnection();\n    \n    return this.withRetry(async () => {\n      const response = await fetch(`${this.baseUrl}/annotation/${encodeURIComponent(imageId)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ annotationData })\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`保存标注文件: ${imageId}`);\n        return true;\n      }\n      \n      throw new Error(result.error || '保存标注文件失败');\n    }, `保存标注文件 ${imageId}`);\n  }\n\n  /**\n   * 读取标注文件\n   */\n  async loadAnnotationFile(imageId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/annotation/${imageId}`);\n      const result = await response.json();\n      \n      if (result.success) {\n        if (result.data) {\n          console.log(`[标注] 成功读取 ${imageId}, 包含 ${result.data.annotations?.length || 0} 个标注点`);\n        }\n        return result.data;\n      }\n      \n      throw new Error(result.error || '读取标注文件失败');\n    } catch (error) {\n      console.error(`[标注] 读取标注文件失败 (${imageId}):`, error);\n      return null;\n    }\n  }\n\n  /**\n   * 获取所有标注文件列表\n   */\n  async getAllAnnotationFiles() {\n    try {\n      const response = await fetch(`${this.baseUrl}/annotations`);\n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`[标注] 扫描完成，找到 ${result.data.length} 个标注文件`);\n        return result.data;\n      }\n      \n      throw new Error(result.error || '获取标注文件列表失败');\n    } catch (error) {\n      console.error('[标注] 获取标注文件列表失败:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 删除标注文件\n   */\n  async deleteAnnotationFile(imageId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/annotation/${imageId}`, {\n        method: 'DELETE'\n      });\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`删除标注文件: ${imageId}`);\n        return true;\n      }\n      \n      throw new Error(result.error || '删除标注文件失败');\n    } catch (error) {\n      console.error(`删除标注文件失败 (${imageId}):`, error);\n      return false;\n    }\n  }\n\n  /**\n   * 获取目录统计信息\n   */\n  async getDirectoryStats(dirPath = null) {\n    try {\n      const url = dirPath ? \n        `${this.baseUrl}/directory-stats?dirPath=${encodeURIComponent(dirPath)}` : \n        `${this.baseUrl}/directory-stats`;\n      \n      const response = await fetch(url);\n      const result = await response.json();\n      \n      if (result.success) {\n        return result.data;\n      }\n      \n      throw new Error(result.error || '获取目录统计失败');\n    } catch (error) {\n      console.error('获取目录统计失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 检查是否为图像文件\n   */\n  isImageFile(filename) {\n    const imageExtensions = ['.png', '.jpg', '.jpeg', '.bmp', '.tiff', '.webp'];\n    const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));\n    return imageExtensions.includes(ext);\n  }\n\n  /**\n   * 解析图像文件名中的时间信息\n   */\n  parseImageDateTime(filename) {\n    const regex = /BR\\d+-\\d+-(\\d{4}-\\d{2}-\\d{2})_(\\d{2})_VIS_sv_\\d+/;\n    const match = filename.match(regex);\n    \n    if (match) {\n      const dateStr = match[1];\n      const hourStr = match[2];\n      const dateTime = new Date(`${dateStr}T${hourStr}:00:00`);\n      return dateTime;\n    }\n    \n    console.warn(`无法解析文件名时间信息: ${filename}`);\n    return new Date(0);\n  }\n\n  /**\n   * 格式化图像时间显示 - 🔧 FIXED: Only show date, no time\n   */\n  formatImageTime(filename) {\n    const regex = /BR\\d+-\\d+-(\\d{4}-\\d{2}-\\d{2})_(\\d{2})_VIS_sv_\\d+/;\n    const match = filename.match(regex);\n    \n    if (match) {\n      const dateStr = match[1];\n      const hourStr = match[2];\n      const date = new Date(`${dateStr}T${hourStr}:00:00`);\n      // 🔧 FIX: Remove time portion, only show year/month/day\n      return `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;\n    }\n    \n    return filename;\n  }\n\n  /**\n   * 获取所有跳过信息\n   */\n  async getAllSkipInfo() {\n    try {\n      const response = await fetch(`${this.baseUrl}/skip-info`);\n      const result = await response.json();\n      \n      if (result.success) {\n        return result.data;\n      }\n      \n      throw new Error(result.error || '获取跳过信息失败');\n    } catch (error) {\n      console.error('获取跳过信息失败:', error);\n      return {};\n    }\n  }\n\n  /**\n   * 获取特定植物的跳过信息\n   */\n  async getSkipInfo(plantId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/skip-info/${plantId}`);\n      const result = await response.json();\n      \n      if (result.success) {\n        return result.data;\n      }\n      \n      throw new Error(result.error || '获取跳过信息失败');\n    } catch (error) {\n      console.error(`获取植物 ${plantId} 跳过信息失败:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * 保存植物跳过信息\n   */\n  async saveSkipInfo(plantId, skipData) {\n    try {\n      const response = await fetch(`${this.baseUrl}/skip-info/${plantId}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ skipData })\n      });\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`保存跳过信息: ${plantId}`);\n        return true;\n      }\n      \n      throw new Error(result.error || '保存跳过信息失败');\n    } catch (error) {\n      console.error(`保存植物 ${plantId} 跳过信息失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 删除植物跳过信息\n   */\n  async deleteSkipInfo(plantId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/skip-info/${plantId}`, {\n        method: 'DELETE'\n      });\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`删除跳过信息: ${plantId}`);\n        return true;\n      }\n      \n      throw new Error(result.error || '删除跳过信息失败');\n    } catch (error) {\n      console.error(`删除植物 ${plantId} 跳过信息失败:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * 🔧 FIX: Get plant status from dedicated API\n   */\n  async getPlantStatus(plantId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/plant-status/${plantId}`);\n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`[植物状态] 从API获取植物 ${plantId} 状态: ${result.data?.status || 'null'}`);\n        return result.data;\n      }\n      \n      // If no status found, return null (not an error)\n      if (response.status === 404 || result.message?.includes('未找到')) {\n        console.log(`[植物状态] 植物 ${plantId} 无状态信息`);\n        return null;\n      }\n      \n      throw new Error(result.error || '获取植物状态失败');\n    } catch (error) {\n      console.error(`获取植物 ${plantId} 状态失败:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * 🔧 FIX: Save plant status to dedicated API\n   */\n  async savePlantStatus(plantId, status) {\n    try {\n      const response = await fetch(`${this.baseUrl}/plant-status/${plantId}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ \n          status, \n          lastModified: new Date().toISOString() \n        })\n      });\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`[植物状态] 保存植物 ${plantId} 状态: ${status}`);\n        return true;\n      }\n      \n      throw new Error(result.error || '保存植物状态失败');\n    } catch (error) {\n      console.error(`保存植物 ${plantId} 状态失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 FIX: Delete plant status from dedicated API\n   */\n  async deletePlantStatus(plantId) {\n    try {\n      const response = await fetch(`${this.baseUrl}/plant-status/${plantId}`, {\n        method: 'DELETE'\n      });\n      \n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`[植物状态] 删除植物 ${plantId} 状态`);\n        return true;\n      }\n      \n      throw new Error(result.error || '删除植物状态失败');\n    } catch (error) {\n      console.error(`删除植物 ${plantId} 状态失败:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * 清理资源（HTTP版本不需要实际清理）\n   */\n  cleanup() {\n    console.log('HttpFileSystemManager 清理完成');\n  }\n\n  /**\n   * 兼容性方法：获取annotations目录（HTTP版本返回虚拟状态）\n   */\n  getAnnotationsDirectory() {\n    return this.isInitialized ? { exists: true } : null;\n  }\n\n  /**\n   * 兼容性方法：确保annotations目录存在\n   */\n  async ensureAnnotationsDirectory() {\n    // HTTP版本中，后端自动处理目录创建\n    return { exists: true };\n  }\n}","/**\n * 标注数据存储管理器\n * \n * 功能：\n * - 将标注数据保存为JSON文件到项目目录\n * - 从JSON文件加载标注数据\n * - 提供导出功能\n * - 管理标注历史和备份\n */\n\nexport class AnnotationStorageManager {\n  constructor() {\n    this.apiBaseUrl = 'http://localhost:3002/api'; // 本地存储服务器\n    this.annotations = new Map();\n    this.imageAnnotations = new Map(); // 新增：按图像ID存储标注\n    this.isInitialized = false;\n    this.fileSystemManager = null; // 文件系统管理器\n    this.useFileSystem = false; // 是否使用文件系统存储\n  }\n\n  /**\n   * 设置文件系统管理器\n   */\n  setFileSystemManager(fileSystemManager) {\n    this.fileSystemManager = fileSystemManager;\n    this.useFileSystem = !!fileSystemManager;\n    console.log('[标注] 文件系统存储已启用');\n\n    // 检查annotations目录句柄是否存在\n    if (fileSystemManager) {\n      const annotationsHandle = fileSystemManager.getAnnotationsDirectory();\n      console.log(`[标注] setFileSystemManager: annotations句柄${annotationsHandle ? '存在' : '不存在'}`);\n    }\n  }\n\n  /**\n   * 初始化存储管理器\n   */\n  async initialize() {\n    try {\n      if (this.useFileSystem && this.fileSystemManager) {\n        // 文件系统模式：扫描标注文件但不预加载到内存\n        await this.scanAnnotationFiles();\n        console.log('AnnotationStorageManager 初始化完成 (文件系统模式)');\n        this.isInitialized = true;\n        return;\n      }\n\n      // 如果没有启用文件系统，尝试服务器模式\n      try {\n        await this.loadAnnotationsFromServer();\n        await this.loadImageAnnotationsFromServer();\n        console.log('AnnotationStorageManager 初始化完成 (服务器模式)');\n      } catch (serverError) {\n        console.warn('服务器模式初始化失败，使用localStorage模式:', serverError.message);\n        // 尝试从localStorage恢复数据\n        this.loadFromLocalStorage();\n        this.loadImageAnnotationsFromLocalStorage();\n        console.log('AnnotationStorageManager 初始化完成 (localStorage模式)');\n      }\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('初始化标注存储管理器失败:', error);\n      this.isInitialized = true; // 即使失败也标记为已初始化，避免重复初始化\n    }\n  }\n\n  /**\n   * 从服务器加载标注数据\n   */\n  async loadAnnotationsFromServer() {\n    try {\n      const response = await fetch(`${this.apiBaseUrl}/load-annotations`);\n      const result = await response.json();\n      \n      if (result.success && result.data) {\n        // 将数据加载到Map中\n        for (const [plantId, annotationData] of Object.entries(result.data.annotations || {})) {\n          this.annotations.set(plantId, annotationData);\n        }\n        \n        console.log(`从服务器加载了 ${this.annotations.size} 个植物的标注数据`);\n        return result.data;\n      } else {\n        throw new Error(result.error || '加载标注数据失败');\n      }\n    } catch (error) {\n      console.warn('从服务器加载标注数据失败，尝试从localStorage恢复:', error.message);\n      this.loadFromLocalStorage();\n      return { annotations: {} };\n    }\n  }\n\n  /**\n   * 保存标注数据到服务器\n   */\n  async saveAnnotationsToServer() {\n    try {\n      const exportData = {\n        saveTime: new Date().toISOString(),\n        totalPlants: this.annotations.size,\n        annotations: {}\n      };\n\n      // 转换Map为普通对象\n      for (const [plantId, annotationData] of this.annotations) {\n        exportData.annotations[plantId] = annotationData;\n      }\n\n      // 发送保存请求到本地服务器\n      const response = await fetch(`${this.apiBaseUrl}/save-annotations`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(exportData)\n      });\n\n      const result = await response.json();\n      \n      if (result.success) {\n        console.log(`成功保存 ${this.annotations.size} 个植物的标注数据到服务器`);\n        // 同时备份到localStorage\n        this.saveToLocalStorage();\n        return true;\n      } else {\n        throw new Error(result.error || '服务器保存失败');\n      }\n    } catch (error) {\n      console.error('保存标注数据到服务器失败:', error);\n      // 如果无法保存到服务器，至少保存到localStorage作为备份\n      this.saveToLocalStorage();\n      return false;\n    }\n  }\n\n  /**\n   * 保存到localStorage作为备份\n   */\n  saveToLocalStorage() {\n    try {\n      const data = {};\n      for (const [plantId, annotationData] of this.annotations) {\n        data[plantId] = annotationData;\n      }\n      localStorage.setItem('plant_annotations_backup', JSON.stringify({\n        saveTime: new Date().toISOString(),\n        annotations: data\n      }));\n      console.log('标注数据已备份到localStorage');\n    } catch (error) {\n      console.error('备份到localStorage失败:', error);\n    }\n  }\n\n  /**\n   * 从localStorage恢复数据\n   */\n  loadFromLocalStorage() {\n    try {\n      const backup = localStorage.getItem('plant_annotations_backup');\n      if (backup) {\n        const data = JSON.parse(backup);\n        for (const [plantId, annotationData] of Object.entries(data.annotations || {})) {\n          if (!this.annotations.has(plantId)) {\n            this.annotations.set(plantId, annotationData);\n          }\n        }\n        console.log('从localStorage恢复了备份数据');\n      }\n    } catch (error) {\n      console.error('从localStorage恢复数据失败:', error);\n    }\n  }\n\n  /**\n   * 保存植物标注数据\n   */\n  async savePlantAnnotations(plantId, annotations, plantInfo = {}) {\n    const annotationData = {\n      plantId,\n      annotations, // 当前选中图像的标注\n      selectedImage: plantInfo.selectedImage?.name || null,\n      selectedImagePath: plantInfo.selectedImage?.id || null,\n      viewAngle: plantInfo.selectedViewAngle || null,\n      status: annotations.length > 0 ? 'completed' : 'in-progress',\n      lastModified: new Date().toISOString(),\n      imageDateTime: plantInfo.selectedImage?.dateTime || null,\n      keypointCount: annotations.length,\n      \n      // 时间序列数据支持\n      timeSeriesData: plantInfo.timeSeriesData || null,\n      isTimeSeriesEnabled: !!plantInfo.timeSeriesData,\n      \n      // 完整的视角和时间序列信息\n      plantViewAngles: plantInfo.plantViewAngles || [], // 植株所有可用的视角\n      selectedViewAngleHistory: plantInfo.selectedViewAngleHistory || {}, // 每个视角的选择历史\n      timeSeriesMetadata: plantInfo.timeSeriesMetadata || {} // 时间序列元数据\n    };\n\n    this.annotations.set(plantId, annotationData);\n    \n    // 自动保存到文件\n    await this.saveAnnotationsToServer();\n    \n    return annotationData;\n  }\n\n  /**\n   * 获取植物标注数据\n   */\n  getPlantAnnotations(plantId) {\n    const data = this.annotations.get(plantId);\n    return data ? data.annotations : [];\n  }\n\n  /**\n   * 获取植物标注状态\n   */\n  getPlantStatus(plantId) {\n    const data = this.annotations.get(plantId);\n    if (!data) return 'pending';\n    \n    return data.annotations.length > 0 ? 'completed' : 'in-progress';\n  }\n\n  /**\n   * 获取所有已标注的植物ID\n   */\n  getAnnotatedPlantIds() {\n    return Array.from(this.annotations.keys());\n  }\n\n  /**\n   * 保存植株跳过信息\n   */\n  async saveSkipInfo(plantId, skipInfo) {\n    try {\n      // 获取或创建植株标注数据\n      let annotationData = this.annotations.get(plantId);\n      if (!annotationData) {\n        annotationData = {\n          plantId,\n          annotations: [],\n          lastModified: new Date().toISOString(),\n          createdAt: new Date().toISOString(),\n          selectedViewAngle: null,\n          selectedImage: null,\n          plantViewAngles: [],\n          selectedViewAngleHistory: {},\n          timeSeriesMetadata: {}\n        };\n      }\n\n      // 更新跳过信息\n      annotationData.status = skipInfo.status;\n      annotationData.skipReason = skipInfo.skipReason;\n      annotationData.skipDate = skipInfo.skipDate;\n      annotationData.lastModified = skipInfo.lastModified;\n\n      this.annotations.set(plantId, annotationData);\n\n      // 保存到文件系统或HTTP后端\n      if (this.useFileSystem && this.fileSystemManager.saveSkipInfo) {\n        try {\n          // HTTP模式：通过API保存跳过信息\n          await this.fileSystemManager.saveSkipInfo(plantId, annotationData);\n          console.log(`植株 ${plantId} 跳过信息已保存到后端`);\n        } catch (apiError) {\n          console.warn('后端保存失败，使用localStorage备份:', apiError);\n          this.saveToLocalStorage();\n          console.log(`植株 ${plantId} 跳过信息已备份到localStorage`);\n        }\n      } else if (this.fileSystemManager && this.fileSystemManager.getAnnotationsDirectory()) {\n        try {\n          // 原有的文件系统模式\n          const fileName = `${plantId}_skip_info.json`;\n          const annotationsHandle = this.fileSystemManager.getAnnotationsDirectory();\n          const fileHandle = await annotationsHandle.getFileHandle(fileName, { create: true });\n          const writable = await fileHandle.createWritable();\n\n          await writable.write(JSON.stringify(annotationData, null, 2));\n          await writable.close();\n\n          console.log(`植株 ${plantId} 跳过信息已保存到文件系统: ${fileName}`);\n        } catch (fsError) {\n          console.warn('文件系统保存失败，使用localStorage备份:', fsError);\n          this.saveToLocalStorage();\n          console.log(`植株 ${plantId} 跳过信息已备份到localStorage`);\n        }\n      } else {\n        // 如果文件系统不可用，保存到localStorage\n        this.saveToLocalStorage();\n        console.log(`植株 ${plantId} 跳过信息已保存到localStorage`);\n      }\n\n    } catch (error) {\n      console.error(`保存植株 ${plantId} 跳过信息失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 NEW: 移除植株跳过信息\n   */\n  async removeSkipInfo(plantId) {\n    try {\n      // 从内存中移除跳过状态\n      const annotationData = this.annotations.get(plantId);\n      if (annotationData) {\n        delete annotationData.status;\n        delete annotationData.skipReason;\n        delete annotationData.skipDate;\n        annotationData.lastModified = new Date().toISOString();\n        \n        // 如果没有其他数据，完全移除\n        if (!annotationData.annotations || annotationData.annotations.length === 0) {\n          this.annotations.delete(plantId);\n        }\n      }\n\n      // 从文件系统或HTTP后端移除\n      if (this.useFileSystem && this.fileSystemManager.deleteSkipInfo) {\n        try {\n          // HTTP模式：通过API移除跳过信息\n          await this.fileSystemManager.deleteSkipInfo(plantId);\n          console.log(`植株 ${plantId} 跳过信息已从后端移除`);\n        } catch (apiError) {\n          console.warn('后端移除失败，使用localStorage清理:', apiError);\n          this.saveToLocalStorage();\n          console.log(`植株 ${plantId} 跳过信息已从localStorage清理`);\n        }\n      } else if (this.fileSystemManager && this.fileSystemManager.getAnnotationsDirectory()) {\n        try {\n          // 原有的文件系统模式：删除跳过信息文件\n          const fileName = `${plantId}_skip_info.json`;\n          const annotationsHandle = this.fileSystemManager.getAnnotationsDirectory();\n          \n          try {\n            await annotationsHandle.removeEntry(fileName);\n            console.log(`植株 ${plantId} 跳过信息文件已删除: ${fileName}`);\n          } catch (removeError) {\n            // 文件不存在是正常的\n            if (removeError.name !== 'NotFoundError') {\n              throw removeError;\n            }\n            console.log(`植株 ${plantId} 跳过信息文件不存在，无需删除`);\n          }\n        } catch (fsError) {\n          console.warn('文件系统删除失败，使用localStorage清理:', fsError);\n          this.saveToLocalStorage();\n          console.log(`植株 ${plantId} 跳过信息已从localStorage清理`);\n        }\n      } else {\n        // 如果文件系统不可用，从localStorage清理\n        this.saveToLocalStorage();\n        console.log(`植株 ${plantId} 跳过信息已从localStorage清理`);\n      }\n\n    } catch (error) {\n      console.error(`移除植株 ${plantId} 跳过信息失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 FIX: Save plant status independently of annotations\n   */\n  async savePlantStatus(plantId, status) {\n    try {\n      // 获取或创建植株数据\n      let annotationData = this.annotations.get(plantId);\n      if (!annotationData) {\n        annotationData = {\n          plantId,\n          annotations: [],\n          lastModified: new Date().toISOString(),\n          createdAt: new Date().toISOString(),\n          selectedViewAngle: null,\n          selectedImage: null,\n          plantViewAngles: [],\n          selectedViewAngleHistory: {},\n          timeSeriesMetadata: {}\n        };\n      }\n\n      // 更新状态和时间戳\n      annotationData.status = status;\n      annotationData.lastModified = new Date().toISOString();\n\n      this.annotations.set(plantId, annotationData);\n\n      // 🔧 FIX: Use dedicated plant status API instead of skip-info API\n      if (this.useFileSystem && this.fileSystemManager.savePlantStatus) {\n        try {\n          // HTTP模式：通过专用植物状态API保存\n          await this.fileSystemManager.savePlantStatus(plantId, status);\n          console.log(`植株 ${plantId} 状态 ${status} 已保存到专用API`);\n        } catch (apiError) {\n          console.warn('植物状态API保存失败，使用localStorage备份:', apiError);\n          this.saveToLocalStorage();\n          console.log(`植株 ${plantId} 状态已备份到localStorage`);\n        }\n      } else if (this.fileSystemManager && this.fileSystemManager.getAnnotationsDirectory()) {\n        try {\n          // 文件系统模式：保存为独立的状态文件\n          const fileName = `${plantId}_status.json`;\n          const annotationsHandle = this.fileSystemManager.getAnnotationsDirectory();\n          const fileHandle = await annotationsHandle.getFileHandle(fileName, { create: true });\n          const writable = await fileHandle.createWritable();\n\n          const statusData = {\n            plantId,\n            status,\n            lastModified: new Date().toISOString(),\n            timestamp: new Date().toISOString()\n          };\n\n          await writable.write(JSON.stringify(statusData, null, 2));\n          await writable.close();\n\n          console.log(`植株 ${plantId} 状态 ${status} 已保存到文件系统: ${fileName}`);\n        } catch (fsError) {\n          console.warn('文件系统保存状态失败，使用localStorage备份:', fsError);\n          this.saveToLocalStorage();\n          console.log(`植株 ${plantId} 状态已备份到localStorage`);\n        }\n      } else {\n        // 如果文件系统不可用，保存到localStorage\n        this.saveToLocalStorage();\n        console.log(`植株 ${plantId} 状态 ${status} 已保存到localStorage`);\n      }\n\n      console.log(`[植物状态] ${plantId}: ${status} (独立保存完成)`);\n\n    } catch (error) {\n      console.error(`保存植株 ${plantId} 状态失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 FIX: Load plant status independently for status restoration\n   */\n  async loadPlantStatus(plantId) {\n    try {\n      console.log(`[状态加载] 开始为植物 ${plantId} 加载状态...`);\n      console.log(`[状态加载] useFileSystem: ${this.useFileSystem}, fileSystemManager存在: ${!!this.fileSystemManager}`);\n      \n      // First check if we have status in memory\n      const existingData = this.annotations.get(plantId);\n      if (existingData && existingData.status) {\n        console.log(`[植物状态] ${plantId}: 从内存加载状态 ${existingData.status}`);\n        return existingData.status;\n      }\n\n      // 🔧 FIX: Try to load from dedicated plant status API first\n      if (this.useFileSystem && this.fileSystemManager.getPlantStatus) {\n        try {\n          console.log(`[状态加载] 尝试从专用API加载植物 ${plantId} 状态...`);\n          const statusData = await this.fileSystemManager.getPlantStatus(plantId);\n          console.log(`[状态加载] 专用API响应:`, statusData);\n          if (statusData && statusData.status) {\n            console.log(`[植物状态] ${plantId}: 从专用API加载状态 ${statusData.status}`);\n            return statusData.status;\n          }\n        } catch (apiError) {\n          console.warn(`从专用API加载植株 ${plantId} 状态失败:`, apiError);\n        }\n      } else {\n        console.log(`[状态加载] 跳过专用API: useFileSystem=${this.useFileSystem}, getPlantStatus存在=${!!this.fileSystemManager?.getPlantStatus}`);\n      }\n\n      // Fallback: Try to load from skip-info API for backwards compatibility\n      if (this.useFileSystem && this.fileSystemManager.getSkipInfo) {\n        try {\n          const data = await this.fileSystemManager.getSkipInfo(plantId);\n          if (data && data.status) {\n            console.log(`[植物状态] ${plantId}: 从skip-info API加载状态 ${data.status} (向后兼容)`);\n            return data.status;\n          }\n        } catch (skipError) {\n          console.warn(`从skip-info API加载植株 ${plantId} 状态失败:`, skipError);\n        }\n      } else if (this.fileSystemManager && this.fileSystemManager.getAnnotationsDirectory()) {\n        try {\n          // 文件系统模式：尝试加载状态文件\n          const fileName = `${plantId}_status.json`;\n          const annotationsHandle = this.fileSystemManager.getAnnotationsDirectory();\n          const fileHandle = await annotationsHandle.getFileHandle(fileName);\n          const file = await fileHandle.getFile();\n          const content = await file.text();\n          const statusData = JSON.parse(content);\n          \n          if (statusData.status) {\n            console.log(`[植物状态] ${plantId}: 从文件系统加载状态 ${statusData.status}`);\n            return statusData.status;\n          }\n        } catch (fsError) {\n          // Status file doesn't exist, this is normal for pending plants\n          console.log(`[植物状态] ${plantId}: 无状态文件，使用默认状态`);\n        }\n      }\n\n      // Fallback to localStorage\n      try {\n        const localData = localStorage.getItem('plantAnnotations');\n        if (localData) {\n          const parsed = JSON.parse(localData);\n          if (parsed[plantId] && parsed[plantId].status) {\n            console.log(`[植物状态] ${plantId}: 从localStorage加载状态 ${parsed[plantId].status}`);\n            return parsed[plantId].status;\n          }\n        }\n      } catch (localError) {\n        console.warn('从localStorage加载状态失败:', localError);\n      }\n\n      // Return null if no status found (let calling code decide default)\n      console.log(`[植物状态] ${plantId}: 未找到持久化状态`);\n      return null;\n\n    } catch (error) {\n      console.error(`加载植株 ${plantId} 状态失败:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * 检查植物是否有标注数据\n   */\n  hasAnnotations(plantId) {\n    const data = this.annotations.get(plantId);\n    return data && data.annotations.length > 0;\n  }\n\n  /**\n   * 删除植物标注数据\n   */\n  async deletePlantAnnotations(plantId) {\n    this.annotations.delete(plantId);\n    await this.saveAnnotationsToServer();\n  }\n\n  /**\n   * 获取标注进度统计\n   */\n  getAnnotationStats(totalPlants) {\n    const annotatedCount = this.getAnnotatedPlantIds().length;\n    const completedCount = Array.from(this.annotations.values())\n      .filter(data => data.annotations.length > 0).length;\n\n    return {\n      total: totalPlants,\n      annotated: annotatedCount,\n      completed: completedCount,\n      pending: totalPlants - annotatedCount,\n      completionRate: totalPlants > 0 ? (completedCount / totalPlants * 100).toFixed(1) : 0\n    };\n  }\n\n  /**\n   * 导出所有标注数据\n   */\n  exportAllAnnotations() {\n    const exportData = {\n      exportTime: new Date().toISOString(),\n      version: '1.0',\n      totalPlants: this.annotations.size,\n      annotations: {}\n    };\n\n    for (const [plantId, annotationData] of this.annotations) {\n      exportData.annotations[plantId] = {\n        ...annotationData,\n        exportedAt: new Date().toISOString()\n      };\n    }\n\n    return exportData;\n  }\n\n  /**\n   * 导出为JSON文件下载\n   */\n  downloadAnnotationsAsJSON() {\n    const exportData = this.exportAllAnnotations();\n    \n    const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n      type: 'application/json'\n    });\n    \n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `plant_annotations_${new Date().toISOString().split('T')[0]}.json`;\n    \n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    \n    URL.revokeObjectURL(url);\n    \n    return exportData;\n  }\n\n  /**\n   * 导出所有图像的纯净标注数据（新的简化版本）\n   * 返回格式：{ imageId: annotations[] }\n   */\n  async exportPureImageAnnotations() {\n    const pureImageAnnotations = {};\n    \n    // 直接从imageAnnotations导出\n    for (const [imageId, annotationData] of this.imageAnnotations) {\n      if (annotationData.annotations && annotationData.annotations.length > 0) {\n        pureImageAnnotations[imageId] = annotationData.annotations.map(annotation => ({\n          id: annotation.id,\n          x: annotation.x,\n          y: annotation.y,\n          timestamp: annotation.timestamp,\n          direction: annotation.direction || 'right', // 包含新的方向信息\n          order: annotation.order || 0 // 包含序号信息，兼容旧数据\n        }));\n      }\n    }\n    \n    console.log(`导出 ${Object.keys(pureImageAnnotations).length} 张图像的纯净标注数据`);\n    return pureImageAnnotations;\n  }\n\n  /**\n   * 下载纯净的图像标注数据为JSON文件\n   */\n  async downloadPureImageAnnotationsAsJSON() {\n    const pureAnnotations = await this.exportPureImageAnnotations();\n    const stats = this.getPureAnnotationsStats(pureAnnotations);\n    \n    const exportData = {\n      exportTime: new Date().toISOString(),\n      version: '2.0',\n      format: 'pure_image_annotations',\n      description: '每张图像对应的标注点数据，不包含内部管理信息',\n      stats: {\n        totalImages: stats.totalImages,\n        annotatedImages: stats.annotatedImages,\n        totalKeypoints: stats.totalKeypoints,\n        completionRate: stats.completionRate\n      },\n      annotations: pureAnnotations\n    };\n    \n    const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n      type: 'application/json'\n    });\n    \n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `pure_image_annotations_${new Date().toISOString().split('T')[0]}.json`;\n    \n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    \n    URL.revokeObjectURL(url);\n    \n    console.log(`导出了 ${stats.annotatedImages} 张图像的纯净标注数据，共 ${stats.totalKeypoints} 个关键点`);\n    \n    return exportData;\n  }\n\n  /**\n   * 获取纯净标注数据的统计信息\n   */\n  getPureAnnotationsStats(pureAnnotations) {\n    const totalImages = Object.keys(pureAnnotations).length;\n    let totalKeypoints = 0;\n    \n    for (const annotations of Object.values(pureAnnotations)) {\n      totalKeypoints += annotations.length;\n    }\n    \n    return {\n      totalImages,\n      annotatedImages: totalImages,\n      totalKeypoints,\n      averageKeypointsPerImage: totalImages > 0 ? (totalKeypoints / totalImages).toFixed(2) : 0,\n      completionRate: '100.0' // 只包含有标注的图像\n    };\n  }\n\n  /**\n   * 设置时间序列管理器的引用\n   */\n  setTimeSeriesManager(timeSeriesManager) {\n    this.timeSeriesManager = timeSeriesManager;\n  }\n\n  /**\n   * 清理所有标注数据\n   */\n  async clearAllAnnotations() {\n    this.annotations.clear();\n    await this.saveAnnotationsToServer();\n  }\n\n  /**\n   * 获取所有标注数据的摘要\n   */\n  getSummary() {\n    const summary = {\n      totalAnnotations: this.annotations.size,\n      completedPlants: 0,\n      totalKeypoints: 0,\n      lastModified: null\n    };\n\n    for (const [plantId, data] of this.annotations) {\n      if (data.annotations.length > 0) {\n        summary.completedPlants++;\n        summary.totalKeypoints += data.annotations.length;\n        \n        if (!summary.lastModified || data.lastModified > summary.lastModified) {\n          summary.lastModified = data.lastModified;\n        }\n      }\n    }\n\n    return summary;\n  }\n\n  /**\n   * 恢复时间序列数据到管理器\n   */\n  restoreTimeSeriesData(timeSeriesManager) {\n    for (const [plantId, data] of this.annotations) {\n      if (data.isTimeSeriesEnabled && data.timeSeriesData) {\n        try {\n          // 恢复时间序列标注数据\n          this.restorePlantTimeSeriesData(timeSeriesManager, plantId, data);\n          console.log(`恢复植株 ${plantId} 的时间序列数据`);\n        } catch (error) {\n          console.error(`恢复植株 ${plantId} 时间序列数据失败:`, error);\n        }\n      }\n    }\n  }\n\n  /**\n   * 恢复单个植株的时间序列数据\n   */\n  restorePlantTimeSeriesData(timeSeriesManager, plantId, annotationData) {\n    const { timeSeriesData, viewAngle } = annotationData;\n    \n    if (!timeSeriesData || !viewAngle) return;\n    \n    // 恢复时间序列结构\n    if (!timeSeriesManager.timeSequences.has(plantId)) {\n      timeSeriesManager.timeSequences.set(plantId, new Map());\n    }\n    \n    if (!timeSeriesManager.timeSeriesAnnotations.has(plantId)) {\n      timeSeriesManager.timeSeriesAnnotations.set(plantId, new Map());\n    }\n    \n    // 恢复时间序列\n    const imageIds = timeSeriesData.annotationData.map(item => item.imageId);\n    timeSeriesManager.timeSequences.get(plantId).set(viewAngle, imageIds);\n    \n    // 恢复标注数据\n    const viewAnnotations = new Map();\n    for (const item of timeSeriesData.annotationData) {\n      viewAnnotations.set(item.imageId, {\n        annotations: item.annotations,\n        timestamp: item.metadata.timestamp,\n        isManualAdjustment: item.metadata.isManualAdjustment,\n        inheritedFrom: item.metadata.inheritedFrom\n      });\n    }\n    \n    timeSeriesManager.timeSeriesAnnotations.get(plantId).set(viewAngle, viewAnnotations);\n    \n    // 恢复手动调整记录\n    const adjustmentKey = `${plantId}_${viewAngle}`;\n    if (!timeSeriesManager.manualAdjustments.has(adjustmentKey)) {\n      timeSeriesManager.manualAdjustments.set(adjustmentKey, new Set());\n    }\n    \n    const manualAdjustments = timeSeriesManager.manualAdjustments.get(adjustmentKey);\n    for (const item of timeSeriesData.annotationData) {\n      if (item.metadata.isManualAdjustment) {\n        manualAdjustments.add(item.imageId);\n      }\n    }\n  }\n\n  /**\n   * 获取植株的视角选择历史\n   */\n  getPlantViewAngleHistory(plantId) {\n    const data = this.annotations.get(plantId);\n    return data?.selectedViewAngleHistory || {};\n  }\n\n  /**\n   * 获取植株的完整标注摘要\n   */\n  getPlantAnnotationSummary(plantId) {\n    const data = this.annotations.get(plantId);\n    if (!data) return null;\n\n    const summary = {\n      plantId,\n      status: data.status,\n      lastModified: data.lastModified,\n      selectedViewAngle: data.viewAngle,\n      availableViewAngles: data.plantViewAngles || [],\n      isTimeSeriesEnabled: data.isTimeSeriesEnabled,\n      currentImageInfo: {\n        imageName: data.selectedImage,\n        imageId: data.selectedImagePath,\n        dateTime: data.imageDateTime\n      }\n    };\n\n    // 如果有时间序列数据，添加统计信息\n    if (data.timeSeriesData) {\n      summary.timeSeriesStats = {\n        totalImages: data.timeSeriesData.totalImages,\n        annotatedImages: data.timeSeriesData.annotationData.length,\n        manualAdjustments: data.timeSeriesData.annotationData.filter(\n          item => item.metadata.isManualAdjustment\n        ).length\n      };\n    }\n\n    return summary;\n  }\n\n  /**\n   * 保存图像标注数据\n   */\n  async saveImageAnnotation(imageId, annotationData) {\n    // 优先使用文件系统保存\n    if (this.useFileSystem) {\n      try {\n        const success = await this.saveImageAnnotationToFileSystem(imageId, annotationData);\n        if (success) {\n          console.log(`成功保存图像 ${imageId} 的标注数据到文件系统`);\n          // 只在文件系统保存成功时才更新内存（用于统计等功能）\n          this.imageAnnotations.set(imageId, annotationData);\n          // 备份到localStorage\n          this.saveImageAnnotationsToLocalStorage();\n          return true;\n        }\n      } catch (error) {\n        console.error(`保存图像 ${imageId} 标注数据到文件系统失败:`, error);\n      }\n    } else {\n      // 如果没有启用文件系统，更新内存\n      this.imageAnnotations.set(imageId, annotationData);\n    }\n\n    // 如果文件系统保存失败或未启用，尝试保存到服务器\n    try {\n      const response = await fetch(`${this.apiBaseUrl}/save-image-annotation`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          imageId,\n          annotationData\n        })\n      });\n\n      const result = await response.json();\n\n      if (result.success) {\n        console.log(`成功保存图像 ${imageId} 的标注数据到服务器`);\n        // 备份到localStorage\n        this.saveImageAnnotationsToLocalStorage();\n        return true;\n      } else {\n        throw new Error(result.error || '服务器保存失败');\n      }\n    } catch (error) {\n      console.error(`保存图像 ${imageId} 标注数据到服务器失败:`, error);\n      // 如果无法保存到服务器，至少保存到localStorage作为备份\n      this.saveImageAnnotationsToLocalStorage();\n      return false;\n    }\n  }\n\n  /**\n   * 获取图像标注数据\n   */\n  async getImageAnnotation(imageId) {\n    // 如果启用了文件系统，直接从文件系统读取\n    if (this.useFileSystem && this.fileSystemManager) {\n      try {\n        const annotationData = await this.fileSystemManager.loadAnnotationFile(imageId);\n        if (annotationData) {\n          console.log(`[标注] 读取成功 ${imageId}: ${annotationData.annotations?.length || 0} 个标注点`);\n        }\n        return annotationData;\n      } catch (error) {\n        console.warn(`从文件系统加载标注失败 (${imageId}):`, error);\n        return null;\n      }\n    }\n\n    // 如果没有启用文件系统，从内存中获取（向后兼容）\n    return this.imageAnnotations.get(imageId) || null;\n  }\n\n  /**\n   * 从服务器加载图像标注数据\n   */\n  async loadImageAnnotationsFromServer() {\n    try {\n      const response = await fetch(`${this.apiBaseUrl}/load-image-annotations`);\n      const result = await response.json();\n      \n      if (result.success && result.data) {\n        // 将数据加载到Map中\n        for (const [imageId, annotationData] of Object.entries(result.data.imageAnnotations || {})) {\n          this.imageAnnotations.set(imageId, annotationData);\n        }\n        \n        console.log(`从服务器加载了 ${this.imageAnnotations.size} 张图像的标注数据`);\n        return result.data;\n      } else {\n        console.log('服务器没有图像标注数据或加载失败');\n        return { imageAnnotations: {} };\n      }\n    } catch (error) {\n      console.warn('从服务器加载图像标注数据失败，尝试从localStorage恢复:', error.message);\n      this.loadImageAnnotationsFromLocalStorage();\n      return { imageAnnotations: {} };\n    }\n  }\n\n  /**\n   * 保存图像标注到localStorage作为备份\n   */\n  saveImageAnnotationsToLocalStorage() {\n    try {\n      const data = {};\n      for (const [imageId, annotationData] of this.imageAnnotations) {\n        data[imageId] = annotationData;\n      }\n      localStorage.setItem('image_annotations_backup', JSON.stringify({\n        saveTime: new Date().toISOString(),\n        imageAnnotations: data\n      }));\n      console.log('图像标注数据已备份到localStorage');\n    } catch (error) {\n      console.error('备份图像标注到localStorage失败:', error);\n    }\n  }\n\n  /**\n   * 从localStorage恢复图像标注数据\n   */\n  loadImageAnnotationsFromLocalStorage() {\n    try {\n      const backup = localStorage.getItem('image_annotations_backup');\n      if (backup) {\n        const data = JSON.parse(backup);\n        for (const [imageId, annotationData] of Object.entries(data.imageAnnotations || {})) {\n          if (!this.imageAnnotations.has(imageId)) {\n            this.imageAnnotations.set(imageId, annotationData);\n          }\n        }\n        console.log('从localStorage恢复了图像标注备份数据');\n      }\n    } catch (error) {\n      console.error('从localStorage恢复图像标注数据失败:', error);\n    }\n  }\n\n  /**\n   * 导出所有图像标注数据（新的简化版本）\n   */\n  exportAllImageAnnotations() {\n    const exportData = {\n      exportTime: new Date().toISOString(),\n      version: '2.0',\n      format: 'simple_image_annotations',\n      totalImages: this.imageAnnotations.size,\n      annotations: {}\n    };\n\n    for (const [imageId, annotationData] of this.imageAnnotations) {\n      if (annotationData.annotations && annotationData.annotations.length > 0) {\n        exportData.annotations[imageId] = annotationData.annotations;\n      }\n    }\n\n    return exportData;\n  }\n\n  /**\n   * 获取所有有标注的图像统计\n   */\n  getImageAnnotationStats() {\n    let annotatedImages = 0;\n    let totalKeypoints = 0;\n\n    for (const [imageId, annotationData] of this.imageAnnotations) {\n      if (annotationData.annotations && annotationData.annotations.length > 0) {\n        annotatedImages++;\n        totalKeypoints += annotationData.annotations.length;\n      }\n    }\n\n    return {\n      totalImages: this.imageAnnotations.size,\n      annotatedImages,\n      totalKeypoints,\n      averageKeypointsPerImage: annotatedImages > 0 ? (totalKeypoints / annotatedImages).toFixed(2) : 0\n    };\n  }\n\n  /**\n   * 从文件系统加载所有标注数据\n   */\n  async loadAnnotationsFromFileSystem() {\n    if (!this.fileSystemManager) {\n      throw new Error('文件系统管理器未设置');\n    }\n\n    console.log('开始从文件系统加载标注数据...');\n\n    try {\n      const imageIds = await this.fileSystemManager.getAllAnnotationFiles();\n      console.log(`发现 ${imageIds.length} 个标注文件:`, imageIds);\n\n      let loadedCount = 0;\n      for (const imageId of imageIds) {\n        try {\n          const annotationData = await this.fileSystemManager.loadAnnotationFile(imageId);\n          if (annotationData) {\n            this.imageAnnotations.set(imageId, annotationData);\n            loadedCount++;\n            console.log(`成功加载标注文件: ${imageId}, 包含 ${annotationData.annotations?.length || 0} 个标注点`);\n          }\n        } catch (error) {\n          console.error(`加载标注文件失败 (${imageId}):`, error);\n        }\n      }\n\n      console.log(`从文件系统加载了 ${loadedCount} 个图像的标注数据，总计 ${this.imageAnnotations.size} 个图像在内存中`);\n    } catch (error) {\n      console.error('从文件系统加载标注数据失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 保存图像标注到文件系统\n   */\n  async saveImageAnnotationToFileSystem(imageId, annotationData) {\n    if (!this.fileSystemManager) {\n      console.warn('文件系统管理器未设置，跳过文件系统保存');\n      return false;\n    }\n\n    try {\n      await this.fileSystemManager.saveAnnotationFile(imageId, annotationData);\n      return true;\n    } catch (error) {\n      console.error(`保存标注到文件系统失败 (${imageId}):`, error);\n      return false;\n    }\n  }\n\n  /**\n   * 从文件系统删除图像标注\n   */\n  async deleteImageAnnotationFromFileSystem(imageId) {\n    if (!this.fileSystemManager) {\n      return false;\n    }\n\n    try {\n      return await this.fileSystemManager.deleteAnnotationFile(imageId);\n    } catch (error) {\n      console.error(`从文件系统删除标注失败 (${imageId}):`, error);\n      return false;\n    }\n  }\n\n  /**\n   * 扫描标注文件（用于统计，不加载到内存）\n   */\n  async scanAnnotationFiles() {\n    if (!this.fileSystemManager) {\n      return;\n    }\n\n    try {\n      const imageIds = await this.fileSystemManager.getAllAnnotationFiles();\n      // 这里只是为了触发扫描和日志输出，不实际加载到内存\n      console.log(`[标注] 扫描完成，发现 ${imageIds.length} 个标注文件`);\n\n      // 扫描跳过信息文件\n      await this.scanSkipInfoFiles();\n    } catch (error) {\n      console.error('[标注] 扫描标注文件失败:', error);\n    }\n  }\n\n  /**\n   * 扫描跳过信息文件\n   */\n  async scanSkipInfoFiles() {\n    if (!this.fileSystemManager) {\n      return;\n    }\n\n    try {\n      if (this.useFileSystem && this.fileSystemManager.getAllSkipInfo) {\n        // HTTP模式：通过API获取跳过信息\n        const skipInfoData = await this.fileSystemManager.getAllSkipInfo();\n        \n        let skipFileCount = 0;\n        for (const [plantId, skipData] of Object.entries(skipInfoData)) {\n          this.annotations.set(plantId, skipData);\n          skipFileCount++;\n          console.log(`[标注] 加载跳过信息: ${plantId} - ${skipData.skipReason}`);\n        }\n        \n        if (skipFileCount > 0) {\n          console.log(`[标注] 成功加载 ${skipFileCount} 个植株的跳过信息`);\n        }\n      } else {\n        // 原有的文件系统模式\n        const annotationsHandle = this.fileSystemManager.getAnnotationsDirectory();\n        if (!annotationsHandle) {\n          return;\n        }\n\n        let skipFileCount = 0;\n        for await (const [name, handle] of annotationsHandle.entries()) {\n          if (handle.kind === 'file' && name.endsWith('_skip_info.json')) {\n            try {\n              const file = await handle.getFile();\n              const content = await file.text();\n              const skipData = JSON.parse(content);\n\n              // 将跳过信息加载到内存\n              this.annotations.set(skipData.plantId, skipData);\n              skipFileCount++;\n\n              console.log(`[标注] 加载跳过信息: ${skipData.plantId} - ${skipData.skipReason}`);\n            } catch (error) {\n              console.warn(`[标注] 加载跳过信息文件失败 (${name}):`, error);\n            }\n          }\n        }\n\n        if (skipFileCount > 0) {\n          console.log(`[标注] 成功加载 ${skipFileCount} 个植株的跳过信息`);\n        }\n      }\n    } catch (error) {\n      console.error('[标注] 扫描跳过信息文件失败:', error);\n    }\n  }\n}","/**\n * 时间序列标注管理器\n * \n * 功能：\n * - 管理植株在不同时间点的标注数据\n * - 支持标注传播（首次标注自动应用到所有时间点）\n * - 支持微调（调整后向后传播到后续时间点）\n * - 处理时间序列的标注继承和覆盖\n */\n\nexport class TimeSeriesAnnotationManager {\n  constructor() {\n    // 存储格式：plantId -> viewAngle -> imageId -> annotations\n    this.timeSeriesAnnotations = new Map();\n    // 存储图像的时间顺序：plantId -> viewAngle -> [imageId...]\n    this.timeSequences = new Map();\n    // 标记哪些是用户手动调整的时间点\n    this.manualAdjustments = new Map();\n  }\n\n  /**\n   * 初始化植株的时间序列\n   */\n  initializePlantTimeSeries(plantId, viewAngle, images) {\n    const plantKey = `${plantId}_${viewAngle}`;\n    \n    // 按时间排序图像\n    const sortedImages = images.sort((a, b) => a.dateTime - b.dateTime);\n    const imageIds = sortedImages.map(img => img.id);\n    \n    // 存储时间序列\n    if (!this.timeSequences.has(plantId)) {\n      this.timeSequences.set(plantId, new Map());\n    }\n    this.timeSequences.get(plantId).set(viewAngle, imageIds);\n    \n    // 初始化标注存储\n    if (!this.timeSeriesAnnotations.has(plantId)) {\n      this.timeSeriesAnnotations.set(plantId, new Map());\n    }\n    if (!this.timeSeriesAnnotations.get(plantId).has(viewAngle)) {\n      this.timeSeriesAnnotations.get(plantId).set(viewAngle, new Map());\n    }\n    \n    console.log(`初始化植株 ${plantId} 视角 ${viewAngle} 的时间序列，共 ${imageIds.length} 个时间点`);\n    \n    return {\n      plantId,\n      viewAngle,\n      imageIds,\n      totalImages: imageIds.length,\n      firstImageId: imageIds[0],\n      lastImageId: imageIds[imageIds.length - 1]\n    };\n  }\n\n  /**\n   * 保存标注并处理传播逻辑\n   */\n  saveAnnotations(plantId, viewAngle, imageId, annotations, isManualAdjustment = false) {\n    const plantAnnotations = this.timeSeriesAnnotations.get(plantId);\n    if (!plantAnnotations) {\n      throw new Error(`植株 ${plantId} 未初始化`);\n    }\n\n    const viewAnnotations = plantAnnotations.get(viewAngle);\n    if (!viewAnnotations) {\n      throw new Error(`植株 ${plantId} 视角 ${viewAngle} 未初始化`);\n    }\n\n    const timeSequence = this.timeSequences.get(plantId)?.get(viewAngle);\n    if (!timeSequence) {\n      throw new Error(`植株 ${plantId} 视角 ${viewAngle} 时间序列未初始化`);\n    }\n\n    const currentImageIndex = timeSequence.indexOf(imageId);\n    if (currentImageIndex === -1) {\n      throw new Error(`图像 ${imageId} 不在时间序列中`);\n    }\n\n    // 保存当前时间点的标注\n    viewAnnotations.set(imageId, {\n      annotations,\n      timestamp: new Date().toISOString(),\n      isManualAdjustment\n    });\n\n    // 记录手动调整\n    if (isManualAdjustment) {\n      const adjustmentKey = `${plantId}_${viewAngle}`;\n      if (!this.manualAdjustments.has(adjustmentKey)) {\n        this.manualAdjustments.set(adjustmentKey, new Set());\n      }\n      this.manualAdjustments.get(adjustmentKey).add(imageId);\n    }\n\n    // 处理传播逻辑\n    this.propagateAnnotations(plantId, viewAngle, imageId, annotations, currentImageIndex);\n\n    console.log(`保存植株 ${plantId} 视角 ${viewAngle} 图像 ${imageId} 的标注，包含 ${annotations.length} 个关键点`);\n    \n    return {\n      savedImageId: imageId,\n      propagatedCount: this.getPropagationCount(plantId, viewAngle, currentImageIndex),\n      isFirstAnnotation: currentImageIndex === 0 && !isManualAdjustment,\n      isManualAdjustment\n    };\n  }\n\n  /**\n   * 标注传播逻辑\n   */\n  propagateAnnotations(plantId, viewAngle, sourceImageId, annotations, sourceImageIndex) {\n    const timeSequence = this.timeSequences.get(plantId).get(viewAngle);\n    const viewAnnotations = this.timeSeriesAnnotations.get(plantId).get(viewAngle);\n    const adjustmentKey = `${plantId}_${viewAngle}`;\n    const manualAdjustments = this.manualAdjustments.get(adjustmentKey) || new Set();\n\n    // 如果这是首次标注（第一张图像），传播到所有未手动调整的时间点\n    if (sourceImageIndex === 0) {\n      for (let i = 1; i < timeSequence.length; i++) {\n        const targetImageId = timeSequence[i];\n        \n        // 如果该时间点没有被手动调整过，应用标注\n        if (!manualAdjustments.has(targetImageId)) {\n          viewAnnotations.set(targetImageId, {\n            annotations: this.deepCloneAnnotations(annotations),\n            timestamp: new Date().toISOString(),\n            isManualAdjustment: false,\n            inheritedFrom: sourceImageId\n          });\n        }\n      }\n      console.log(`从首个图像 ${sourceImageId} 传播标注到后续 ${timeSequence.length - 1} 个时间点`);\n    } \n    // 如果这是中间时间点的调整，向后传播\n    else {\n      let propagatedCount = 0;\n      for (let i = sourceImageIndex + 1; i < timeSequence.length; i++) {\n        const targetImageId = timeSequence[i];\n        \n        // 如果后续时间点没有更新的手动调整，应用当前调整\n        if (!manualAdjustments.has(targetImageId)) {\n          viewAnnotations.set(targetImageId, {\n            annotations: this.deepCloneAnnotations(annotations),\n            timestamp: new Date().toISOString(),\n            isManualAdjustment: false,\n            inheritedFrom: sourceImageId\n          });\n          propagatedCount++;\n        } else {\n          // 遇到手动调整的时间点，停止传播\n          break;\n        }\n      }\n      \n      if (propagatedCount > 0) {\n        console.log(`从时间点 ${sourceImageIndex} 向后传播标注到 ${propagatedCount} 个时间点`);\n      }\n    }\n  }\n\n  /**\n   * 获取指定时间点的标注\n   */\n  getAnnotations(plantId, viewAngle, imageId) {\n    const viewAnnotations = this.timeSeriesAnnotations.get(plantId)?.get(viewAngle);\n    if (!viewAnnotations) {\n      return [];\n    }\n\n    const annotationData = viewAnnotations.get(imageId);\n    return annotationData ? annotationData.annotations : [];\n  }\n\n  /**\n   * 获取标注的元数据\n   */\n  getAnnotationMetadata(plantId, viewAngle, imageId) {\n    const viewAnnotations = this.timeSeriesAnnotations.get(plantId)?.get(viewAngle);\n    if (!viewAnnotations) {\n      return null;\n    }\n\n    const data = viewAnnotations.get(imageId);\n    if (!data) {\n      return null;\n    }\n\n    const timeSequence = this.timeSequences.get(plantId)?.get(viewAngle);\n    const imageIndex = timeSequence ? timeSequence.indexOf(imageId) : -1;\n\n    return {\n      hasAnnotations: data.annotations.length > 0,\n      isManualAdjustment: data.isManualAdjustment,\n      inheritedFrom: data.inheritedFrom,\n      timestamp: data.timestamp,\n      imageIndex,\n      isFirstImage: imageIndex === 0,\n      isLastImage: imageIndex === timeSequence.length - 1\n    };\n  }\n\n  /**\n   * 获取传播统计信息\n   */\n  getPropagationCount(plantId, viewAngle, fromIndex) {\n    const timeSequence = this.timeSequences.get(plantId)?.get(viewAngle);\n    if (!timeSequence) return 0;\n\n    if (fromIndex === 0) {\n      // 首次标注，计算传播到的总数\n      return timeSequence.length - 1;\n    } else {\n      // 中间调整，计算向后传播的数量\n      const adjustmentKey = `${plantId}_${viewAngle}`;\n      const manualAdjustments = this.manualAdjustments.get(adjustmentKey) || new Set();\n      \n      let count = 0;\n      for (let i = fromIndex + 1; i < timeSequence.length; i++) {\n        if (!manualAdjustments.has(timeSequence[i])) {\n          count++;\n        } else {\n          break;\n        }\n      }\n      return count;\n    }\n  }\n\n  /**\n   * 检查是否有标注数据\n   */\n  hasAnnotations(plantId, viewAngle, imageId) {\n    const annotations = this.getAnnotations(plantId, viewAngle, imageId);\n    return annotations.length > 0;\n  }\n\n  /**\n   * 获取植株视角的标注统计\n   */\n  getAnnotationStats(plantId, viewAngle) {\n    const timeSequence = this.timeSequences.get(plantId)?.get(viewAngle);\n    if (!timeSequence) {\n      return { total: 0, annotated: 0, manual: 0, inherited: 0 };\n    }\n\n    const viewAnnotations = this.timeSeriesAnnotations.get(plantId)?.get(viewAngle);\n    if (!viewAnnotations) {\n      return { total: timeSequence.length, annotated: 0, manual: 0, inherited: 0 };\n    }\n\n    let annotated = 0;\n    let manual = 0;\n    let inherited = 0;\n\n    for (const imageId of timeSequence) {\n      const data = viewAnnotations.get(imageId);\n      if (data && data.annotations.length > 0) {\n        annotated++;\n        if (data.isManualAdjustment) {\n          manual++;\n        } else if (data.inheritedFrom) {\n          inherited++;\n        }\n      }\n    }\n\n    return {\n      total: timeSequence.length,\n      annotated,\n      manual,\n      inherited,\n      coverage: ((annotated / timeSequence.length) * 100).toFixed(1)\n    };\n  }\n\n  /**\n   * 深度克隆标注数据\n   */\n  deepCloneAnnotations(annotations) {\n    return annotations.map(annotation => ({\n      ...annotation,\n      x: annotation.x,\n      y: annotation.y\n    }));\n  }\n\n  /**\n   * 清除植株的所有标注\n   */\n  clearPlantAnnotations(plantId, viewAngle) {\n    const plantAnnotations = this.timeSeriesAnnotations.get(plantId);\n    if (plantAnnotations && plantAnnotations.has(viewAngle)) {\n      plantAnnotations.get(viewAngle).clear();\n    }\n\n    const adjustmentKey = `${plantId}_${viewAngle}`;\n    if (this.manualAdjustments.has(adjustmentKey)) {\n      this.manualAdjustments.get(adjustmentKey).clear();\n    }\n\n    console.log(`清除植株 ${plantId} 视角 ${viewAngle} 的所有标注`);\n  }\n\n  /**\n   * 导出时间序列标注数据\n   */\n  exportTimeSeriesData(plantId, viewAngle) {\n    const timeSequence = this.timeSequences.get(plantId)?.get(viewAngle);\n    const viewAnnotations = this.timeSeriesAnnotations.get(plantId)?.get(viewAngle);\n    \n    if (!timeSequence || !viewAnnotations) {\n      return null;\n    }\n\n    const exportData = {\n      plantId,\n      viewAngle,\n      totalImages: timeSequence.length,\n      annotationData: []\n    };\n\n    for (const imageId of timeSequence) {\n      const data = viewAnnotations.get(imageId);\n      if (data) {\n        exportData.annotationData.push({\n          imageId,\n          annotations: data.annotations,\n          metadata: {\n            timestamp: data.timestamp,\n            isManualAdjustment: data.isManualAdjustment,\n            inheritedFrom: data.inheritedFrom\n          }\n        });\n      }\n    }\n\n    return exportData;\n  }\n\n  /**\n   * 导出所有图像的纯净标注数据（不包含内部管理信息）\n   * 返回格式：{ imageId: annotations[] }\n   */\n  exportAllImageAnnotations() {\n    const allImageAnnotations = {};\n    \n    // 遍历所有植株\n    for (const [plantId, plantData] of this.timeSeriesAnnotations) {\n      // 遍历每个植株的所有视角\n      for (const [viewAngle, viewAnnotations] of plantData) {\n        // 遍历该视角的所有图像\n        for (const [imageId, annotationData] of viewAnnotations) {\n          // 包含所有有标注的图像，不管是原始、继承还是微调的\n          if (annotationData.annotations && annotationData.annotations.length > 0) {\n            // 只保存纯净的标注点数据，移除内部管理信息\n            allImageAnnotations[imageId] = annotationData.annotations.map(annotation => ({\n              id: annotation.id,\n              x: annotation.x,\n              y: annotation.y,\n              timestamp: annotation.timestamp\n            }));\n          }\n        }\n      }\n    }\n    \n    return allImageAnnotations;\n  }\n\n  /**\n   * 导出指定植株的所有图像标注数据\n   */\n  exportPlantImageAnnotations(plantId) {\n    const plantImageAnnotations = {};\n    const plantData = this.timeSeriesAnnotations.get(plantId);\n    \n    if (!plantData) {\n      return plantImageAnnotations;\n    }\n    \n    // 遍历该植株的所有视角\n    for (const [viewAngle, viewAnnotations] of plantData) {\n      // 遍历该视角的所有图像\n      for (const [imageId, annotationData] of viewAnnotations) {\n        if (annotationData.annotations && annotationData.annotations.length > 0) {\n          // 只保存纯净的标注点数据\n          plantImageAnnotations[imageId] = annotationData.annotations.map(annotation => ({\n            id: annotation.id,\n            x: annotation.x,\n            y: annotation.y,\n            timestamp: annotation.timestamp\n          }));\n        }\n      }\n    }\n    \n    return plantImageAnnotations;\n  }\n\n  /**\n   * 获取标注数据统计信息\n   */\n  getExportStats() {\n    let totalImages = 0;\n    let annotatedImages = 0;\n    let totalKeypoints = 0;\n    const plantStats = {};\n    \n    for (const [plantId, plantData] of this.timeSeriesAnnotations) {\n      let plantImages = 0;\n      let plantAnnotatedImages = 0;\n      let plantKeypoints = 0;\n      \n      for (const [viewAngle, viewAnnotations] of plantData) {\n        for (const [imageId, annotationData] of viewAnnotations) {\n          plantImages++;\n          totalImages++;\n          \n          if (annotationData.annotations && annotationData.annotations.length > 0) {\n            plantAnnotatedImages++;\n            annotatedImages++;\n            plantKeypoints += annotationData.annotations.length;\n            totalKeypoints += annotationData.annotations.length;\n          }\n        }\n      }\n      \n      plantStats[plantId] = {\n        totalImages: plantImages,\n        annotatedImages: plantAnnotatedImages,\n        totalKeypoints: plantKeypoints,\n        completionRate: plantImages > 0 ? ((plantAnnotatedImages / plantImages) * 100).toFixed(1) : 0\n      };\n    }\n    \n    return {\n      totalImages,\n      annotatedImages,\n      totalKeypoints,\n      completionRate: totalImages > 0 ? ((annotatedImages / totalImages) * 100).toFixed(1) : 0,\n      plantStats\n    };\n  }\n\n  /**\n   * 调试：获取时间序列管理器的当前状态\n   */\n  getDebugStatus() {\n    const status = {\n      plantsCount: this.timeSeriesAnnotations.size,\n      totalSequences: 0,\n      totalAnnotatedImages: 0,\n      plantDetails: {}\n    };\n    \n    for (const [plantId, plantData] of this.timeSeriesAnnotations) {\n      const plantDetail = {\n        viewAnglesCount: plantData.size,\n        viewAngles: {}\n      };\n      \n      for (const [viewAngle, viewAnnotations] of plantData) {\n        status.totalSequences++;\n        const annotatedImages = Array.from(viewAnnotations.values()).filter(\n          data => data.annotations && data.annotations.length > 0\n        ).length;\n        \n        status.totalAnnotatedImages += annotatedImages;\n        \n        plantDetail.viewAngles[viewAngle] = {\n          totalImages: viewAnnotations.size,\n          annotatedImages,\n          imageIds: Array.from(viewAnnotations.keys())\n        };\n      }\n      \n      status.plantDetails[plantId] = plantDetail;\n    }\n    \n    console.log('时间序列管理器状态:', status);\n    return status;\n  }\n\n  /**\n   * 调试：强制导出所有时间序列数据（详细版本）\n   */\n  exportAllTimeSeriesDataDebug() {\n    const debugData = {\n      managedPlants: this.timeSeriesAnnotations.size,\n      allData: {}\n    };\n    \n    for (const [plantId, plantData] of this.timeSeriesAnnotations) {\n      debugData.allData[plantId] = {};\n      \n      for (const [viewAngle, viewAnnotations] of plantData) {\n        debugData.allData[plantId][viewAngle] = {};\n        \n        for (const [imageId, annotationData] of viewAnnotations) {\n          debugData.allData[plantId][viewAngle][imageId] = {\n            hasAnnotations: !!(annotationData.annotations && annotationData.annotations.length > 0),\n            annotationCount: annotationData.annotations?.length || 0,\n            annotations: annotationData.annotations || [],\n            metadata: {\n              timestamp: annotationData.timestamp,\n              isManualAdjustment: annotationData.isManualAdjustment,\n              inheritedFrom: annotationData.inheritedFrom\n            }\n          };\n        }\n      }\n    }\n    \n    console.log('时间序列详细数据:', debugData);\n    return debugData;\n  }\n} ","/**\n * 植物数据管理器\n * \n * 功能：\n * - 植物数据的加载和解析\n * - 图像时间排序和管理\n * - 标注状态跟踪\n * - 数据缓存和性能优化\n */\n\nimport { HttpFileSystemManager } from './HttpFileSystemManager.js';\nimport { AnnotationStorageManager } from './AnnotationStorageManager.js';\nimport { TimeSeriesAnnotationManager } from './TimeSeriesAnnotationManager.js';\n\nexport class PlantDataManager {\n  constructor() {\n    this.fileSystemManager = new HttpFileSystemManager();\n    this.annotationStorage = new AnnotationStorageManager();\n    this.timeSeriesManager = new TimeSeriesAnnotationManager();\n    this.plants = new Map();\n    this.plantImages = new Map();\n    this.annotationStatus = new Map();\n    this.loadingPlants = new Set();\n  }\n\n  /**\n   * 初始化数据管理器\n   */\n  async initialize() {\n    try {\n      // 初始化HTTP文件系统管理器\n      await this.fileSystemManager.initialize();\n      \n      await this.annotationStorage.initialize();\n      \n      // 恢复时间序列数据到管理器\n      this.annotationStorage.restoreTimeSeriesData(this.timeSeriesManager);\n      \n      // 设置时间序列管理器的引用到存储管理器\n      this.annotationStorage.setTimeSeriesManager(this.timeSeriesManager);\n      \n      console.log('PlantDataManager 初始化完成');\n    } catch (error) {\n      console.error('PlantDataManager 初始化失败:', error);\n    }\n  }\n\n  /**\n   * 加载数据集中的所有植物\n   */\n  async loadDataset() {\n    console.log('开始加载数据集...');\n\n    try {\n      // 注意：不要在这里cleanup，因为会清除annotations目录句柄\n      // 只清理植物相关数据\n      this.plants.clear();\n      this.plantImages.clear();\n      this.annotationStatus.clear();\n      this.loadingPlants.clear();\n\n      // 设置文件系统管理器到标注存储\n      this.annotationStorage.setFileSystemManager(this.fileSystemManager);\n\n      // 重新初始化标注存储以使用文件系统\n      this.annotationStorage.isInitialized = false;\n      await this.annotationStorage.initialize();\n\n      // 初始化时间序列相关功能\n      this.annotationStorage.restoreTimeSeriesData(this.timeSeriesManager);\n      this.annotationStorage.setTimeSeriesManager(this.timeSeriesManager);\n      \n      // 遍历植物文件夹（不再需要传入datasetHandle）\n      const plantFolders = await this.fileSystemManager.traversePlantDirectories();\n      \n      if (plantFolders.length === 0) {\n        throw new Error('数据集中未找到有效的植物文件夹');\n      }\n      \n      // 批量加载植物基本信息\n      const plants = [];\n      for (const plantFolder of plantFolders) {\n        const plant = await this.createPlantData(plantFolder);\n        plants.push(plant);\n        this.plants.set(plant.id, plant);\n      }\n      \n      // 从持久化存储恢复标注状态\n      await this.restoreAnnotationStatus(plants);\n      \n      // 按植物ID排序\n      plants.sort((a, b) => a.id.localeCompare(b.id));\n      \n      console.log(`成功加载 ${plants.length} 个植物`);\n      return plants;\n      \n    } catch (error) {\n      console.error('加载数据集失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 恢复植物的标注状态\n   */\n  async restoreAnnotationStatus(plants) {\n    if (this.annotationStorage.useFileSystem) {\n      // 文件系统模式：检查每个植物的标注文件\n      await this.restoreAnnotationStatusFromFileSystem(plants);\n    } else {\n      // 服务器模式：使用原有逻辑\n      const annotatedPlantIds = this.annotationStorage.getAnnotatedPlantIds();\n\n      for (const plant of plants) {\n        if (annotatedPlantIds.includes(plant.id)) {\n          const status = this.annotationStorage.getPlantStatus(plant.id);\n          const annotations = this.annotationStorage.getPlantAnnotations(plant.id);\n          const summary = this.annotationStorage.getPlantAnnotationSummary(plant.id);\n\n          plant.status = status;\n          plant.annotations = annotations;\n\n          // 恢复跳过信息\n          const annotationData = this.annotationStorage.annotations.get(plant.id);\n          if (annotationData && annotationData.status === 'skipped') {\n            plant.skipReason = annotationData.skipReason;\n            plant.skipDate = annotationData.skipDate;\n          }\n\n          // 恢复视角选择信息\n          if (summary) {\n            plant.selectedViewAngle = summary.selectedViewAngle;\n            plant.viewAngles = summary.availableViewAngles;\n\n            const skipInfo = plant.status === 'skipped' ? ` (跳过: ${plant.skipReason})` : '';\n            console.log(`恢复植株 ${plant.id} 的标注状态: ${status}, 视角: ${summary.selectedViewAngle}, ${annotations.length} 个标注点${skipInfo}`);\n          }\n\n          // 缓存到内存\n          this.annotationStatus.set(plant.id, annotations);\n        }\n      }\n    }\n  }\n\n  /**\n   * 从文件系统恢复植物标注状态（批量优化版）\n   */\n  async restoreAnnotationStatusFromFileSystem(plants) {\n    console.log('[标注] 开始从文件系统恢复植物状态...');\n\n    // 🚀 PERFORMANCE OPTIMIZATION: Try bulk loading first\n    let bulkAnnotationData = null;\n    try {\n      // Try to get bulk annotation data if AnnotationManager is available\n      if (window.PlantAnnotationTool?.annotationManager) {\n        console.log('[标注] 尝试使用批量标注数据进行快速状态恢复...');\n        bulkAnnotationData = await window.PlantAnnotationTool.annotationManager.getAllAnnotationsInBulk();\n        \n        if (bulkAnnotationData) {\n          console.log('[标注] 批量标注数据获取成功，使用高性能模式');\n          await this.restoreStatusFromBulkData(plants, bulkAnnotationData);\n          return; // Skip individual file reads completely\n        }\n      }\n    } catch (error) {\n      console.warn('[标注] 批量加载失败，回退到单独文件读取模式:', error);\n    }\n\n    // 🔄 FALLBACK: Individual file reading (legacy mode)\n    console.log('[标注] 使用传统单独文件读取模式');\n    await this.restoreStatusFromIndividualFiles(plants);\n  }\n\n  /**\n   * 从批量数据恢复植物状态（高性能模式）\n   */\n  async restoreStatusFromBulkData(plants, bulkData) {\n    console.log('[标注] 使用批量数据进行快速状态恢复...');\n    const startTime = performance.now();\n    \n    // Create lookup maps for fast access\n    const imageAnnotationsMap = bulkData.imageAnnotations || {};\n    const plantAnnotationsMap = bulkData.plantAnnotations || {};\n    \n    for (const plant of plants) {\n      try {\n        let hasAnnotations = false;\n        let totalAnnotations = 0;\n        let selectedViewAngle = null;\n        const viewAngleStats = {};\n\n        // 获取植物的所有图像（如果还没有加载）\n        if (!this.plantImages.has(plant.id)) {\n          const imagesByView = await this.fileSystemManager.readPlantImages(plant.id);\n          this.plantImages.set(plant.id, imagesByView);\n        }\n\n        const imagesByView = this.plantImages.get(plant.id);\n\n        // 检查每个视角的标注情况 - 使用内存查找而非文件读取\n        for (const [viewAngle, images] of Object.entries(imagesByView)) {\n          let viewAnnotationCount = 0;\n\n          for (const image of images) {\n            // 🚀 FAST LOOKUP: Use in-memory data instead of file reads\n            const imageAnnotations = imageAnnotationsMap[image.id];\n            if (imageAnnotations && imageAnnotations.length > 0) {\n              hasAnnotations = true;\n              const count = imageAnnotations.length;\n              totalAnnotations += count;\n              viewAnnotationCount += count;\n\n              // 记录最常用的视角作为选中视角\n              if (!selectedViewAngle || viewAnnotationCount > (viewAngleStats[selectedViewAngle] || 0)) {\n                selectedViewAngle = viewAngle;\n              }\n            }\n          }\n\n          if (viewAnnotationCount > 0) {\n            viewAngleStats[viewAngle] = viewAnnotationCount;\n          }\n        }\n\n        // 检查植物级标注\n        const plantAnnotations = plantAnnotationsMap[plant.id];\n        if (plantAnnotations && plantAnnotations.length > 0) {\n          hasAnnotations = true;\n          totalAnnotations += plantAnnotations.length;\n        }\n\n        // 检查是否有跳过信息\n        const skipData = this.annotationStorage.annotations.get(plant.id);\n        if (skipData && skipData.status === 'skipped') {\n          // 恢复跳过状态\n          plant.status = 'skipped';\n          plant.skipReason = skipData.skipReason;\n          plant.skipDate = skipData.skipDate;\n        } else {\n          // 🔧 FIX: Check for persisted completion status from dedicated API in bulk mode too\n          console.log(`[批量恢复] 检查植物 ${plant.id} 的专用状态API...`);\n          const persistedStatus = await this.annotationStorage.loadPlantStatus(plant.id);\n          console.log(`[批量恢复] 植物 ${plant.id} 专用API状态: ${persistedStatus}`);\n          \n          if (persistedStatus === 'completed') {\n            // 保持已完成状态，即使没有标注数据  \n            plant.status = 'completed';\n            plant.selectedViewAngle = selectedViewAngle;\n            console.log(`[批量恢复] 植物 ${plant.id}: completed (从专用API恢复)`);\n          } else if (hasAnnotations) {\n            // 🔧 FIX: Plants with annotations are 'in-progress', not auto-completed\n            plant.status = 'in-progress';\n            plant.selectedViewAngle = selectedViewAngle;\n            console.log(`[批量恢复] 植物 ${plant.id}: in-progress (有标注数据)`);\n          } else {\n            // 无标注数据且无持久化状态\n            plant.status = 'pending';\n            console.log(`[批量恢复] 植物 ${plant.id}: pending (无数据)`);\n          }\n        }\n\n      } catch (error) {\n        console.warn(`[标注] 检查植物 ${plant.id} 状态失败:`, error);\n        plant.status = 'pending';\n      }\n    }\n\n    const endTime = performance.now();\n    console.log(`[标注] 批量状态恢复完成，耗时: ${(endTime - startTime).toFixed(2)}ms`);\n  }\n\n  /**\n   * 从单独文件恢复植物状态（传统模式）\n   */\n  async restoreStatusFromIndividualFiles(plants) {\n    console.log('[标注] 使用传统文件读取模式恢复状态...');\n\n    // 获取所有标注文件列表（一次性获取）\n    const allAnnotationFiles = await this.annotationStorage.fileSystemManager.getAllAnnotationFiles();\n    const annotationFileSet = new Set(allAnnotationFiles);\n\n    for (const plant of plants) {\n      try {\n        let hasAnnotations = false;\n        let totalAnnotations = 0;\n        let selectedViewAngle = null;\n        const viewAngleStats = {};\n\n        // 获取植物的所有图像（如果还没有加载）\n        if (!this.plantImages.has(plant.id)) {\n          const imagesByView = await this.fileSystemManager.readPlantImages(plant.id);\n          this.plantImages.set(plant.id, imagesByView);\n        }\n\n        const imagesByView = this.plantImages.get(plant.id);\n\n        // 检查每个视角的标注情况\n        for (const [viewAngle, images] of Object.entries(imagesByView)) {\n          let viewAnnotationCount = 0;\n\n          for (const image of images) {\n            // 快速检查：如果标注文件存在于列表中，才尝试读取\n            if (annotationFileSet.has(image.id)) {\n              const annotationData = await this.annotationStorage.getImageAnnotation(image.id);\n              if (annotationData && annotationData.annotations && annotationData.annotations.length > 0) {\n                hasAnnotations = true;\n                const count = annotationData.annotations.length;\n                totalAnnotations += count;\n                viewAnnotationCount += count;\n\n                // 记录最常用的视角作为选中视角\n                if (!selectedViewAngle || viewAnnotationCount > (viewAngleStats[selectedViewAngle] || 0)) {\n                  selectedViewAngle = viewAngle;\n                }\n              }\n            }\n          }\n\n          if (viewAnnotationCount > 0) {\n            viewAngleStats[viewAngle] = viewAnnotationCount;\n          }\n        }\n\n        // 检查是否有跳过信息\n        const skipData = this.annotationStorage.annotations.get(plant.id);\n        if (skipData && skipData.status === 'skipped') {\n          // 恢复跳过状态\n          plant.status = 'skipped';\n          plant.skipReason = skipData.skipReason;\n          plant.skipDate = skipData.skipDate;\n          console.log(`[标注] 植物 ${plant.id}: skipped (${skipData.skipReason})`);\n        } else {\n          // 🔧 FIX: Check for persisted completion status before applying default logic\n          console.log(`[状态恢复] 开始检查植物 ${plant.id} 的持久化状态...`);\n          const persistedStatus = await this.annotationStorage.loadPlantStatus(plant.id);\n          console.log(`[状态恢复] 植物 ${plant.id} 持久化状态结果: ${persistedStatus}`);\n          \n          if (persistedStatus === 'completed') {\n            // 保持已完成状态，即使没有标注数据\n            plant.status = 'completed';\n            plant.selectedViewAngle = selectedViewAngle;\n            console.log(`[标注] 植物 ${plant.id}: completed (从持久化存储恢复)`);\n          } else if (hasAnnotations) {\n            // 🔧 FIX: Plants with annotations are 'in-progress', not auto-completed\n            plant.status = 'in-progress';\n            plant.selectedViewAngle = selectedViewAngle;\n            console.log(`[标注] 植物 ${plant.id}: in-progress, 选中视角: ${selectedViewAngle} (${totalAnnotations} 个标注点)`);\n          } else {\n            // 无标注数据且无持久化状态\n            plant.status = 'pending';\n            console.log(`[标注] 植物 ${plant.id}: pending (无标注数据且无持久化状态)`);\n          }\n        }\n\n      } catch (error) {\n        console.warn(`[标注] 检查植物 ${plant.id} 状态失败:`, error);\n        plant.status = 'pending';\n      }\n    }\n\n    console.log('[标注] 植物状态恢复完成');\n  }\n\n  /**\n   * 创建植物数据对象\n   */\n  async createPlantData(plantFolder) {\n    const plant = {\n      id: plantFolder.id,\n      name: plantFolder.name,\n      path: plantFolder.path, // HTTP版本使用path而不是handle\n      status: 'pending', // pending, in-progress, completed\n      imageCount: 0,\n      hasImages: false,\n      viewAngles: [], // 可用的视角列表\n      selectedViewAngle: null, // 用户选择的视角\n      selectedImage: null,\n      annotations: [],\n      lastModified: null,\n      loadedAt: new Date().toISOString()\n    };\n    \n    // 异步加载图像数量（不阻塞主流程）\n    this.loadPlantImageCount(plant);\n    \n    return plant;\n  }\n\n  /**\n   * 异步加载植物的图像数量\n   */\n  async loadPlantImageCount(plant) {\n    if (this.loadingPlants.has(plant.id)) {\n      return;\n    }\n    \n    this.loadingPlants.add(plant.id);\n    \n    try {\n      const imagesByView = await this.fileSystemManager.readPlantImages(plant.id);\n      \n      // 统计各视角的图像数量\n      const viewAngles = Object.keys(imagesByView).filter(view => imagesByView[view].length > 0);\n      const totalImages = Object.values(imagesByView).reduce((total, images) => total + images.length, 0);\n      \n      // 更新植物信息\n      plant.viewAngles = viewAngles;\n      plant.imageCount = totalImages;\n      plant.hasImages = totalImages > 0;\n      \n      // 缓存图像数据\n      if (totalImages > 0) {\n        this.plantImages.set(plant.id, imagesByView);\n      }\n      \n      console.log(`植物 ${plant.id} 包含 ${totalImages} 张图像，视角: ${viewAngles.join(', ')}`);\n      \n      // 触发UI更新事件\n      this.emitPlantUpdated(plant);\n      \n    } catch (error) {\n      console.error(`加载植物 ${plant.id} 图像信息失败:`, error);\n      plant.hasImages = false;\n      plant.imageCount = 0;\n      plant.viewAngles = [];\n    } finally {\n      this.loadingPlants.delete(plant.id);\n    }\n  }\n\n  /**\n   * 获取植物列表\n   */\n  getPlantList() {\n    return Array.from(this.plants.values()).sort((a, b) => a.id.localeCompare(b.id));\n  }\n\n  /**\n   * 根据ID获取植物\n   */\n  getPlant(plantId) {\n    return this.plants.get(plantId);\n  }\n\n  /**\n   * 获取植物的图像列表（指定视角）\n   */\n  async getPlantImages(plantId, viewAngle = null) {\n    // 检查缓存\n    if (this.plantImages.has(plantId)) {\n      const imagesByView = this.plantImages.get(plantId);\n      \n      if (viewAngle) {\n        return imagesByView[viewAngle] || [];\n      } else {\n        // 如果没有指定视角，返回所有视角的数据\n        return imagesByView;\n      }\n    }\n    \n    // 如果正在加载，等待完成\n    if (this.loadingPlants.has(plantId)) {\n      return new Promise((resolve) => {\n        const checkLoading = () => {\n          if (!this.loadingPlants.has(plantId)) {\n            const imagesByView = this.plantImages.get(plantId) || {};\n            resolve(viewAngle ? (imagesByView[viewAngle] || []) : imagesByView);\n          } else {\n            setTimeout(checkLoading, 100);\n          }\n        };\n        checkLoading();\n      });\n    }\n    \n    // 立即加载\n    const plant = this.plants.get(plantId);\n    if (!plant) {\n      throw new Error(`植物 ${plantId} 不存在`);\n    }\n    \n    try {\n      const imagesByView = await this.fileSystemManager.readPlantImages(plant.id);\n      this.plantImages.set(plantId, imagesByView);\n      \n      if (viewAngle) {\n        return imagesByView[viewAngle] || [];\n      } else {\n        return imagesByView;\n      }\n    } catch (error) {\n      console.error(`获取植物 ${plantId} 图像失败:`, error);\n      return viewAngle ? [] : {};\n    }\n  }\n\n  /**\n   * 🔧 FIXED: 更新植物状态 - 始终保存状态到持久化存储\n   */\n  updatePlantStatus(plantId, status) {\n    const plant = this.plants.get(plantId);\n    if (plant) {\n      plant.status = status;\n      plant.lastModified = new Date().toISOString();\n\n      // 🔧 FIX: Always save plant status to persistent storage, regardless of annotations\n      if (this.annotationStorage) {\n        // Use the new savePlantStatus method for independent status persistence\n        this.annotationStorage.savePlantStatus(plantId, status)\n          .then(() => {\n            console.log(`[状态更新] ${plantId}: ${status} - 已保存到持久化存储`);\n          })\n          .catch(error => {\n            console.error('保存植物状态失败:', error);\n            // 备用方案：如果有标注数据，尝试传统的保存方法\n            const annotations = this.getPlantAnnotations(plantId);\n            if (annotations.length > 0) {\n              const plantInfo = {\n                selectedImage: plant.selectedImage,\n                selectedViewAngle: plant.selectedViewAngle\n              };\n              return this.annotationStorage.savePlantAnnotations(plantId, annotations, plantInfo);\n            }\n          });\n      }\n\n      this.emitPlantUpdated(plant);\n    }\n  }\n\n  /**\n   * 跳过植株\n   */\n  async skipPlant(plantId, reason) {\n    const plant = this.plants.get(plantId);\n    if (!plant) {\n      throw new Error(`植株 ${plantId} 不存在`);\n    }\n\n    // 更新植株状态\n    plant.status = 'skipped';\n    plant.skipReason = reason;\n    plant.skipDate = new Date().toISOString();\n    plant.lastModified = new Date().toISOString();\n\n    // 保存跳过信息到持久化存储\n    try {\n      const skipInfo = {\n        status: 'skipped',\n        skipReason: reason,\n        skipDate: plant.skipDate,\n        lastModified: plant.lastModified\n      };\n\n      await this.annotationStorage.saveSkipInfo(plantId, skipInfo);\n      console.log(`植株 ${plantId} 已标记为跳过: ${reason}`);\n\n      this.emitPlantUpdated(plant);\n\n    } catch (error) {\n      console.error(`保存植株 ${plantId} 跳过信息失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 NEW: 撤销跳过植株\n   */\n  async unskipPlant(plantId) {\n    const plant = this.plants.get(plantId);\n    if (!plant) {\n      throw new Error(`植株 ${plantId} 不存在`);\n    }\n\n    if (plant.status !== 'skipped') {\n      throw new Error(`植株 ${plantId} 当前状态不是跳过状态`);\n    }\n\n    try {\n      // 确定新状态：如果有标注数据则为 in-progress，否则为 pending\n      const annotations = await this.getPlantAnnotations(plantId);\n      const newStatus = (annotations && annotations.length > 0) ? 'in-progress' : 'pending';\n\n      // 更新植株状态\n      plant.status = newStatus;\n      plant.lastModified = new Date().toISOString();\n      \n      // 清除跳过相关信息\n      delete plant.skipReason;\n      delete plant.skipDate;\n\n      // 移除持久化存储中的跳过信息\n      await this.annotationStorage.removeSkipInfo(plantId);\n      \n      // 更新植株状态到持久化存储\n      await this.annotationStorage.savePlantStatus(plantId, newStatus);\n\n      console.log(`植株 ${plantId} 已撤销跳过状态，新状态: ${newStatus}`);\n      this.emitPlantUpdated(plant);\n\n    } catch (error) {\n      console.error(`撤销植株 ${plantId} 跳过状态失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 NEW: 撤销完成植株\n   */\n  async uncompletePlant(plantId) {\n    const plant = this.plants.get(plantId);\n    if (!plant) {\n      throw new Error(`植株 ${plantId} 不存在`);\n    }\n\n    if (plant.status !== 'completed') {\n      throw new Error(`植株 ${plantId} 当前状态不是已完成状态`);\n    }\n\n    try {\n      // 确定新状态：如果有标注数据则为 in-progress，否则为 pending\n      const annotations = await this.getPlantAnnotations(plantId);\n      const newStatus = (annotations && annotations.length > 0) ? 'in-progress' : 'pending';\n\n      // 更新植株状态\n      plant.status = newStatus;\n      plant.lastModified = new Date().toISOString();\n\n      // 更新植株状态到持久化存储\n      await this.annotationStorage.savePlantStatus(plantId, newStatus);\n\n      console.log(`植株 ${plantId} 已撤销完成状态，新状态: ${newStatus}`);\n      this.emitPlantUpdated(plant);\n\n    } catch (error) {\n      console.error(`撤销植株 ${plantId} 完成状态失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 设置植物的选中视角\n   */\n  setSelectedViewAngle(plantId, viewAngle) {\n    const plant = this.plants.get(plantId);\n    if (plant) {\n      plant.selectedViewAngle = viewAngle;\n      plant.selectedImage = null; // 重置选中的图像\n      \n      // 如果植物状态还是pending，更新为in-progress\n      if (plant.status === 'pending') {\n        this.updatePlantStatus(plantId, 'in-progress');\n      }\n      \n      this.emitPlantUpdated(plant);\n    }\n  }\n\n  /**\n   * 设置植物的选中图像\n   */\n  setSelectedImage(plantId, imageData) {\n    const plant = this.plants.get(plantId);\n    if (plant) {\n      plant.selectedImage = imageData;\n      \n      // 自动设置视角（如果还没有设置的话）\n      if (!plant.selectedViewAngle && imageData.viewAngle) {\n        plant.selectedViewAngle = imageData.viewAngle;\n      }\n\n      // 初始化时间序列（如果还没有初始化）\n      if (plant.selectedViewAngle) {\n        this.initializeTimeSeriesIfNeeded(plantId, plant.selectedViewAngle);\n      }\n      \n      // 如果植物状态还是pending，更新为in-progress\n      if (plant.status === 'pending') {\n        this.updatePlantStatus(plantId, 'in-progress');\n      }\n      \n      this.emitPlantUpdated(plant);\n    }\n  }\n\n  /**\n   * 初始化时间序列（如果需要）\n   */\n  async initializeTimeSeriesIfNeeded(plantId, viewAngle) {\n    try {\n      const images = await this.getPlantImages(plantId, viewAngle);\n      if (images.length > 0) {\n        const seriesInfo = this.timeSeriesManager.initializePlantTimeSeries(plantId, viewAngle, images);\n        console.log(`初始化时间序列: ${seriesInfo.totalImages} 张图像`);\n        return seriesInfo;\n      }\n    } catch (error) {\n      console.error('初始化时间序列失败:', error);\n    }\n    return null;\n  }\n\n  /**\n   * 获取植物的标注数据（新的简化方案）\n   */\n  async savePlantAnnotations(plantId, annotations, isManualAdjustment = false, options = {}) {\n    const plant = this.plants.get(plantId);\n    if (!plant) {\n      throw new Error(`植株 ${plantId} 不存在`);\n    }\n\n    if (!plant.selectedImage || !plant.selectedViewAngle) {\n      throw new Error('请先选择图像和视角');\n    }\n\n    const currentImageId = plant.selectedImage.id;\n    const viewAngle = plant.selectedViewAngle;\n\n    try {\n      // 获取该视角的所有图像\n      const images = await this.getPlantImages(plantId, viewAngle);\n      const currentImageIndex = images.findIndex(img => img.id === currentImageId);\n      \n      if (currentImageIndex === -1) {\n        throw new Error('当前图像不在图像列表中');\n      }\n\n      let savedCount = 0;\n      \n      if (isManualAdjustment) {\n        // 仅保存当前图像\n        await this.saveAnnotationToFile(plantId, currentImageId, annotations, options);\n        savedCount = 1;\n        console.log(`保存标注到当前图像: ${currentImageId}`);\n      } else {\n        // 向后传播：保存到当前图像及后续所有图像\n        for (let i = currentImageIndex; i < images.length; i++) {\n          const imageId = images[i].id;\n          await this.saveAnnotationToFile(plantId, imageId, annotations, options);\n          savedCount++;\n        }\n        console.log(`向后传播保存标注到 ${savedCount} 张图像`);\n      }\n\n      // 🔧 FIX: Update plant status - only set to in-progress when saving annotations\n      // Completion status should only be set explicitly via Complete Plant button\n      plant.annotations = annotations;\n      plant.lastModified = new Date().toISOString();\n      plant.status = annotations.length > 0 ? 'in-progress' : 'pending';\n\n      // 更新内存缓存\n      this.annotationStatus.set(plantId, annotations);\n\n      // 触发UI更新\n      this.emitPlantUpdated(plant);\n\n      const directionInfo = options.saveDirectionsOnly ? ' (仅方向信息)' : '';\n      const message = isManualAdjustment ? \n        `已保存到当前图像${directionInfo}` : \n        `已传播保存到 ${savedCount} 张图像${directionInfo}`;\n\n      return {\n        success: true,\n        savedCount,\n        message,\n        viewAngle: viewAngle,\n        isManualAdjustment,\n        saveDirectionsOnly: options.saveDirectionsOnly\n      };\n      \n    } catch (error) {\n      console.error(`保存植株 ${plantId} 标注数据失败:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * 保存标注数据到特定图像文件\n   */\n  async saveAnnotationToFile(plantId, imageId, annotations, options = {}) {\n    let finalAnnotations = annotations;\n    \n    // 如果只保存方向信息，需要合并现有的位置信息\n    if (options.saveDirectionsOnly) {\n      const existingData = await this.annotationStorage.getImageAnnotation(imageId);\n      if (existingData && existingData.annotations) {\n        finalAnnotations = this.mergeDirectionData(existingData.annotations, annotations);\n      }\n    }\n    \n    // 为每个图像创建独立的标注文件\n    const annotationData = {\n      plantId,\n      imageId,\n      annotations: finalAnnotations,\n      timestamp: new Date().toISOString(),\n      version: '2.0' // 新版本标记\n    };\n\n    // 保存到持久化存储\n    await this.annotationStorage.saveImageAnnotation(imageId, annotationData);\n  }\n\n  /**\n   * 合并方向数据（仅更新方向信息，保持位置不变）\n   */\n  mergeDirectionData(existingAnnotations, newAnnotations) {\n    const merged = [...existingAnnotations];\n    \n    // 为每个新标注点的方向信息更新对应的现有标注点\n    newAnnotations.forEach(newAnnotation => {\n      const existingIndex = merged.findIndex(existing => existing.order === newAnnotation.order);\n      \n      if (existingIndex !== -1) {\n        // 只更新方向相关信息，保持位置不变\n        merged[existingIndex] = {\n          ...merged[existingIndex],\n          direction: newAnnotation.direction,\n          directionType: newAnnotation.directionType,\n          timestamp: new Date().toISOString()\n        };\n      } else {\n        // 如果没有找到对应的标注点，添加新的\n        merged.push(newAnnotation);\n      }\n    });\n    \n    return merged;\n  }\n\n  /**\n   * 保存标注数据到指定图像（自动保存专用）\n   */\n  async saveImageAnnotations(imageId, annotations) {\n    try {\n      // 获取当前植株ID\n      const currentPlantId = window.appState?.currentPlant?.id || this.getCurrentPlantIdFromImage(imageId);\n\n      // 创建标注数据结构\n      const annotationData = {\n        imageId,\n        plantId: currentPlantId,\n        annotations,\n        timestamp: new Date().toISOString(),\n        version: '2.0'\n      };\n\n      // 保存到持久化存储\n      await this.annotationStorage.saveImageAnnotation(imageId, annotationData);\n\n      console.log(`自动保存完成：图像 ${imageId} (植株: ${currentPlantId}) 的 ${annotations.length} 个标注点`);\n\n    } catch (error) {\n      console.error('自动保存图像标注失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 从图像ID推断植株ID\n   */\n  getCurrentPlantIdFromImage(imageId) {\n    // 尝试从图像ID中提取植株ID\n    // 图像ID格式通常是: BR017-028122_sv-000_BR017-028122-2018-07-04_00_VIS_sv_000-0-0-0.png\n    // 植株ID通常是: BR017-028122\n\n    if (imageId.includes('_')) {\n      const parts = imageId.split('_');\n      if (parts.length > 0) {\n        // 取第一部分作为植株ID\n        return parts[0];\n      }\n    }\n\n    // 如果无法解析，尝试从文件名中提取\n    if (imageId.includes('-')) {\n      const parts = imageId.split('-');\n      if (parts.length >= 2) {\n        // 组合前两部分作为植株ID (如 BR017-028122)\n        return `${parts[0]}-${parts[1]}`;\n      }\n    }\n\n    // 最后的备选方案：返回原始imageId的前缀\n    return imageId.split('.')[0].split('_')[0];\n  }\n\n  /**\n   * 获取特定图像的标注数据\n   */\n  async getImageAnnotations(imageId) {\n    try {\n      const annotationData = await this.annotationStorage.getImageAnnotation(imageId);\n\n      if (!annotationData || !annotationData.annotations) {\n        return [];\n      }\n\n      const annotations = annotationData.annotations;\n\n      // 🔧 DISABLED: 为传统数据添加序号（兼容性处理）\n      // IMPORTANT: This automatic renumbering was causing order inconsistencies\n      // across frames in real-time sync. Annotations should maintain their\n      // original order numbers to ensure consistent synchronization.\n      // this.ensureAnnotationOrders(annotations);\n      \n      console.log(`🔄 Loaded ${annotations.length} annotations for image ${imageId} (auto-renumbering disabled)`);\n\n      return annotations;\n    } catch (error) {\n      console.error('获取图像标注失败:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 获取植物的标注数据（简化版本）\n   */\n  getPlantAnnotations(plantId, imageId = null) {\n    if (imageId) {\n      // 直接从文件读取指定图像的标注\n      return this.getImageAnnotations(imageId);\n    }\n\n    // 如果没有指定图像，返回植物的当前标注状态\n    return this.annotationStatus.get(plantId) || [];\n  }\n\n  /**\n   * 获取当前图像的标注元数据\n   */\n  getCurrentImageAnnotationMetadata(plantId) {\n    const plant = this.plants.get(plantId);\n    if (!plant || !plant.selectedImage || !plant.selectedViewAngle) {\n      return null;\n    }\n\n    return this.timeSeriesManager.getAnnotationMetadata(\n      plantId,\n      plant.selectedViewAngle,\n      plant.selectedImage.id\n    );\n  }\n\n  /**\n   * 获取植株视角的时间序列统计\n   */\n  getPlantTimeSeriesStats(plantId, viewAngle) {\n    return this.timeSeriesManager.getAnnotationStats(plantId, viewAngle);\n  }\n\n  /**\n   * 检查是否为手动调整模式\n   */\n  shouldShowManualAdjustmentMode(plantId) {\n    const metadata = this.getCurrentImageAnnotationMetadata(plantId);\n    if (!metadata) return false;\n\n    // 如果不是第一张图像，且已有标注，显示微调模式\n    return !metadata.isFirstImage && metadata.hasAnnotations;\n  }\n\n  /**\n   * 获取下一个未完成的植物\n   */\n  getNextPendingPlant(currentPlantId = null) {\n    const plants = this.getPlantList();\n    \n    if (!currentPlantId) {\n      // 返回第一个未完成的植物\n      return plants.find(plant => plant.status !== 'completed');\n    }\n    \n    // 找到当前植物的索引\n    const currentIndex = plants.findIndex(plant => plant.id === currentPlantId);\n    \n    if (currentIndex === -1) {\n      return plants.find(plant => plant.status !== 'completed');\n    }\n    \n    // 从当前植物的下一个开始查找\n    for (let i = currentIndex + 1; i < plants.length; i++) {\n      if (plants[i].status !== 'completed') {\n        return plants[i];\n      }\n    }\n    \n    // 如果没找到，从头开始查找\n    for (let i = 0; i < currentIndex; i++) {\n      if (plants[i].status !== 'completed') {\n        return plants[i];\n      }\n    }\n    \n    return null; // 所有植物都已完成\n  }\n\n  /**\n   * 获取详细的图片统计信息\n   */\n  getDetailedImageStats() {\n    const plants = this.getPlantList();\n    let totalImages = 0;\n    let completedImages = 0;\n    let totalPlants = plants.length;\n    let completedPlants = 0;\n    \n    const plantStats = [];\n\n    for (const plant of plants) {\n      const plantImageCount = plant.imageCount || 0;\n      totalImages += plantImageCount;\n      \n      const plantStat = {\n        plantId: plant.id,\n        imageCount: plantImageCount,\n        status: plant.status,\n        isCompleted: plant.status === 'completed'\n      };\n      \n      if (plant.status === 'completed') {\n        completedPlants++;\n        completedImages += plantImageCount;\n      }\n      \n      plantStats.push(plantStat);\n    }\n\n    const completionRate = totalImages > 0 ? (completedImages / totalImages * 100) : 0;\n    const plantCompletionRate = totalPlants > 0 ? (completedPlants / totalPlants * 100) : 0;\n\n    return {\n      totalImages,\n      completedImages,\n      totalPlants,\n      completedPlants,\n      completionRate: completionRate.toFixed(1),\n      plantCompletionRate: plantCompletionRate.toFixed(1),\n      pendingImages: totalImages - completedImages,\n      plantStats\n    };\n  }\n\n  /**\n   * 获取简化的图片统计信息\n   */\n  getImageStats() {\n    const detailed = this.getDetailedImageStats();\n    return {\n      totalImages: detailed.totalImages,\n      completedImages: detailed.completedImages,\n      totalPlants: detailed.totalPlants,\n      completedPlants: detailed.completedPlants,\n      completionRate: detailed.completionRate\n    };\n  }\n\n  /**\n   * 获取进度统计\n   */\n  getProgress() {\n    const plants = this.getPlantList();\n    const total = plants.length;\n    \n    // 使用持久化存储的统计信息\n    const persistentStats = this.annotationStorage.getAnnotationStats(total);\n    \n    // 结合内存中的状态\n    const completed = plants.filter(plant => plant.status === 'completed').length;\n    const inProgress = plants.filter(plant => plant.status === 'in-progress').length;\n    const pending = plants.filter(plant => plant.status === 'pending').length;\n    const skipped = plants.filter(plant => plant.status === 'skipped').length;\n\n    // 计算总完成数（包括跳过的植株）\n    const totalCompleted = completed + skipped;\n\n    // 添加图片统计\n    const imageStats = this.getImageStats();\n\n    return {\n      total,\n      completed: Math.max(completed, persistentStats.completed),\n      inProgress,\n      pending,\n      skipped,\n      totalCompleted, // 新增：包含跳过的总完成数\n      completionRate: total > 0 ? (Math.max(totalCompleted, persistentStats.completed + skipped) / total * 100).toFixed(1) : 0,\n      persistent: persistentStats,\n      images: imageStats\n    };\n  }\n\n  /**\n   * 搜索植物\n   */\n  searchPlants(query) {\n    if (!query) {\n      return this.getPlantList();\n    }\n    \n    const lowerQuery = query.toLowerCase();\n    return this.getPlantList().filter(plant => \n      plant.id.toLowerCase().includes(lowerQuery) ||\n      plant.name.toLowerCase().includes(lowerQuery)\n    );\n  }\n\n  /**\n   * 按状态过滤植物\n   */\n  filterPlantsByStatus(status) {\n    if (status === 'all') {\n      return this.getPlantList();\n    }\n    \n    return this.getPlantList().filter(plant => plant.status === status);\n  }\n\n  /**\n   * 触发植物更新事件\n   */\n  emitPlantUpdated(plant) {\n    // 触发自定义事件\n    const event = new CustomEvent('plantUpdated', {\n      detail: { plant }\n    });\n    document.dispatchEvent(event);\n  }\n\n  /**\n   * 清理资源和缓存\n   */\n  cleanup() {\n    this.plants.clear();\n    this.plantImages.clear();\n    this.annotationStatus.clear();\n    this.loadingPlants.clear();\n    \n    if (this.fileSystemManager) {\n      this.fileSystemManager.cleanup();\n    }\n  }\n\n  /**\n   * 导出所有标注数据\n   */\n  exportAllAnnotations() {\n    // 使用持久化存储的导出功能\n    return this.annotationStorage.exportAllAnnotations();\n  }\n\n  /**\n   * 下载标注数据为JSON文件\n   */\n  downloadAnnotationsAsJSON() {\n    return this.annotationStorage.downloadAnnotationsAsJSON();\n  }\n\n  /**\n   * 导出所有图像的纯净标注数据（新格式）\n   * 不包含时间序列管理的内部信息，直接输出图像ID对应的标注点\n   */\n  async exportPureImageAnnotations() {\n    return await this.annotationStorage.exportPureImageAnnotations();\n  }\n\n  /**\n   * 下载纯净的图像标注数据为JSON文件\n   */\n  async downloadPureImageAnnotationsAsJSON() {\n    return await this.annotationStorage.downloadPureImageAnnotationsAsJSON();\n  }\n\n  /**\n   * 获取导出数据的统计信息\n   */\n  async getExportStats() {\n    const pureAnnotations = await this.exportPureImageAnnotations();\n    const timeSeriesStats = this.timeSeriesManager.getExportStats();\n    \n    return {\n      pureFormat: this.annotationStorage.getPureAnnotationsStats(pureAnnotations),\n      timeSeriesFormat: timeSeriesStats,\n      recommendation: '建议使用纯净格式进行数据分析和处理'\n    };\n  }\n\n  /**\n   * 调试：检查时间序列数据状态和导出问题\n   */\n  async debugTimeSeriesExport() {\n    console.log('=== 时间序列导出调试 ===');\n    \n    // 1. 检查时间序列管理器状态\n    const timeSeriesStatus = this.timeSeriesManager.getDebugStatus();\n    \n    // 2. 检查时间序列管理器中的详细数据\n    const timeSeriesData = this.timeSeriesManager.exportAllTimeSeriesDataDebug();\n    \n    // 3. 检查导出的纯净数据\n    const pureAnnotations = await this.exportPureImageAnnotations();\n    console.log('导出的纯净标注数据:', pureAnnotations);\n    \n    // 4. 检查存储管理器中的数据\n    const storageAnnotations = this.annotationStorage.annotations;\n    console.log('存储管理器中的数据:', Array.from(storageAnnotations.entries()));\n    \n    // 5. 比较数据差异\n    const comparison = {\n      timeSeriesManagerImages: timeSeriesStatus.totalAnnotatedImages,\n      pureExportImages: Object.keys(pureAnnotations).length,\n      storageManagerPlants: storageAnnotations.size\n    };\n    \n    console.log('数据比较:', comparison);\n    \n    return {\n      timeSeriesStatus,\n      timeSeriesData,\n      pureAnnotations,\n      storageData: Array.from(storageAnnotations.entries()),\n      comparison\n    };\n  }\n\n  /**\n   * 保存标注状态到本地存储\n   */\n  saveAnnotationStatus(plantId, data) {\n    try {\n      const storageKey = `plant_annotation_${plantId}`;\n      const savedData = {\n        ...data,\n        savedAt: new Date().toISOString()\n      };\n      localStorage.setItem(storageKey, JSON.stringify(savedData));\n    } catch (error) {\n      console.error('保存标注状态失败:', error);\n    }\n  }\n\n  /**\n   * 从本地存储加载标注状态\n   */\n  loadAnnotationStatus(plantId) {\n    try {\n      const storageKey = `plant_annotation_${plantId}`;\n      const saved = localStorage.getItem(storageKey);\n      \n      if (saved) {\n        return JSON.parse(saved);\n      }\n    } catch (error) {\n      console.error('加载标注状态失败:', error);\n    }\n    \n    return null;\n  }\n\n  /**\n   * 🔧 FIXED: 确保标注数据都有序号（支持类型特定编号系统）\n   * 为缺少序号的标注点分配序号，但保持类型特定的编号系统\n   */\n  ensureAnnotationOrders(annotations) {\n    if (!annotations || annotations.length === 0) {\n      return;\n    }\n    \n    // 🔧 FIX: 按类型分组标注点\n    const annotationsByType = {};\n    \n    // 分组：内置regular(已迁移为自定义) 与 各种自定义类型\n    annotations.forEach(annotation => {\n      // 🐛 BUGFIX: Ensure all annotations have annotationType field set\n      if (!annotation.annotationType) {\n        // 🔧 FIX: Smart detection - check if this is actually a custom annotation\n        if (annotation.customTypeId) {\n          annotation.annotationType = 'custom'; // Preserve custom type\n        } else {\n          // 迁移后不应再出现纯regular，兜底映射到内置类型\n          annotation.annotationType = 'custom';\n          annotation.customTypeId = annotation.customTypeId || 'builtin-regular-keypoint';\n        }\n      }\n      \n      const typeKey = annotation.annotationType === 'custom' \n        ? `custom:${annotation.customTypeId || 'unknown'}`\n        : `custom:builtin-regular-keypoint`;\n      \n      if (!annotationsByType[typeKey]) {\n        annotationsByType[typeKey] = [];\n      }\n      annotationsByType[typeKey].push(annotation);\n    });\n    \n    let totalFixed = 0;\n    \n    // 🔧 FIX: 为每个类型独立处理序号\n    Object.entries(annotationsByType).forEach(([typeKey, typeAnnotations]) => {\n      let hasOrderIssues = false;\n      \n      // 检查该类型是否有序号问题\n      for (let i = 0; i < typeAnnotations.length; i++) {\n        if (typeof typeAnnotations[i].order !== 'number' || typeAnnotations[i].order <= 0) {\n          hasOrderIssues = true;\n          break;\n        }\n      }\n      \n      // 检查该类型内部是否有重复序号\n      if (!hasOrderIssues) {\n        const orders = typeAnnotations.map(kp => kp.order);\n        const uniqueOrders = [...new Set(orders)];\n        if (uniqueOrders.length !== orders.length) {\n          hasOrderIssues = true;\n        }\n      }\n      \n      // 如果该类型有序号问题，重新分配\n      if (hasOrderIssues) {\n        console.log(`发现 ${typeKey} 类型标注序号问题，正在为 ${typeAnnotations.length} 个标注点分配序号...`);\n        \n        // 按照原有顺序为该类型分配序号（从1开始）\n        for (let i = 0; i < typeAnnotations.length; i++) {\n          typeAnnotations[i].order = i + 1;\n        }\n        \n        totalFixed += typeAnnotations.length;\n        console.log(`已为 ${typeKey} 类型分配序号：1-${typeAnnotations.length}`);\n      }\n    });\n    \n    if (totalFixed > 0) {\n      console.log(`序号修复完成：共修复 ${totalFixed} 个标注点，保持类型特定编号系统`);\n    }\n  }\n} ","/**\n * 标注工具组件\n * \n * 功能：\n * - Canvas图像渲染和缩放\n * - 触摸板缩放支持 (0.1x-10x)\n * - 关键点添加、删除、拖拽\n * - 撤销/重做功能\n * - 视图状态管理\n */\n\nexport class AnnotationTool {\n  constructor(canvasId, options = {}) {\n    console.log('[调试] AnnotationTool 构造函数被调用', { canvasId, timestamp: Date.now() });\n\n    this.canvas = document.getElementById(canvasId);\n    if (!this.canvas) {\n      throw new Error(`Canvas element with id \"${canvasId}\" not found`);\n    }\n    \n    this.ctx = this.canvas.getContext('2d');\n    this.options = {\n      minZoom: 0.1,\n      maxZoom: 10,\n      zoomSpeed: 0.1,\n      // 标注点基础配置\n      baseKeypointRadius: 8,               // 基础标注点半径\n      minKeypointRadius: 4,                // 最小标注点半径  \n      maxKeypointRadius: 20,               // 最大标注点半径\n      keypointScaleFactor: 0.8,            // 标注点缩放因子\n      // 颜色配置\n      keypointLeftColor: '#ff4444',        // 左侧关键点颜色\n      keypointRightColor: '#4444ff',       // 右侧关键点颜色\n      keypointHoverColor: '#ff6666',\n      keypointSelectedColor: '#ffaa00',    // 选中关键点颜色\n      keypointBorderColor: '#ffffff',\n      keypointBorderWidth: 2,\n      // 标签显示配置\n      labelThresholdScale: 0.6,            // 标签外部显示的缩放阈值\n      tinyThresholdScale: 0.3,             // 极小显示模式的缩放阈值\n      labelOffset: 15,                     // 外部标签偏移距离\n      // 方向标注配置\n      directionThreshold: 20,              // 最小拖拽距离阈值\n      directionArrowLength: 40,            // 方向箭头长度\n      ...options\n    };\n    \n    // 状态管理\n    this.state = {\n      scale: 1,\n      translateX: 0,\n      translateY: 0,\n      isDragging: false,\n      isPanning: false,\n      lastPanPoint: null,\n      // 新增：方向标注状态\n      isDirectionDragging: false,\n      dragStartPoint: null,\n      currentDragPoint: null,\n      previewKeypoint: null,\n      // 新增：选中和方向选择状态\n      selectedKeypoint: null,               // 当前选中的关键点\n      isDirectionSelectionMode: false,     // 是否处于方向选择模式\n      directionSelectionPoint: null,       // 方向选择的鼠标位置\n      // 新增：自动化方向选择状态\n      isAutoDirectionMode: false,          // 是否处于自动化方向选择模式\n      autoDirectionIndex: 0,               // 当前自动选择的关键点索引\n      autoDirectionKeypoints: [],          // 需要自动选择方向的关键点列表\n      // 🔧 NEW: 多方向标注状态\n      isDirectionCountMode: false,         // 是否处于方向数量选择模式\n      currentDirectionCount: 1,            // 当前方向数量\n      directionsSet: 0,                    // 已设置的方向数量\n      // 新增：自动切换到预期位置\n      autoMoveToExpectedPosition: false,   // 是否自动切换到预期位置\n      // 新增：自定义区域拖拽状态\n      isCustomRegionDragging: false,       // 是否正在拖拽自定义区域\n      customRegionStartPoint: null,        // 区域拖拽开始点\n      customRegionCurrentPoint: null       // 区域拖拽当前点\n    };\n    \n    // 图像相关\n    this.currentImage = null;\n    this.imageElement = null;\n    this.imageLoaded = false;\n    \n    // 标注数据\n    this.keypoints = [];\n    this.hoveredKeypoint = null;\n    this.draggedKeypoint = null;\n    \n    // 历史管理（撤销/重做）\n    this.history = [];\n    this.historyIndex = -1;\n    this.maxHistorySize = 50;\n    \n    // 自定义标注系统\n    this.customAnnotationManager = null;\n    this.customAnnotationRenderer = null;\n    \n    // 自定义标注拖拽状态\n    this.customAnnotationDragState = {\n      isDragging: false,\n      draggedAnnotation: null,\n      startPosition: null\n    };\n    \n    // 🔧 NEW: 图像切换锁定机制 - 防止快速切换时的数据混乱\n    this.imageSwitchLock = {\n      isLocked: false,\n      currentLoadingImageId: null,\n      lockStartTime: null\n    };\n    \n    // 🔧 NEW: Enhanced Auto Direction State Management\n    this.autoDirectionMode = 'longitudinal'; // 'longitudinal' | 'cross-sectional' - default fallback\n    this.crossSectionalState = null; // Will be initialized when cross-sectional mode starts\n    this.crossSectionalMap = new Map(); // Maps order numbers to image-annotation pairs\n    \n    // 绑定事件\n    this.bindEvents();\n    \n    // 初始化Canvas\n    this.initializeCanvas();\n    \n    // 初始化自定义标注系统 - 异步但立即开始\n    this.initializeCustomAnnotationSystem();\n    \n    // 🔧 FIX: Initialize auto direction mode from UI selector\n    this.initializeAutoDirectionModeFromUI();\n    \n    console.log('AnnotationTool initialized with advanced direction annotation support and custom annotations');\n  }\n\n  /**\n   * 🔧 FIX: Initialize auto direction mode from UI selector\n   */\n  initializeAutoDirectionModeFromUI() {\n    // Use setTimeout to ensure DOM is fully loaded\n    setTimeout(() => {\n      const modeSelector = document.getElementById('auto-direction-mode-selector');\n      if (modeSelector && modeSelector.value) {\n        this.autoDirectionMode = modeSelector.value;\n        console.log('[调试] 从UI选择器初始化自动方向模式:', this.autoDirectionMode);\n      } else {\n        // Set default value in UI selector if none exists\n        this.autoDirectionMode = 'longitudinal';\n        if (modeSelector) {\n          modeSelector.value = 'longitudinal';\n          console.log('[调试] 设置UI选择器默认值为: longitudinal');\n        }\n      }\n    }, 100);\n  }\n\n  /**\n   * 初始化Canvas\n   */\n  initializeCanvas() {\n    // 🔧 FIX: Add resize state tracking and debouncing\n    this.resizeState = {\n      isResizing: false,\n      lastResizeTime: 0,\n      debounceTimeout: null,\n      dimensionsHistory: []\n    };\n    \n    // 延迟设置Canvas尺寸，确保容器已正确渲染\n    setTimeout(() => {\n      this.resizeCanvasWithRetry();\n    }, 200);\n    \n    // 设置Canvas样式\n    this.canvas.style.cursor = 'crosshair';\n    \n    // 🔧 FIX: Debounced window resize listener to prevent excessive resizing\n    window.addEventListener('resize', () => {\n      this.debouncedResize();\n    });\n  }\n\n  /**\n   * 带重试机制的Canvas尺寸调整\n   */\n  resizeCanvasWithRetry(retryCount = 0) {\n    const maxRetries = 10;\n    const container = this.canvas.parentElement;\n    const rect = container.getBoundingClientRect();\n    \n    // 检查容器尺寸是否有效\n    if (rect.width === 0 || rect.height === 0) {\n      if (retryCount < maxRetries) {\n        console.warn(`Canvas容器尺寸为0，延迟重试... (${retryCount + 1}/${maxRetries})`);\n        setTimeout(() => {\n          this.resizeCanvasWithRetry(retryCount + 1);\n        }, 300); // 增加重试间隔\n        return;\n      } else {\n        console.error('Canvas容器尺寸始终为0，使用默认尺寸');\n        // 使用默认尺寸\n        this.canvas.width = 600;\n        this.canvas.height = 400;\n        this.canvas.style.width = '600px';\n        this.canvas.style.height = '400px';\n        this.render();\n        return;\n      }\n    }\n    \n    // 设置正确的尺寸\n    this.resizeCanvas();\n    this.render();\n  }\n\n  /**\n   * 🔧 ENHANCED: Debounced resize handler to prevent resize loops\n   */\n  debouncedResize() {\n    const now = Date.now();\n    \n    // 🔧 FIX: Prevent resize loops with timing checks\n    if (this.resizeState.isResizing && (now - this.resizeState.lastResizeTime) < 100) {\n      console.debug('Resize loop detected, skipping resize');\n      return;\n    }\n    \n    // Clear existing debounce timeout\n    if (this.resizeState.debounceTimeout) {\n      clearTimeout(this.resizeState.debounceTimeout);\n    }\n    \n    // Debounce resize calls\n    this.resizeState.debounceTimeout = setTimeout(() => {\n      this.resizeCanvas();\n      this.render();\n    }, 150); // 150ms debounce\n  }\n\n  /**\n   * 调整Canvas尺寸 - Enhanced with loop prevention\n   */\n  resizeCanvas() {\n    const container = this.canvas.parentElement;\n    const rect = container.getBoundingClientRect();\n    \n    // 确保容器有有效尺寸\n    if (rect.width === 0 || rect.height === 0) {\n      console.warn('Canvas容器尺寸无效，跳过调整');\n      return;\n    }\n    \n    // 🔧 FIX: Prevent resize loops by checking if dimensions actually changed\n    const currentDimensions = `${rect.width}x${rect.height}`;\n    const history = this.resizeState.dimensionsHistory;\n    \n    // Check if we're oscillating between dimensions\n    if (history.length >= 3) {\n      const recent = history.slice(-3);\n      if (recent.includes(currentDimensions) && recent.filter(d => d === currentDimensions).length >= 2) {\n        console.warn(`Canvas resize oscillation detected (${currentDimensions}), stabilizing...`);\n        return;\n      }\n    }\n    \n    // Record dimension change\n    history.push(currentDimensions);\n    if (history.length > 5) {\n      history.shift(); // Keep only recent 5 changes\n    }\n    \n    // 🔧 FIX: Set resize state to prevent recursive calls\n    this.resizeState.isResizing = true;\n    this.resizeState.lastResizeTime = Date.now();\n    \n    try {\n      // 设置Canvas实际尺寸\n      this.canvas.width = rect.width;\n      this.canvas.height = rect.height;\n      \n      // 设置Canvas显示尺寸\n      this.canvas.style.width = rect.width + 'px';\n      this.canvas.style.height = rect.height + 'px';\n      \n      console.log(`Canvas resized to ${rect.width}x${rect.height}`);\n      \n      // 🔧 FIX: Only call fitToScreen if not already in resize process\n      if (this.imageLoaded && this.imageElement && !this.resizeState.fittingToScreen) {\n        this.safeFitToScreen();\n      }\n    } finally {\n      // Reset resize state after a delay\n      setTimeout(() => {\n        this.resizeState.isResizing = false;\n      }, 200);\n    }\n  }\n\n  /**\n   * 绑定事件监听器\n   */\n  bindEvents() {\n    console.log('[调试] bindEvents 被调用，绑定鼠标事件监听器', { timestamp: Date.now() });\n\n    // 鼠标事件\n    this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));\n    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n    this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));\n    this.canvas.addEventListener('contextmenu', (e) => this.handleContextMenu(e));\n    \n    // 触摸板缩放\n    this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });\n    \n    // 键盘事件\n    document.addEventListener('keydown', (e) => this.handleKeyDown(e));\n    document.addEventListener('keyup', (e) => this.handleKeyUp(e));\n    \n    // 防止上下文菜单\n    this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());\n  }\n\n  /**\n   * 🔧 ENHANCED: 加载图像（带图像切换锁定机制）\n   * @param {Object} imageData - 图像数据\n   * @param {boolean} preserveView - 是否保持当前视图状态（缩放和位置）\n   */\n  async loadImage(imageData, preserveView = false) {\n    try {\n      console.log('Loading image:', imageData.name);\n      \n      // 🔧 NEW: 设置图像切换锁定，防止auto-save在切换过程中执行\n      this.setImageSwitchLock(true, imageData.id);\n      \n      // 🔧 NEW: 图像切换时中断所有方向相关模式\n      this.interruptAllDirectionModes('image_switch');\n      \n      this.currentImage = imageData;\n      this.imageLoaded = false;\n      \n      // 检查plantDataManager是否可用\n      if (!window.PlantAnnotationTool || !window.PlantAnnotationTool.plantDataManager) {\n        // 🔧 FIX: 出错时解锁\n        this.setImageSwitchLock(false);\n        throw new Error('PlantDataManager未初始化，请刷新页面重试');\n      }\n      \n      const plantDataManager = window.PlantAnnotationTool.plantDataManager;\n      \n      if (!plantDataManager.fileSystemManager) {\n        // 🔧 FIX: 出错时解锁\n        this.setImageSwitchLock(false);\n        throw new Error('FileSystemManager未初始化，请刷新页面重试');\n      }\n      \n      // 获取图像URL\n      const imageURL = await plantDataManager.fileSystemManager.createImageURL(imageData);\n      \n      // 创建图像元素\n      this.imageElement = new Image();\n      this.imageElement.crossOrigin = 'anonymous'; // 🔧 FIX: Allow canvas access for SIFT matching\n      \n      return new Promise((resolve, reject) => {\n        this.imageElement.onload = () => {\n          this.imageLoaded = true;\n          console.log(`Image loaded: ${this.imageElement.width}x${this.imageElement.height}`);\n\n          // 根据preserveView参数决定是否重置视图\n          if (!preserveView) {\n            // 🔧 FIX: Use safe fit to screen to prevent resize loops\n            this.safeFitToScreen();\n            console.log('重置视图到适合屏幕');\n          } else {\n            console.log('保持当前视图状态');\n          }\n\n          // 注意：不再自动清空标注点，让外部调用者决定是否需要清空\n          // this.clearKeypoints(); // 移除这行\n\n          // 渲染\n          this.render();\n\n          // 🔧 NEW: 图像加载完成后解锁，允许auto-save\n          this.setImageSwitchLock(false);\n\n          resolve();\n        };\n        \n        this.imageElement.onerror = () => {\n          // 🔧 FIX: 出错时解锁\n          this.setImageSwitchLock(false);\n          reject(new Error('Failed to load image'));\n        };\n        \n        this.imageElement.src = imageURL;\n      });\n      \n    } catch (error) {\n      console.error('Error loading image:', error);\n      // 🔧 FIX: 出错时解锁\n      this.setImageSwitchLock(false);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 ENHANCED: Safe fit to screen with loop prevention\n   */\n  safeFitToScreen() {\n    // Prevent recursive fit-to-screen calls\n    if (this.resizeState.fittingToScreen) {\n      console.debug('fitToScreen already in progress, skipping');\n      return;\n    }\n    \n    this.resizeState.fittingToScreen = true;\n    \n    try {\n      this.fitToScreen();\n    } finally {\n      // Reset flag after processing\n      setTimeout(() => {\n        this.resizeState.fittingToScreen = false;\n      }, 50);\n    }\n  }\n\n  /**\n   * 适应屏幕尺寸 - Enhanced with stability checks\n   */\n  fitToScreen() {\n    if (!this.imageElement || !this.imageLoaded) return;\n    \n    const canvasWidth = this.canvas.width;\n    const canvasHeight = this.canvas.height;\n    const imageWidth = this.imageElement.width;\n    const imageHeight = this.imageElement.height;\n    \n    // 🔧 FIX: Validate canvas and image dimensions\n    if (canvasWidth <= 0 || canvasHeight <= 0 || imageWidth <= 0 || imageHeight <= 0) {\n      console.warn('Invalid dimensions for fit to screen, skipping');\n      return;\n    }\n    \n    // 计算缩放比例（保持宽高比）\n    const scaleX = (canvasWidth * 0.9) / imageWidth;\n    const scaleY = (canvasHeight * 0.9) / imageHeight;\n    const scale = Math.min(scaleX, scaleY);\n    \n    // 🔧 FIX: Add scale change detection to prevent unnecessary updates\n    const newScale = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, scale));\n    const scaleChange = Math.abs(newScale - this.state.scale);\n    \n    // Only update if scale change is significant (more than 1%)\n    if (scaleChange > 0.01) {\n      this.state.scale = newScale;\n      \n      // 居中显示\n      this.state.translateX = (canvasWidth - imageWidth * this.state.scale) / 2;\n      this.state.translateY = (canvasHeight - imageHeight * this.state.scale) / 2;\n      \n      this.updateZoomInfo();\n      console.log(`Fit to screen: scale=${this.state.scale.toFixed(2)} (change: ${scaleChange.toFixed(3)})`);\n    } else {\n      console.debug(`Scale change too small (${scaleChange.toFixed(3)}), skipping update`);\n    }\n  }\n\n  /**\n   * 重置视图\n   */\n  resetView() {\n    if (!this.imageElement || !this.imageLoaded) return;\n    \n    this.state.scale = 1;\n    this.state.translateX = 0;\n    this.state.translateY = 0;\n    \n    this.updateZoomInfo();\n    this.render();\n  }\n\n  /**\n   * 清空图像和重置视图 - 用于植物切换时完全清空工作区\n   */\n  clearImage() {\n    console.log('清空图像和重置视图');\n    \n    // 🔧 NEW: 植物切换时中断所有方向相关模式\n    this.interruptAllDirectionModes('plant_switch');\n    \n    // 清空图像相关状态\n    this.currentImage = null;\n    this.imageElement = null;\n    this.imageLoaded = false;\n    \n    // 重置视图状态\n    this.state.scale = 1;\n    this.state.translateX = 0;\n    this.state.translateY = 0;\n    \n    // 🔧 FIX: 清空标注点但不触发自动保存（防止覆盖已保存的数据）\n    this.clearKeypointsWithoutSave();\n    \n    // 🔧 FIX: Additional safety - clear any keypoint labels that might remain\n    this.clearKeypointLabels();\n    \n    // 更新显示\n    this.updateZoomInfo();\n    this.render(); // 现在会显示占位符而不是图像和标注点\n  }\n\n  /**\n   * 渲染Canvas\n   */\n  render() {\n    // 清空Canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (!this.imageElement || !this.imageLoaded) {\n      this.renderPlaceholder();\n      return;\n    }\n    \n    // 保存Canvas状态\n    this.ctx.save();\n    \n    // 应用变换\n    this.ctx.translate(this.state.translateX, this.state.translateY);\n    this.ctx.scale(this.state.scale, this.state.scale);\n    \n    // 绘制图像\n    this.ctx.drawImage(this.imageElement, 0, 0);\n    \n    // 恢复Canvas状态\n    this.ctx.restore();\n    \n    // 🔧 NEW: 如果在校准预览模式，渲染校准可视化\n    if (this.calibrationPreviewState?.isActive) {\n      this.renderCalibrationPreview();\n    } else {\n      // 正常模式：绘制标注点\n      this.renderKeypoints();\n    }\n    \n    // 绘制自定义标注\n    this.renderCustomAnnotations();\n  }\n\n  /**\n   * 渲染占位符\n   */\n  renderPlaceholder() {\n    const centerX = this.canvas.width / 2;\n    const centerY = this.canvas.height / 2;\n    \n    this.ctx.fillStyle = '#f3f4f6';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    this.ctx.fillStyle = '#6b7280';\n    this.ctx.font = '16px Inter, sans-serif';\n    this.ctx.textAlign = 'center';\n    this.ctx.fillText('Please choose image to annotate', centerX, centerY);\n  }\n\n  /**\n   * 渲染标注点（统一版本，支持自定义类型）\n   */\n  renderKeypoints() {\n    // 🔧 FIX: Don't render keypoints when no image is loaded to prevent \"ghost\" annotations\n    if (!this.imageElement || !this.imageLoaded) {\n      console.log('[AnnotationTool] Skipping keypoint render - no image loaded');\n      return;\n    }\n    \n    // 清除所有标签元素\n    this.clearKeypointLabels();\n    \n    // 获取当前的显示策略\n    const displayStrategy = this.getKeypointDisplayStrategy();\n    \n    // 渲染已存在的标注点\n    this.keypoints.forEach((keypoint, index) => {\n      const screenPos = this.imageToScreen(keypoint.x, keypoint.y);\n      \n      // 🔄 NEW: 统一渲染系统 - 支持自定义类型\n      if (keypoint.annotationType === 'custom') {\n        this.renderCustomKeypoint(keypoint, screenPos, displayStrategy);\n      } else {\n        // 将任何非custom标注兜底视为内置regular类型（迁移后极少出现）\n        const fallback = { ...keypoint, annotationType: 'custom', customTypeId: 'builtin-regular-keypoint' };\n        this.renderCustomKeypoint(fallback, screenPos, displayStrategy);\n      }\n    });\n    \n    // 渲染拖拽预览\n    if (this.state.isDirectionDragging && this.state.previewKeypoint) {\n      const previewPos = this.imageToScreen(this.state.previewKeypoint.x, this.state.previewKeypoint.y);\n      const direction = this.state.previewKeypoint.direction;\n      const fillColor = direction === 'left' ? this.options.keypointLeftColor : this.options.keypointRightColor;\n      \n      // 半透明预览\n      this.ctx.globalAlpha = 0.7;\n      this.renderSingleKeypoint(previewPos.x, previewPos.y, fillColor, '?', direction, displayStrategy);\n      this.ctx.globalAlpha = 1.0;\n      \n      // 绘制拖拽指示器\n      this.renderDragIndicator();\n    }\n    \n    // 渲染自定义区域拖拽预览\n    if (this.state.isCustomRegionDragging) {\n      this.renderCustomRegionPreview();\n    }\n    \n    // 渲染方向选择指引\n    if (this.state.isDirectionSelectionMode && this.state.selectedKeypoint && this.state.directionSelectionPoint) {\n      this.renderDirectionSelectionGuide();\n    }\n    \n    // 更新缩放级别指示器\n    this.updateZoomIndicator(displayStrategy);\n    \n    // 更新标注点大小信息\n    this.updateAnnotationSizeInfo(displayStrategy);\n  }\n\n  /**\n   * 🔄 NEW: 渲染常规标注点\n   */\n  renderRegularKeypoint(keypoint, screenPos, displayStrategy, index) {\n    // 确定颜色（根据方向和选中状态）\n    const isHovered = this.hoveredKeypoint === keypoint;\n    const isSelected = this.state.selectedKeypoint === keypoint;\n    let fillColor;\n    \n    if (isSelected) {\n      fillColor = this.options.keypointSelectedColor;\n    } else if (isHovered) {\n      fillColor = this.options.keypointHoverColor;\n    } else if (keypoint.directionType === 'angle' || typeof keypoint.direction === 'number') {\n      // 角度类型使用特殊颜色\n      fillColor = '#00aa00'; // 绿色表示已设置角度\n    } else if (keypoint.direction === 'left') {\n      fillColor = this.options.keypointLeftColor;\n    } else if (keypoint.direction === 'right') {\n      fillColor = this.options.keypointRightColor;\n    } else {\n      // 无方向标注点使用紫色\n      fillColor = '#9333ea'; // 紫色表示无方向\n    }\n    \n    // 使用标注点的序号，如果没有则使用索引+1作为后备\n    const displayOrder = keypoint.order || (index + 1);\n    \n    this.renderSingleKeypoint(screenPos.x, screenPos.y, fillColor, displayOrder, keypoint.direction, displayStrategy, keypoint);\n\n    // 🔧 NEW: 绘制多方向箭头（如果有多个方向）\n    if (keypoint.directions && keypoint.directions.length > 1) {\n      this.renderMultipleDirections(keypoint);\n    } else {\n      // 绘制单一方向箭头（支持所有类型的方向）\n      this.renderDirectionIndicator(screenPos.x, screenPos.y, keypoint.direction, keypoint);\n    }\n  }\n  \n  /**\n   * 🔄 NEW: 渲染自定义标注点\n   */\n  renderCustomKeypoint(keypoint, screenPos, displayStrategy) {\n    const customType = this.getCustomType(keypoint.customTypeId);\n    if (!customType) {\n      console.warn(`Custom type ${keypoint.customTypeId} not found`);\n      return;\n    }\n    \n    // 确定透明度\n    const isHovered = this.hoveredKeypoint === keypoint;\n    const isSelected = this.state.selectedKeypoint === keypoint;\n    let alpha = 1;\n    \n    if (isSelected) {\n      alpha = 0.9;\n    } else if (isHovered) {\n      alpha = 0.8;\n    }\n    \n    this.ctx.save();\n    this.ctx.globalAlpha = alpha;\n    \n    if (keypoint.width && keypoint.height) {\n      // 渲染区域标注\n      this.renderCustomRegion(keypoint, screenPos, customType, displayStrategy);\n    } else {\n      // 渲染点标注\n      this.renderCustomPoint(keypoint, screenPos, customType, displayStrategy);\n    }\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 🔄 NEW: 渲染自定义点标注\n   */\n  renderCustomPoint(keypoint, screenPos, customType, displayStrategy) {\n    // 绘制点\n    this.ctx.beginPath();\n    this.ctx.arc(screenPos.x, screenPos.y, displayStrategy.radius, 0, 2 * Math.PI);\n    this.ctx.fillStyle = customType.color;\n    this.ctx.fill();\n    \n    // 绘制边框\n    this.ctx.strokeStyle = '#ffffff';\n    this.ctx.lineWidth = displayStrategy.borderWidth;\n    this.ctx.stroke();\n    \n    // 绘制标签\n    if (displayStrategy.showInternalLabel) {\n      this.ctx.fillStyle = '#ffffff';\n      this.ctx.font = `bold ${displayStrategy.fontSize}px Arial`;\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'middle';\n      this.ctx.fillText(keypoint.order.toString(), screenPos.x, screenPos.y);\n    } else if (displayStrategy.showExternalLabel) {\n      this.renderCustomPointLabel(keypoint, screenPos, customType, displayStrategy);\n    }\n\n    // 绘制方向指示（默认开启；仅当显式为 false 时关闭）\n    if (!(customType && customType.metadata && customType.metadata.isDirectional === false)) {\n      this.renderDirectionIndicator(screenPos.x, screenPos.y, keypoint.direction, keypoint);\n    }\n  }\n  \n  /**\n   * 🔄 NEW: 渲染自定义区域标注\n   */\n  renderCustomRegion(keypoint, screenPos, customType, displayStrategy) {\n    // 计算区域屏幕坐标\n    const bottomRightScreen = this.imageToScreen(\n      keypoint.x + keypoint.width,\n      keypoint.y + keypoint.height\n    );\n    \n    const screenWidth = bottomRightScreen.x - screenPos.x;\n    const screenHeight = bottomRightScreen.y - screenPos.y;\n    \n    // 绘制填充区域\n    this.ctx.fillStyle = customType.color;\n    this.ctx.globalAlpha = 0.2;\n    this.ctx.fillRect(screenPos.x, screenPos.y, screenWidth, screenHeight);\n    \n    // 绘制边框\n    this.ctx.globalAlpha = 1.0;\n    this.ctx.strokeStyle = customType.color;\n    this.ctx.lineWidth = displayStrategy.borderWidth;\n    this.ctx.strokeRect(screenPos.x, screenPos.y, screenWidth, screenHeight);\n    \n    // 绘制标签（在中心）\n    const centerX = screenPos.x + screenWidth / 2;\n    const centerY = screenPos.y + screenHeight / 2;\n    \n    if (displayStrategy.showInternalLabel && Math.min(screenWidth, screenHeight) > 20) {\n      this.ctx.fillStyle = customType.color;\n      this.ctx.font = `bold ${displayStrategy.fontSize}px Arial`;\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'middle';\n      this.ctx.fillText(keypoint.order.toString(), centerX, centerY);\n    }\n    \n    if (displayStrategy.showExternalLabel) {\n      this.renderCustomRegionLabel(keypoint, { x: centerX, y: screenPos.y }, customType, displayStrategy);\n    }\n\n    // 绘制方向指示（矩形中心为锚点；默认开启，除非 isDirectional === false）\n    if (!(customType && customType.metadata && customType.metadata.isDirectional === false)) {\n      this.renderDirectionIndicator(\n        centerX,\n        centerY,\n        keypoint.direction,\n        keypoint\n      );\n    }\n  }\n  \n  /**\n   * 🔄 NEW: 渲染自定义点标签\n   */\n  renderCustomPointLabel(keypoint, screenPos, customType, displayStrategy) {\n    const labelY = screenPos.y - displayStrategy.radius - displayStrategy.labelOffset;\n    \n    this.ctx.save();\n    \n    // 创建标签文本\n    const labelText = `${customType.name} #${keypoint.order}`;\n    this.ctx.font = `${displayStrategy.fontSize}px Arial`;\n    const textMetrics = this.ctx.measureText(labelText);\n    const textWidth = textMetrics.width;\n    \n    // 绘制标签背景\n    const padding = 4;\n    this.ctx.fillStyle = customType.color;\n    this.ctx.fillRect(\n      screenPos.x - textWidth / 2 - padding,\n      labelY - displayStrategy.fontSize / 2 - padding,\n      textWidth + padding * 2,\n      displayStrategy.fontSize + padding * 2\n    );\n    \n    // 绘制标签文本\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(labelText, screenPos.x, labelY);\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 🔄 NEW: 渲染自定义区域标签\n   */\n  renderCustomRegionLabel(keypoint, screenPos, customType, displayStrategy) {\n    const labelY = screenPos.y - displayStrategy.labelOffset;\n    \n    this.ctx.save();\n    \n    // 创建标签文本\n    const labelText = `${customType.name} #${keypoint.order}`;\n    this.ctx.font = `${displayStrategy.fontSize}px Arial`;\n    const textMetrics = this.ctx.measureText(labelText);\n    const textWidth = textMetrics.width;\n    \n    // 绘制标签背景\n    const padding = 4;\n    this.ctx.fillStyle = customType.color;\n    this.ctx.fillRect(\n      screenPos.x - textWidth / 2 - padding,\n      labelY - displayStrategy.fontSize / 2 - padding,\n      textWidth + padding * 2,\n      displayStrategy.fontSize + padding * 2\n    );\n    \n    // 绘制标签文本\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(labelText, screenPos.x, labelY);\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 🔄 NEW: 渲染自定义区域拖拽预览\n   */\n  renderCustomRegionPreview() {\n    if (!this.state.isCustomRegionDragging) return;\n    \n    const startScreenPos = this.state.customRegionStartPoint;\n    const currentScreenPos = this.state.customRegionCurrentPoint;\n    \n    if (!startScreenPos || !currentScreenPos) return;\n    \n    const customType = this.customAnnotationManager?.getCurrentCustomType();\n    if (!customType || customType.type !== 'region') return;\n    \n    const left = Math.min(startScreenPos.x, currentScreenPos.x);\n    const top = Math.min(startScreenPos.y, currentScreenPos.y);\n    const width = Math.abs(currentScreenPos.x - startScreenPos.x);\n    const height = Math.abs(currentScreenPos.y - startScreenPos.y);\n    \n    this.ctx.save();\n    this.ctx.globalAlpha = 0.5;\n    \n    // 绘制预览填充\n    this.ctx.fillStyle = customType.color;\n    this.ctx.fillRect(left, top, width, height);\n    \n    // 绘制预览边框\n    this.ctx.strokeStyle = customType.color;\n    this.ctx.lineWidth = 2;\n    this.ctx.setLineDash([5, 5]);\n    this.ctx.strokeRect(left, top, width, height);\n    \n    // 绘制尺寸信息\n    this.ctx.globalAlpha = 0.8;\n    this.ctx.fillStyle = '#000000';\n    this.ctx.font = '12px Arial';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    \n    const sizeText = `${Math.round(width)}x${Math.round(height)}`;\n    this.ctx.fillText(sizeText, left + width/2, top + height/2);\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 渲染单个标注点\n   */\n  renderSingleKeypoint(x, y, fillColor, label, direction, strategy, keypoint = null) {\n    // 绘制标注点圆圈\n    this.ctx.beginPath();\n    this.ctx.arc(x, y, strategy.radius, 0, 2 * Math.PI);\n    \n    // 填充\n    this.ctx.fillStyle = fillColor;\n    this.ctx.fill();\n    \n    // 边框\n    this.ctx.strokeStyle = this.options.keypointBorderColor;\n    this.ctx.lineWidth = strategy.borderWidth;\n    this.ctx.stroke();\n    \n    // 根据显示策略绘制标签\n    if (strategy.showInternalLabel) {\n      // 在标注点内部显示序号\n      this.ctx.fillStyle = this.options.keypointBorderColor;\n      this.ctx.font = `bold ${strategy.fontSize}px Inter, sans-serif`;\n      this.ctx.textAlign = 'center';\n      this.ctx.textBaseline = 'middle';\n      this.ctx.fillText(label.toString(), x, y);\n      \n      // 不再在标注点上方显示方向符号，改为使用虚线箭头\n      \n    } else if (strategy.showExternalLabel) {\n      // 在标注点外部显示标签\n      this.createExternalLabel(x, y, label, direction, fillColor, strategy);\n      \n    } else if (strategy.showMinimalMode) {\n      // 极小模式：只显示标注点，悬停时显示详细信息\n      if (keypoint && this.hoveredKeypoint === keypoint) {\n        this.createTooltip(x, y, label, direction, keypoint);\n      }\n    }\n  }\n\n  /**\n   * 渲染拖拽指示器\n   */\n  renderDragIndicator() {\n    if (!this.state.dragStartPoint || !this.state.currentDragPoint) return;\n    \n    const startX = this.state.dragStartPoint.x;\n    const startY = this.state.dragStartPoint.y;\n    const currentX = this.state.currentDragPoint.x;\n    const currentY = this.state.currentDragPoint.y;\n    \n    // 计算拖拽距离和方向\n    const deltaX = currentX - startX;\n    const distance = Math.sqrt(deltaX * deltaX + (currentY - startY) * (currentY - startY));\n    \n    if (distance >= this.options.directionThreshold) {\n      // 绘制拖拽线条\n      this.ctx.strokeStyle = deltaX < 0 ? this.options.keypointLeftColor : this.options.keypointRightColor;\n      this.ctx.lineWidth = 3;\n      this.ctx.setLineDash([5, 5]);\n      \n      this.ctx.beginPath();\n      this.ctx.moveTo(startX, startY);\n      this.ctx.lineTo(currentX, currentY);\n      this.ctx.stroke();\n      \n      // 重置线条样式\n      this.ctx.setLineDash([]);\n      \n      // 绘制方向文字\n      const midX = (startX + currentX) / 2;\n      const midY = (startY + currentY) / 2 - 20;\n      \n      this.ctx.fillStyle = deltaX < 0 ? this.options.keypointLeftColor : this.options.keypointRightColor;\n      this.ctx.font = 'bold 14px Inter, sans-serif';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText(deltaX < 0 ? '← Left' : 'Right →', midX, midY);\n    }\n  }\n\n  /**\n   * 图像坐标转屏幕坐标\n   */\n  imageToScreen(imageX, imageY) {\n    return {\n      x: imageX * this.state.scale + this.state.translateX,\n      y: imageY * this.state.scale + this.state.translateY\n    };\n  }\n\n  /**\n   * 屏幕坐标转图像坐标\n   */\n  screenToImage(screenX, screenY) {\n    return {\n      x: (screenX - this.state.translateX) / this.state.scale,\n      y: (screenY - this.state.translateY) / this.state.scale\n    };\n  }\n\n  /**\n   * 获取鼠标相对Canvas的位置\n   */\n  getMousePos(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    };\n  }\n\n  /**\n   * 🔧 NEW: Calculate the visible image bounds in screen coordinates\n   */\n  getVisibleImageBounds() {\n    if (!this.imageElement || !this.imageLoaded) {\n      return null;\n    }\n\n    // Image dimensions in screen space\n    const imageWidth = this.imageElement.width * this.state.scale;\n    const imageHeight = this.imageElement.height * this.state.scale;\n    \n    // Image position in screen space (top-left corner)\n    const imageLeft = this.state.translateX;\n    const imageTop = this.state.translateY;\n    \n    // Calculate visible bounds (intersection with canvas)\n    const visibleBounds = {\n      left: Math.max(0, imageLeft),\n      top: Math.max(0, imageTop),\n      right: Math.min(this.canvas.width, imageLeft + imageWidth),\n      bottom: Math.min(this.canvas.height, imageTop + imageHeight),\n      // Also store the full image bounds for reference\n      imageLeft,\n      imageTop,\n      imageRight: imageLeft + imageWidth,\n      imageBottom: imageTop + imageHeight\n    };\n    \n    // 🔧 DEBUG: Log bounds occasionally for troubleshooting\n    if (Math.random() < 0.001) { // 0.1% chance to log\n      console.log('[AnnotationTool] Image bounds debug:', {\n        imageSize: { width: this.imageElement.width, height: this.imageElement.height },\n        canvasSize: { width: this.canvas.width, height: this.canvas.height },\n        scale: this.state.scale,\n        translate: { x: this.state.translateX, y: this.state.translateY },\n        visibleBounds,\n        imageLoaded: this.imageLoaded\n      });\n    }\n    \n    return visibleBounds;\n  }\n\n  /**\n   * 🔧 NEW: Check if a screen point is within the visible image area\n   */\n  isPointInVisibleImage(screenX, screenY) {\n    const bounds = this.getVisibleImageBounds();\n    if (!bounds) {\n      return false;\n    }\n    \n    // Check if point is within the visible image area (intersection of image and canvas)\n    return screenX >= bounds.left && \n           screenX <= bounds.right && \n           screenY >= bounds.top && \n           screenY <= bounds.bottom;\n  }\n\n  /**\n   * 🔧 NEW: Check if image coordinates are valid and within image boundaries\n   */\n  isImageCoordinateValid(imageX, imageY) {\n    if (!this.imageElement || !this.imageLoaded) {\n      return false;\n    }\n    \n    return imageX >= 0 && \n           imageX <= this.imageElement.width && \n           imageY >= 0 && \n           imageY <= this.imageElement.height;\n  }\n\n  /**\n   * 🔧 NEW: Comprehensive bounds checking for annotation creation\n   */\n  canCreateAnnotationAt(screenX, screenY) {\n    // Check if image is loaded\n    if (!this.imageElement || !this.imageLoaded) {\n      console.warn('[AnnotationTool] Cannot create annotation: no image loaded');\n      return false;\n    }\n\n    // Check if point is within visible image area\n    if (!this.isPointInVisibleImage(screenX, screenY)) {\n      console.warn('[AnnotationTool] Cannot create annotation: position is outside visible image area');\n      return false;\n    }\n\n    // Double-check with image coordinates\n    const imagePos = this.screenToImage(screenX, screenY);\n    if (!this.isImageCoordinateValid(imagePos.x, imagePos.y)) {\n      console.warn('[AnnotationTool] Cannot create annotation: position is outside image boundaries');\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * 🔧 NEW: Silent bounds checking for cursor state (no console warnings)\n   */\n  canAnnotateAtSilent(screenX, screenY) {\n    // Check if image is loaded\n    if (!this.imageElement || !this.imageLoaded) {\n      return false;\n    }\n\n    // Check if point is within visible image area\n    if (!this.isPointInVisibleImage(screenX, screenY)) {\n      return false;\n    }\n\n    // Double-check with image coordinates\n    const imagePos = this.screenToImage(screenX, screenY);\n    if (!this.isImageCoordinateValid(imagePos.x, imagePos.y)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * 🔧 DEBUG: Manual bounds checking for troubleshooting\n   */\n  debugBoundsAt(screenX, screenY) {\n    console.log('[AnnotationTool] Debug bounds check at:', { screenX, screenY });\n    \n    if (!this.imageElement || !this.imageLoaded) {\n      console.log('❌ Image not loaded');\n      return false;\n    }\n    \n    const bounds = this.getVisibleImageBounds();\n    console.log('📐 Visible bounds:', bounds);\n    \n    const inVisibleArea = this.isPointInVisibleImage(screenX, screenY);\n    console.log('🎯 In visible area:', inVisibleArea);\n    \n    const imagePos = this.screenToImage(screenX, screenY);\n    const validCoords = this.isImageCoordinateValid(imagePos.x, imagePos.y);\n    console.log('📍 Image coords:', imagePos, 'Valid:', validCoords);\n    \n    const finalResult = this.canAnnotateAtSilent(screenX, screenY);\n    console.log('✅ Final result:', finalResult);\n    \n    return finalResult;\n  }\n\n  /**\n   * 处理鼠标按下\n   */\n  async handleMouseDown(event) {\n    console.log('[调试] handleMouseDown 被调用', {\n      button: event.button,\n      timestamp: Date.now(),\n      target: event.target.tagName,\n      isTrusted: event.isTrusted,\n      type: event.type,\n      eventPhase: event.eventPhase,\n      bubbles: event.bubbles,\n      cancelable: event.cancelable,\n      stackTrace: new Error().stack\n    });\n\n    const mousePos = this.getMousePos(event);\n\n    if (event.button === 0) { // 左键\n      if (event.shiftKey) {\n        // Shift + 左键：开始平移\n        this.state.isPanning = true;\n        this.state.lastPanPoint = mousePos;\n        this.canvas.style.cursor = 'grabbing';\n      } else {\n        // 检查是否点击了自定义标注\n        const clickedCustomAnnotation = this.getCustomAnnotationAt(mousePos);\n        \n        if (clickedCustomAnnotation) {\n          // 处理自定义标注点击\n          this.handleCustomAnnotationClick(clickedCustomAnnotation, mousePos);\n          \n          // 开始拖拽自定义标注\n          this.startCustomAnnotationDrag(clickedCustomAnnotation, mousePos);\n          return;\n        }\n        \n        // 检查是否点击了标注点\n        const clickedKeypoint = this.getKeypointAt(mousePos);\n        \n        if (clickedKeypoint) {\n          console.log('[调试] 点击了标注点', {\n            clickedKeypoint: clickedKeypoint.order,\n            isDirectionSelectionMode: this.state.isDirectionSelectionMode,\n            selectedKeypoint: this.state.selectedKeypoint?.order,\n            isSameKeypoint: this.state.selectedKeypoint === clickedKeypoint\n          });\n\n          // 如果处于方向选择模式且点击的是已选中的标注点，处理方向选择\n          if (this.state.isDirectionSelectionMode && this.state.selectedKeypoint === clickedKeypoint) {\n            console.log('[调试] 处理方向选择');\n            try {\n              await this.handleDirectionSelection(mousePos);\n            } catch (error) {\n              console.error('[方向选择] 处理方向选择失败:', error);\n            }\n            return;\n          }\n\n          // 如果不是在处理方向选择，则开始拖拽标注点\n          // 但是首先检查这是否是一个点击（而不是拖拽）\n          this.draggedKeypoint = clickedKeypoint;\n          this.state.dragStartPoint = mousePos;\n          this.state.mouseDownTime = Date.now(); // 记录按下时间\n          this.state.wasDraggedDuringSession = false; // 重置拖拽标记\n          this.canvas.style.cursor = 'grabbing';\n\n          // 重要：点击了标注点就直接返回，不要继续执行后面的逻辑\n          return;\n        } else {\n          // 如果处于方向选择模式，处理方向选择\n          if (this.state.isDirectionSelectionMode) {\n            // 无论是自动模式还是手动模式，点击空白区域都应该设置方向\n            console.log('[调试] 方向选择模式下点击，处理方向选择');\n            try {\n              await this.handleDirectionSelection(mousePos);\n            } catch (error) {\n              console.error('[方向选择] 处理方向选择失败:', error);\n            }\n            return;\n          }\n\n          // 🔧 FIX: Check if image is loaded before allowing annotation creation\n          if (!this.imageElement || !this.imageLoaded) {\n            console.warn('[AnnotationTool] Cannot create annotation: no image loaded');\n            if (window.PlantAnnotationTool?.showError) {\n              window.PlantAnnotationTool.showError('No Image Loaded', 'Please select and load an image before creating annotations.');\n            }\n            return;\n          }\n\n          // 检查是否处于自定义标注模式\n          if (this.customAnnotationManager && this.customAnnotationManager.isInCustomMode()) {\n            const customType = this.customAnnotationManager.getCurrentCustomType();\n            if (!customType) {\n              console.warn('No custom type selected');\n              return;\n            }\n            if (customType.type === 'region') {\n              // 区域类型：走自定义区域流程\n              this.handleCustomAnnotationMode(mousePos);\n              return;\n            }\n            if (customType.type === 'point') {\n              // 点类型：允许拖拽设置方向或简单点击后进入方向选择\n              this.state.blankAreaClickStart = mousePos;\n              this.state.mouseDownTime = Date.now();\n              this.state.wasDraggedDuringSession = false;\n              return;\n            }\n          }\n\n          // 🚫 禁止在未选择 Annotation Type 时创建标注\n          console.warn('[AnnotationTool] Annotation disabled: please select an Annotation Type to start annotating.');\n          if (window.PlantAnnotationTool?.showError) {\n            window.PlantAnnotationTool.showError('Annotation Disabled', 'Please open Annotation Type Setting and select a type before annotating.');\n          }\n          return;\n        }\n      }\n    } else if (event.button === 2) { // 右键\n      if (this.state.isAutoDirectionMode) {\n        // 右键暂停自动化方向升级模式\n        this.pauseAutoDirectionMode();\n      } else if (this.state.isDirectionSelectionMode) {\n        // 右键取消方向选择\n        this.cancelDirectionSelection(true); // 强制退出\n      }\n    } else if (event.button === 1) { // 🔧 NEW: 中键 - 方向数量选择\n      this.handleMiddleMouseButton(mousePos);\n    }\n  }\n\n  /**\n   * 处理鼠标移动\n   */\n  handleMouseMove(event) {\n    const mousePos = this.getMousePos(event);\n    \n    if (this.state.isPanning && this.state.lastPanPoint) {\n      // 平移图像\n      const deltaX = mousePos.x - this.state.lastPanPoint.x;\n      const deltaY = mousePos.y - this.state.lastPanPoint.y;\n      \n      this.state.translateX += deltaX;\n      this.state.translateY += deltaY;\n      \n      this.state.lastPanPoint = mousePos;\n      this.render();\n      \n    } else if (this.draggedKeypoint) {\n      // 拖拽标注点\n      const imagePos = this.screenToImage(mousePos.x, mousePos.y);\n      \n      // 🔧 FIX: Constrain dragged keypoint to stay within image boundaries\n      if (this.isImageCoordinateValid(imagePos.x, imagePos.y)) {\n        this.draggedKeypoint.x = imagePos.x;\n        this.draggedKeypoint.y = imagePos.y;\n        \n        // 标记已经进行了拖拽\n        this.state.wasDraggedDuringSession = true;\n        \n        this.render();\n        \n        // 通知预览管理器显示被拖动点对应的预览\n        this.notifyDraggedKeypointPreview(this.draggedKeypoint);\n      }\n      // If the position is invalid, don't update the keypoint position (ignore the movement)\n      \n    } else if (this.customAnnotationDragState.isDragging) {\n      // 拖拽自定义标注\n      this.updateCustomAnnotationDrag(mousePos);\n\n    } else if (this.state.blankAreaClickStart) {\n      // 检查是否开始了拖拽（从空白区域点击开始）\n      const distance = Math.sqrt(\n        Math.pow(mousePos.x - this.state.blankAreaClickStart.x, 2) +\n        Math.pow(mousePos.y - this.state.blankAreaClickStart.y, 2)\n      );\n\n      if (distance >= this.options.directionThreshold) {\n        // 距离足够，标记为拖拽状态\n        this.state.wasDraggedDuringSession = true;\n\n        // 自定义点类型也支持方向拖拽\n        this.startDirectionAnnotation(this.state.blankAreaClickStart);\n        this.state.blankAreaClickStart = null; // 清除空白点击状态\n        this.updateDirectionDragging(mousePos);\n      }\n\n    } else if (this.state.isDirectionDragging) {\n      // 方向拖拽处理\n      this.updateDirectionDragging(mousePos);\n\n    } else if (this.state.isCustomRegionDragging) {\n      // 自定义区域拖拽处理\n      this.updateCustomRegionDrag(mousePos);\n\n    } else if (this.state.isDirectionSelectionMode) {\n      // 方向选择模式下的鼠标移动\n      this.state.directionSelectionPoint = mousePos;\n      \n      // 🔧 FIX: Proper cursor management for direction selection mode\n      let directionCursor = 'crosshair'; // Default for direction selection\n      \n      // Check if we're hovering over the selected keypoint for better UX\n      if (this.state.selectedKeypoint) {\n        const keypointScreen = this.imageToScreen(\n          this.state.selectedKeypoint.x,\n          this.state.selectedKeypoint.y\n        );\n        const distance = Math.sqrt(\n          Math.pow(mousePos.x - keypointScreen.x, 2) +\n          Math.pow(mousePos.y - keypointScreen.y, 2)\n        );\n        \n        // If hovering over the selected keypoint, show pointer cursor\n        if (distance <= (this.options.baseKeypointRadius * 2)) {\n          directionCursor = 'pointer';\n        }\n      }\n      \n      // Update cursor for direction selection mode\n      if (this.canvas.style.cursor !== directionCursor) {\n        this.canvas.style.cursor = directionCursor;\n      }\n      \n      this.render();\n      \n    } else {\n      // 检查是否悬停在自定义标注上\n      const hoveredCustomAnnotation = this.getCustomAnnotationAt(mousePos);\n      \n      if (hoveredCustomAnnotation) {\n        // 悬停在自定义标注上\n        this.canvas.style.cursor = 'pointer';\n        \n        // 更新悬停状态\n        if (this.customAnnotationRenderer) {\n          this.customAnnotationRenderer.setHoveredAnnotation(hoveredCustomAnnotation);\n        }\n        \n        this.render();\n        return;\n      } else {\n        // 清除悬停状态\n        if (this.customAnnotationRenderer) {\n          this.customAnnotationRenderer.setHoveredAnnotation(null);\n        }\n      }\n      \n      // 检查悬停的标注点\n      const hoveredKeypoint = this.getKeypointAt(mousePos);\n      \n      // 🔧 FIX: Always check cursor state for better responsiveness\n      let newCursor = 'crosshair'; // Default cursor\n      \n      // 🔧 FIX: Special handling for auto direction mode\n      if (this.state.isAutoDirectionMode) {\n        // In auto direction mode, provide different cursor feedback\n        if (hoveredKeypoint) {\n          newCursor = 'pointer'; // Can click keypoints in auto mode\n        } else {\n          newCursor = 'crosshair'; // Allow normal interaction in auto mode\n        }\n      } else if (this.customAnnotationManager && this.customAnnotationManager.isInCustomMode()) {\n        // 🔧 FIX: Custom annotation mode - maintain crosshair cursor for annotation purposes\n        if (hoveredKeypoint) {\n          newCursor = 'pointer'; // Can still interact with existing keypoints\n        } else {\n          // Check if mouse is within valid annotation area\n          const canAnnotate = this.canAnnotateAtSilent(mousePos.x, mousePos.y);\n          newCursor = canAnnotate ? 'crosshair' : 'not-allowed';\n        }\n      } else {\n        // Normal mode cursor logic\n        if (hoveredKeypoint) {\n          newCursor = 'pointer';\n        } else {\n          // Check if mouse is within valid annotation area\n          const canAnnotate = this.canAnnotateAtSilent(mousePos.x, mousePos.y);\n          newCursor = canAnnotate ? 'crosshair' : 'not-allowed';\n        }\n      }\n      \n      // Update cursor if it changed\n      if (this.canvas.style.cursor !== newCursor) {\n        this.canvas.style.cursor = newCursor;\n      }\n      \n      // Update hovered keypoint and render if it changed\n      if (hoveredKeypoint !== this.hoveredKeypoint) {\n        this.hoveredKeypoint = hoveredKeypoint;\n        this.render();\n      }\n    }\n  }\n\n  /**\n   * 处理鼠标抬起\n   */\n  handleMouseUp(event) {\n    const mousePos = this.getMousePos(event);\n    \n    if (this.state.isPanning) {\n      this.state.isPanning = false;\n      this.state.lastPanPoint = null;\n      this.canvas.style.cursor = 'crosshair';\n    }\n    \n    // 检查是否是简单点击（没有拖拽）\n    if (this.draggedKeypoint) {\n      // 检查是否有实际移动\n      const startPos = this.state.dragStartPoint || mousePos;\n      const distance = Math.sqrt(\n        Math.pow(mousePos.x - startPos.x, 2) +\n        Math.pow(mousePos.y - startPos.y, 2)\n      );\n\n      // 检查是否在短时间内进行了拖拽操作\n      const currentTime = Date.now();\n      const timeSinceMouseDown = currentTime - (this.state.mouseDownTime || currentTime);\n      const wasDragged = this.state.wasDraggedDuringSession || false;\n\n      // 更严格的点击判断：距离小且时间短且没有拖拽过\n      if (distance < 8 && timeSinceMouseDown < 200 && !wasDragged) {\n        // 这是一个快速点击，不是拖拽\n        this.handleKeypointClick(this.draggedKeypoint);\n      } else {\n        // 这是拖拽，保存状态\n        this.saveState();\n        this.autoSaveCurrentImage();\n        \n        // 🔄 NEW: 实时同步 - 标注点移动\n        this.triggerRealTimeSync('MOVE_KEYPOINT', this.draggedKeypoint, this.state.dragStartPoint);\n      }\n\n      // 重置拖拽状态\n      this.draggedKeypoint = null;\n      this.state.wasDraggedDuringSession = false;\n      this.state.mouseDownTime = null;\n      this.canvas.style.cursor = 'crosshair';\n      this.restoreNormalPreview();\n    }\n    \n    // 检查是否是空白区域的简单点击（进入方向选择或创建点）\n    if (this.state.blankAreaClickStart) {\n      const distance = Math.sqrt(\n        Math.pow(mousePos.x - this.state.blankAreaClickStart.x, 2) +\n        Math.pow(mousePos.y - this.state.blankAreaClickStart.y, 2)\n      );\n\n      const currentTime = Date.now();\n      const timeSinceMouseDown = currentTime - (this.state.mouseDownTime || currentTime);\n      const wasDragged = this.state.wasDraggedDuringSession || false;\n\n      // 判断是否是简单点击：距离小、时间短、没有拖拽\n      if (distance < 8 && timeSinceMouseDown < 300 && !wasDragged) {\n        const isCustomPointMode = this.customAnnotationManager?.isInCustomMode() && this.customAnnotationManager.getCurrentCustomType()?.type === 'point';\n        if (isCustomPointMode) {\n          // 自定义点类型：创建无方向点，不自动进入方向选择\n          const imagePos = this.screenToImage(this.state.blankAreaClickStart.x, this.state.blankAreaClickStart.y);\n          const currentType = this.customAnnotationManager.getCurrentCustomType();\n          // 创建时不写入 direction 字段\n          const kp = this.addKeypointWithDirection(imagePos.x, imagePos.y, undefined, currentType.id);\n          if (kp) {\n            // 确保移除可能被默认赋值的 direction\n            delete kp.direction;\n            delete kp.directionType;\n            this.render();\n            this.autoSaveCurrentImage();\n          }\n        } else {\n          // 未选择自定义点类型：保留兼容路径（此前在mouseDown已阻止未选类型）\n          this.createNoDirectionKeypoint(this.state.blankAreaClickStart);\n        }\n      }\n\n      // 清除空白点击状态\n      this.state.blankAreaClickStart = null;\n      this.state.mouseDownTime = null;\n      this.state.wasDraggedDuringSession = false;\n    }\n\n    \n    // 完成自定义标注拖拽\n    if (this.customAnnotationDragState.isDragging) {\n      this.finishCustomAnnotationDrag();\n    }\n    \n    if (this.state.isDirectionDragging) {\n      // 完成方向标注\n      this.finishDirectionAnnotation();\n    }\n    \n    if (this.state.isCustomRegionDragging) {\n      // 完成自定义区域拖拽\n      this.finishCustomRegionDrag();\n    }\n  }\n\n  /**\n   * 创建无方向标注点\n   */\n  createNoDirectionKeypoint(mousePos) {\n    // 🚫 不允许在未选择 Annotation Type 的情况下创建“默认/regular”关键点\n    if (!this.customAnnotationManager || !this.customAnnotationManager.isInCustomMode()) {\n      if (window.PlantAnnotationTool?.showError) {\n        window.PlantAnnotationTool.showError('Annotation Disabled', 'Please select an Annotation Type before creating keypoints.');\n      }\n      return;\n    }\n\n    // 🔧 FIX: Comprehensive bounds checking for annotation creation\n    if (!this.canCreateAnnotationAt(mousePos.x, mousePos.y)) {\n      if (window.PlantAnnotationTool?.showError) {\n        window.PlantAnnotationTool.showError('Invalid Position', 'Annotations can only be placed within the image area. Please click directly on the image.');\n      }\n      return;\n    }\n\n    const imagePos = this.screenToImage(mousePos.x, mousePos.y);\n\n    // 在“类型模式”下，空白点击应该创建当前选中类型的标注\n    const currentType = this.customAnnotationManager.getCurrentCustomType();\n    if (!currentType) {\n      if (window.PlantAnnotationTool?.showError) {\n        window.PlantAnnotationTool.showError('No Type Selected', 'Please select an Annotation Type before annotating.');\n      }\n      return;\n    }\n\n    if (currentType.type === 'region') {\n      // 如果是矩形类型，启动统一的矩形拖拽流程\n      this.startUnifiedCustomRegionDrag(mousePos, currentType.id);\n      return;\n    }\n\n    // Keypoint 类型：使用类型默认角度\n    const direction = typeof currentType.metadata?.defaultAngle === 'number' ? currentType.metadata.defaultAngle : null;\n    const keypoint = this.addCustomPointAnnotation(imagePos.x, imagePos.y, currentType.id);\n    // addCustomPointAnnotation 内部已处理 defaultAngle 应用与保存/渲染/同步\n    return keypoint;\n  }\n\n  /**\n   * 选择关键点\n   */\n  selectKeypoint(keypoint) {\n    console.log('[调试] selectKeypoint 被调用', {\n      keypoint: keypoint.order,\n      currentDirection: keypoint.direction,\n      directionType: keypoint.directionType\n    });\n\n    // 🔧 BUG FIX: 确保标注点具有多方向支持\n    this.ensureMultiDirectionSupport(keypoint);\n\n    this.state.selectedKeypoint = keypoint;\n    this.state.isDirectionSelectionMode = true;\n    this.state.directionSelectionPoint = null;\n\n    console.log('[调试] 方向选择模式状态', {\n      isDirectionSelectionMode: this.state.isDirectionSelectionMode,\n      selectedKeypoint: this.state.selectedKeypoint?.order,\n      isAutoDirectionMode: this.state.isAutoDirectionMode\n    });\n\n    // 🔧 FIX: Set appropriate cursor for direction selection mode\n    this.canvas.style.cursor = 'crosshair';\n\n    // 通知预览管理器显示这个点的预览\n    this.notifySelectedKeypointPreview(keypoint);\n\n    this.render();\n    console.log(`Selected keypoint #${keypoint.order} for direction selection`);\n  }\n\n  /**\n   * 处理关键点点击\n   */\n  handleKeypointClick(keypoint) {\n    console.log('[调试] handleKeypointClick 被调用', {\n      keypoint: keypoint.order,\n      isAutoDirectionMode: this.state.isAutoDirectionMode,\n      isDirectionSelectionMode: this.state.isDirectionSelectionMode,\n      currentSelectedKeypoint: this.state.selectedKeypoint?.order\n    });\n\n    if (this.state.isAutoDirectionMode) {\n      // 自动化模式下，选择当前关键点\n      this.selectKeypoint(keypoint);\n    } else {\n      // 普通模式下，总是选择关键点进入方向选择模式\n      // 无论是否已经处于方向选择模式\n      this.selectKeypoint(keypoint);\n    }\n  }\n\n  /**\n   * 处理方向选择\n   */\n  async handleDirectionSelection(mousePos) {\n    console.log('[调试] handleDirectionSelection 被调用', {\n      selectedKeypoint: this.state.selectedKeypoint,\n      mousePos,\n      isAutoDirectionMode: this.state.isAutoDirectionMode\n    });\n\n    if (!this.state.selectedKeypoint) {\n      console.log('[调试] 没有选中的标注点，退出方向选择');\n      return;\n    }\n\n    const keypointScreen = this.imageToScreen(\n      this.state.selectedKeypoint.x,\n      this.state.selectedKeypoint.y\n    );\n\n    // 计算方向角度\n    const deltaX = mousePos.x - keypointScreen.x;\n    const deltaY = mousePos.y - keypointScreen.y;\n    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\n\n    // 标准化角度到 0-360 度\n    const normalizedAngle = (angle + 360) % 360;\n\n    // 🔧 NEW: 记录点击坐标\n    const imagePos = this.screenToImage(mousePos.x, mousePos.y);\n    const clickData = {\n      x: imagePos.x,\n      y: imagePos.y,\n      screenX: mousePos.x,\n      screenY: mousePos.y,\n      timestamp: Date.now()\n    };\n\n    console.log('[调试] 计算的角度信息', {\n      deltaX, deltaY, angle, normalizedAngle,\n      clickData,\n      keypointBefore: {...this.state.selectedKeypoint}\n    });\n\n    // 🔧 NEW: 支持多方向设置\n    if (this.state.selectedKeypoint.maxDirections > 1) {\n      // 多方向模式\n      const direction = { \n        angle: normalizedAngle, \n        type: 'angle',\n        clickPosition: clickData  // 🔧 NEW: 记录点击位置\n      };\n      \n      if (this.addDirectionToKeypoint(this.state.selectedKeypoint, direction)) {\n        // 🔧 FIX: Only increment counter after successful addition\n        this.state.directionsSet++;\n        \n        console.log(`[多方向] 设置方向 ${this.state.directionsSet}/${this.state.selectedKeypoint.maxDirections}: ${normalizedAngle.toFixed(1)}°`);\n        \n        // 更新进度显示\n        this.showMultiDirectionProgress();\n        \n        // 🔄 NEW: 实时同步 - 多方向编辑\n        this.triggerRealTimeSync('EDIT_DIRECTION', this.state.selectedKeypoint);\n        \n        // 🔧 FIX: Check actual directions count, not counter\n        if (this.state.selectedKeypoint.directions.length >= this.state.selectedKeypoint.maxDirections) {\n          console.log('[多方向] 所有方向设置完成');\n          this.finishMultiDirectionSetting();\n        }\n      }\n    } else {\n      // 单方向模式（原有逻辑）\n      // 更新关键点方向\n      const oldDirection = this.state.selectedKeypoint.direction;\n      this.state.selectedKeypoint.direction = normalizedAngle;\n      this.state.selectedKeypoint.directionType = 'angle'; // 标记为角度类型\n      \n      // 🔧 NEW: 记录点击坐标\n      this.state.selectedKeypoint.directionClick = clickData;\n      \n      // 同时更新directions数组以保持一致性\n      this.state.selectedKeypoint.directions = [{ \n        angle: normalizedAngle, \n        type: 'angle',\n        clickPosition: clickData  // 🔧 NEW: 记录点击位置\n      }];\n\n      console.log('[调试] 方向更新', {\n        keypointId: this.state.selectedKeypoint.id,\n        order: this.state.selectedKeypoint.order,\n        oldDirection,\n        newDirection: normalizedAngle,\n        clickData,\n        keypointAfter: {...this.state.selectedKeypoint}\n      });\n      \n      // 🔄 NEW: 实时同步 - 单方向编辑\n      this.triggerRealTimeSync('EDIT_DIRECTION', this.state.selectedKeypoint);\n      \n      // 🔧 ENHANCED: Handle both longitudinal and cross-sectional auto direction modes\n      if (this.state.isAutoDirectionMode) {\n        console.log('[调试] 自动模式，处理下一步:', this.autoDirectionMode);\n        \n        if (this.autoDirectionMode === 'cross-sectional') {\n          // Cross-sectional mode: process current point and advance\n          await this.handleCrossSectionalDirectionSet(normalizedAngle);\n        } else {\n          // Longitudinal mode: proceed to next keypoint in current image\n          this.selectNextAutoDirectionKeypoint();\n        }\n      } else {\n        console.log('[调试] 非自动模式，取消方向选择');\n        this.cancelDirectionSelection(true); // 强制退出\n\n        // 🔧 FIX: Only move to expected position if auto-move is enabled AND we just created a new point\n        // Don't auto-move when just setting direction on existing points\n        if (this.state.autoMoveToExpectedPosition && this.justCreatedNewPoint) {\n          console.log('[自动移动] 检测到新建标注点，移动到下一个预期位置');\n          this.moveToNextExpectedPosition();\n          this.justCreatedNewPoint = false; // Reset flag\n        } else {\n          console.log('[自动移动] 跳过移动 - 仅为现有标注点设置方向或auto-move已关闭');\n        }\n      }\n    }\n  }\n\n  /**\n   * 🔧 NEW: Handle Cross-Sectional Direction Set\n   * @param {number} direction - Direction angle in degrees\n   */\n  async handleCrossSectionalDirectionSet(direction) {\n    if (!this.crossSectionalState) {\n      console.error('[Cross-Sectional] No cross-sectional state available');\n      return;\n    }\n    \n    try {\n      console.log(`[Cross-Sectional] Setting direction ${direction.toFixed(1)}° for current point`);\n      \n      // 🔧 FIX: Check if cross-sectional state still exists\n      if (!this.crossSectionalState) {\n        console.warn('[Cross-Sectional] State is null, cannot process direction');\n        return;\n      }\n      \n      // Process current cross-sectional point with the direction\n      await this.processCurrentCrossSectionalPoint(direction);\n      \n      // Save state\n      this.saveState();\n      this.autoSaveCurrentImage();\n      \n      // 🔧 FIX: Check state again after processing\n      if (!this.crossSectionalState) {\n        console.warn('[Cross-Sectional] State became null during processing');\n        return;\n      }\n      \n      // Check if all annotations are processed\n      if (this.crossSectionalState.processedCount >= this.crossSectionalState.totalCount) {\n        console.log('[Cross-Sectional] All annotations processed, completing mode');\n        this.completeCrossSectionalMode();\n      } else {\n        // Continue with next annotation\n        console.log('[Cross-Sectional] Continuing to next annotation');\n        // The advance method will be called from processCurrentCrossSectionalPoint\n      }\n      \n    } catch (error) {\n      console.error('[Cross-Sectional] Failed to handle direction set:', error);\n      \n      // Show error to user but don't break the mode\n      if (window.PlantAnnotationTool?.showError) {\n        window.PlantAnnotationTool.showError('Cross-Sectional Error', `Failed to process direction: ${error.message}`);\n      }\n      \n      // Try to continue anyway by advancing to next point\n      try {\n        console.log('[Cross-Sectional] Attempting to continue despite error...');\n        // 🔧 FIX: Check if state exists before accessing\n        if (this.crossSectionalState) {\n          this.crossSectionalState.processedCount++;\n          await this.advanceCrossSectionalProgress();\n        } else {\n          console.warn('[Cross-Sectional] Cannot continue - state is null');\n        }\n      } catch (advanceError) {\n        console.error('[Cross-Sectional] Failed to advance after error:', advanceError);\n        // Exit cross-sectional mode if we can't continue\n        if (this.crossSectionalState) {\n          this.completeCrossSectionalMode();\n        } else {\n          console.warn('[Cross-Sectional] Cannot complete - state is null, forcing exit');\n          this.exitAutoDirectionMode();\n        }\n      }\n    }\n  }\n\n  /**\n   * 取消方向选择\n   */\n  cancelDirectionSelection(forceExit = false) {\n    console.log('[调试] cancelDirectionSelection 被调用', {\n      wasInDirectionMode: this.state.isDirectionSelectionMode,\n      selectedKeypoint: this.state.selectedKeypoint?.order,\n      isAutoMode: this.state.isAutoDirectionMode,\n      forceExit\n    });\n\n    this.state.selectedKeypoint = null;\n    this.state.isDirectionSelectionMode = false;\n    this.state.directionSelectionPoint = null;\n\n    // 只有在强制退出或非自动模式时才退出自动模式\n    if (this.state.isAutoDirectionMode && forceExit) {\n      console.log('[调试] 强制退出自动模式');\n      this.exitAutoDirectionMode();\n    } else if (this.state.isAutoDirectionMode) {\n      console.log('[调试] 自动模式中取消方向选择，但保持自动模式');\n      // 在自动模式下，只是清除当前选择，不退出自动模式\n    }\n\n    // 🔧 FIX: Reset cursor to appropriate state when exiting direction selection\n    if (this.state.isAutoDirectionMode) {\n      // In auto mode, maintain crosshair cursor\n      this.canvas.style.cursor = 'crosshair';\n    } else {\n      // In normal mode, reset to default crosshair\n      this.canvas.style.cursor = 'crosshair';\n    }\n\n    this.restoreNormalPreview();\n    this.render();\n    console.log('Direction selection cancelled');\n  }\n\n  /**\n   * 🔧 ENHANCED: 开始自动化方向选择模式（支持纵向和横向模式）\n   */\n  async startAutoDirectionMode() {\n    console.log('[调试] startAutoDirectionMode 被调用，当前模式:', this.autoDirectionMode);\n\n    // 先清理之前的状态\n    if (this.state.isDirectionSelectionMode || this.state.isAutoDirectionMode) {\n      console.log('[调试] 清理之前的方向选择状态');\n      this.state.selectedKeypoint = null;\n      this.state.isDirectionSelectionMode = false;\n      this.state.directionSelectionPoint = null;\n      this.state.isAutoDirectionMode = false;\n    }\n\n    // Clear any existing cross-sectional state\n    this.crossSectionalState = null;\n    this.crossSectionalMap.clear();\n\n    try {\n      // 如果当前选择的类型存在且不支持方向，直接提示并返回\n      if (this.customAnnotationManager) {\n        const t = this.customAnnotationManager.getCurrentCustomType?.();\n        if (t && t.metadata && t.metadata.isDirectional === false) {\n          if (window.PlantAnnotationTool?.showError) {\n            window.PlantAnnotationTool.showError('Auto Direction Disabled', '当前选择的类型未启用方向功能');\n          }\n          return false;\n        }\n      }\n      if (this.autoDirectionMode === 'cross-sectional') {\n        // 🔧 NEW: Cross-Sectional Mode - Process same order across all images\n        const ok = await this.startCrossSectionalMode();\n        if (!ok) {\n          this.exitAutoDirectionMode();\n          this.resetAutoDirectionButton();\n        }\n        return ok;\n      } else {\n        // 🔧 EXISTING: Longitudinal Mode - Complete all points in one image first\n        const ok = this.startLongitudinalMode();\n        if (!ok) {\n          this.exitAutoDirectionMode();\n          this.resetAutoDirectionButton();\n        }\n        return ok;\n      }\n    } catch (error) {\n      console.error('[Auto Direction] Failed to start auto direction mode:', error);\n      if (window.PlantAnnotationTool?.showError) {\n        window.PlantAnnotationTool.showError('Auto Direction Error', error.message);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * 🔧 NEW: Start Cross-Sectional Mode\n   */\n  async startCrossSectionalMode() {\n    console.log('[Cross-Sectional] Starting cross-sectional mode');\n    \n    try {\n      // Build cross-sectional map for all images\n      this.crossSectionalMap = await this.buildCrossSectionalMap();\n      \n      if (this.crossSectionalMap.size === 0) {\n        console.log('[Cross-Sectional] No directionless annotations found across all images');\n        if (window.PlantAnnotationTool?.showInfo) {\n          window.PlantAnnotationTool.showInfo('No Work Needed', 'No directionless annotations found across all images in current view angle.');\n        }\n        return false;\n      }\n      \n      // Initialize cross-sectional state\n      this.initializeCrossSectionalState();\n      \n      // Set auto direction mode flag\n      this.state.isAutoDirectionMode = true;\n      \n      // Update UI to reflect cross-sectional mode\n      this.updateAutoDirectionModeUI();\n      \n      // Start processing with first annotation\n      const currentPoint = this.getCurrentCrossSectionalPoint();\n      if (currentPoint) {\n        console.log(`[Cross-Sectional] Starting with annotation #${currentPoint.annotation.order} in ${currentPoint.imageName}`);\n        \n        // Switch to the first image with annotations to process\n        await this.switchToImageForCrossSectional(currentPoint.imageId);\n        \n        // Show cross-sectional progress UI\n        this.updateCrossSectionalProgressUI();\n        \n        if (window.PlantAnnotationTool?.showInfo) {\n          window.PlantAnnotationTool.showInfo('Cross-Sectional Mode', \n            `Processing ${this.crossSectionalState.totalCount} annotations across ${this.crossSectionalState.availableOrders.length} order numbers. Click to set directions.`);\n        }\n        \n        return true;\n      } else {\n        throw new Error('No annotations to process in cross-sectional mode');\n      }\n      \n    } catch (error) {\n      console.error('[Cross-Sectional] Failed to start cross-sectional mode:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 EXISTING: Start Longitudinal Mode (original behavior)\n   */\n  startLongitudinalMode() {\n    console.log('[Longitudinal] Starting longitudinal mode');\n    \n    // 找到所有需要设置方向的标注点（传统left/right标注点 + 无方向标注点）\n    const needDirectionKeypoints = this.keypoints.filter(kp => {\n      // 传统left/right标注点\n      const isLegacy = (kp.direction === 'left' || kp.direction === 'right') &&\n                      kp.directionType !== 'angle' &&\n                      typeof kp.direction !== 'number';\n\n      // 无方向标注点\n      const isNoDirection = kp.direction === null || kp.direction === undefined;\n\n      return isLegacy || isNoDirection;\n    });\n\n    console.log('[Longitudinal] 找到需要设置方向的标注点', needDirectionKeypoints.map(kp => ({\n      order: kp.order,\n      direction: kp.direction,\n      directionType: kp.directionType,\n      type: kp.direction === null ? '无方向' : '传统方向'\n    })));\n\n    if (needDirectionKeypoints.length === 0) {\n      console.log('[Longitudinal] 没有需要设置方向的标注点');\n      // 显示提示信息\n      if (window.PlantAnnotationTool?.showInfo) {\n        window.PlantAnnotationTool.showInfo('无需设置', '当前图像没有需要设置方向的标注点');\n      }\n      // 确保按钮和状态复位\n      this.exitAutoDirectionMode();\n      this.resetAutoDirectionButton();\n      return false;\n    }\n\n    // 按序号排序\n    needDirectionKeypoints.sort((a, b) => (a.order || 0) - (b.order || 0));\n\n    this.state.isAutoDirectionMode = true;\n    this.state.autoDirectionKeypoints = needDirectionKeypoints;\n    this.state.autoDirectionIndex = 0;\n\n    console.log('[Longitudinal] 设置自动模式状态', {\n      isAutoDirectionMode: this.state.isAutoDirectionMode,\n      autoDirectionKeypoints: this.state.autoDirectionKeypoints.length,\n      autoDirectionIndex: this.state.autoDirectionIndex\n    });\n\n    // Update UI to reflect longitudinal mode\n    this.updateAutoDirectionModeUI();\n\n    // 选择第一个关键点并自动放大\n    this.selectKeypointWithZoom(needDirectionKeypoints[0]);\n\n    console.log(`[Longitudinal] 开始自动化方向设置模式，共 ${needDirectionKeypoints.length} 个标注点需要设置方向`);\n\n    // 显示提示信息\n    if (window.PlantAnnotationTool?.showInfo) {\n      window.PlantAnnotationTool.showInfo('Longitudinal Mode', \n        `Setting directions for ${needDirectionKeypoints.length} annotations in current image. Move mouse to select direction, click to confirm, right-click to pause.`);\n    }\n\n    return true;\n  }\n\n  /**\n   * 选择关键点并自动放大到该位置\n   */\n  selectKeypointWithZoom(keypoint) {\n    console.log('[调试] selectKeypointWithZoom 开始', {\n      keypoint: keypoint.order,\n      isAutoMode: this.state.isAutoDirectionMode,\n      isDirectionMode: this.state.isDirectionSelectionMode\n    });\n\n    // 先选择关键点\n    this.selectKeypoint(keypoint);\n\n    console.log('[调试] selectKeypoint 完成后状态', {\n      isAutoMode: this.state.isAutoDirectionMode,\n      isDirectionMode: this.state.isDirectionSelectionMode,\n      selectedKeypoint: this.state.selectedKeypoint?.order\n    });\n\n    // 自动放大到关键点位置\n    const defaultAutoScale = 2.5; // 默认的自动化放大倍数\n    const currentScale = this.state.scale;\n\n    // 如果当前缩放大于默认值，保持当前缩放；否则使用默认值\n    const targetScale = Math.max(currentScale, defaultAutoScale);\n    const newScale = Math.min(targetScale, this.options.maxZoom);\n\n    // 计算画布中心\n    const centerX = this.canvas.width / 2;\n    const centerY = this.canvas.height / 2;\n\n    // 计算标注点在新缩放下的位置，使其居中\n    this.state.scale = newScale;\n    this.state.translateX = centerX - (keypoint.x * newScale);\n    this.state.translateY = centerY - (keypoint.y * newScale);\n\n    // 确保图像不会超出边界\n    this.constrainView();\n\n    this.updateZoomInfo();\n    this.render();\n\n    const scaleAction = currentScale >= defaultAutoScale ? '保持当前缩放' : '使用默认缩放';\n    console.log(`自动居中到标注点 #${keypoint.order}，缩放: ${newScale.toFixed(1)}x (${scaleAction})`);\n\n    // 添加视觉提示\n    this.showKeypointFocusHint(keypoint);\n\n    console.log('[调试] selectKeypointWithZoom 完成后状态', {\n      isAutoMode: this.state.isAutoDirectionMode,\n      isDirectionMode: this.state.isDirectionSelectionMode,\n      selectedKeypoint: this.state.selectedKeypoint?.order\n    });\n  }\n\n  /**\n   * 显示标注点聚焦提示\n   */\n  showKeypointFocusHint(keypoint) {\n    // 创建一个临时的聚焦效果\n    const originalRender = this.render.bind(this);\n    let pulseCount = 0;\n    const maxPulses = 3;\n\n    const pulse = () => {\n      if (pulseCount >= maxPulses) {\n        return;\n      }\n\n      // 绘制脉冲效果\n      const screenPos = this.imageToScreen(keypoint.x, keypoint.y);\n      const ctx = this.ctx;\n\n      ctx.save();\n      ctx.globalAlpha = 0.6 - (pulseCount * 0.2);\n      ctx.strokeStyle = '#f59e0b';\n      ctx.lineWidth = 3;\n      ctx.setLineDash([]);\n\n      const radius = 30 + (pulseCount * 10);\n      ctx.beginPath();\n      ctx.arc(screenPos.x, screenPos.y, radius, 0, 2 * Math.PI);\n      ctx.stroke();\n\n      ctx.restore();\n\n      pulseCount++;\n      if (pulseCount < maxPulses) {\n        setTimeout(pulse, 200);\n      }\n    };\n\n    // 延迟一点开始脉冲效果\n    setTimeout(pulse, 100);\n  }\n\n  /**\n   * 约束视图，确保不超出合理边界\n   */\n  constrainView() {\n    if (!this.imageElement) return;\n\n    const imageWidth = this.imageElement.width * this.state.scale;\n    const imageHeight = this.imageElement.height * this.state.scale;\n    const canvasWidth = this.canvas.width;\n    const canvasHeight = this.canvas.height;\n\n    // 如果图像小于画布，居中显示\n    if (imageWidth < canvasWidth) {\n      this.state.translateX = (canvasWidth - imageWidth) / 2;\n    } else {\n      // 确保图像不会移出画布太远\n      const maxTranslateX = 0;\n      const minTranslateX = canvasWidth - imageWidth;\n      this.state.translateX = Math.max(minTranslateX, Math.min(maxTranslateX, this.state.translateX));\n    }\n\n    if (imageHeight < canvasHeight) {\n      this.state.translateY = (canvasHeight - imageHeight) / 2;\n    } else {\n      const maxTranslateY = 0;\n      const minTranslateY = canvasHeight - imageHeight;\n      this.state.translateY = Math.max(minTranslateY, Math.min(maxTranslateY, this.state.translateY));\n    }\n  }\n\n  /**\n   * 选择下一个自动方向选择的关键点\n   */\n  selectNextAutoDirectionKeypoint() {\n    this.state.autoDirectionIndex++;\n\n    if (this.state.autoDirectionIndex >= this.state.autoDirectionKeypoints.length) {\n      // 当前图片的所有标注点都已完成\n      const totalUpgraded = this.state.autoDirectionKeypoints.length;\n      console.log(`当前图片方向设置完成，共设置了 ${totalUpgraded} 个标注点`);\n\n      // 尝试切换到下一张图片继续自动化\n      if (this.tryAutoSwitchToNextImage()) {\n        console.log('自动切换到下一张图片继续方向设置');\n        return;\n      }\n\n      // 没有下一张图片，完全结束自动化模式\n      this.exitAutoDirectionMode();\n      this.resetAutoDirectionButton();\n\n      // 显示完成提示\n      if (window.showSuccess) {\n        window.showSuccess('全部完成', `自动化方向设置已完成！`);\n      }\n      return;\n    }\n\n    const nextKeypoint = this.state.autoDirectionKeypoints[this.state.autoDirectionIndex];\n    this.selectKeypointWithZoom(nextKeypoint);\n\n    const progress = `${this.state.autoDirectionIndex + 1}/${this.state.autoDirectionKeypoints.length}`;\n    console.log(`自动选择下一个传统标注点 #${nextKeypoint.order} (${progress})`);\n\n    // 显示进度提示\n    if (window.showInfo) {\n      window.showInfo('升级进度', `正在升级第 ${this.state.autoDirectionIndex + 1} 个，共 ${this.state.autoDirectionKeypoints.length} 个传统标注点`);\n    }\n  }\n\n  /**\n   * 显示自动模式完成提示\n   */\n  showAutoModeCompletionHint() {\n    // 创建完成提示元素\n    const hint = document.createElement('div');\n    hint.className = 'auto-direction-completion-hint';\n    hint.textContent = '🎉 自动化方向选择已完成！';\n    hint.style.cssText = `\n      position: absolute;\n      top: 50px;\n      left: 50%;\n      transform: translateX(-50%);\n      background: linear-gradient(135deg, #10b981 0%, #059669 100%);\n      color: white;\n      padding: 12px 24px;\n      border-radius: 25px;\n      font-size: 14px;\n      font-weight: 600;\n      z-index: 1000;\n      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);\n      animation: completionBounce 0.6s ease-out;\n    `;\n    \n    // 添加动画样式\n    if (!document.getElementById('completion-animation-style')) {\n      const style = document.createElement('style');\n      style.id = 'completion-animation-style';\n      style.textContent = `\n        @keyframes completionBounce {\n          0% {\n            opacity: 0;\n            transform: translateX(-50%) translateY(-20px) scale(0.8);\n          }\n          50% {\n            transform: translateX(-50%) translateY(0) scale(1.1);\n          }\n          100% {\n            opacity: 1;\n            transform: translateX(-50%) translateY(0) scale(1);\n          }\n        }\n      `;\n      document.head.appendChild(style);\n    }\n    \n    // 添加到canvas容器\n    const canvasContainer = document.getElementById('canvas-container');\n    if (canvasContainer) {\n      canvasContainer.appendChild(hint);\n      \n      // 3秒后自动移除\n      setTimeout(() => {\n        if (hint.parentElement) {\n          hint.remove();\n        }\n      }, 3000);\n    }\n  }\n\n  /**\n   * 🔧 NEW: Set Auto Direction Mode (Longitudinal vs Cross-Sectional)\n   * @param {string} mode - 'longitudinal' or 'cross-sectional'\n   */\n  setAutoDirectionMode(mode) {\n    if (!['longitudinal', 'cross-sectional'].includes(mode)) {\n      throw new Error('Invalid auto direction mode: ' + mode);\n    }\n    \n    this.autoDirectionMode = mode;\n    console.log(`Auto Direction mode set to: ${mode}`);\n    \n    // Update UI to reflect mode change\n    this.updateAutoDirectionModeUI();\n  }\n\n  /**\n   * 🔧 NEW: Update UI to reflect current auto direction mode\n   */\n  updateAutoDirectionModeUI() {\n    const autoDirectionBtn = document.getElementById('auto-direction-btn');\n    const modeSelector = document.getElementById('auto-direction-mode-selector');\n    \n    if (autoDirectionBtn && this.autoDirectionMode) {\n      // Remove existing mode classes\n      autoDirectionBtn.classList.remove('longitudinal-mode', 'cross-sectional-mode');\n      \n      // Add current mode class\n      autoDirectionBtn.classList.add(`${this.autoDirectionMode}-mode`);\n      \n      // Update button text if needed\n      if (this.state.isAutoDirectionMode) {\n        const modeText = this.autoDirectionMode === 'cross-sectional' ? 'Exit Vertical Mode' : 'Exit Horizontal Mode';\n        autoDirectionBtn.textContent = modeText;\n      } else {\n        autoDirectionBtn.textContent = 'Auto Direction';\n      }\n    }\n    \n    // 🔧 FIX: Only update mode selector if we have a valid mode\n    // Don't override UI selector with null/undefined values\n    if (modeSelector && this.autoDirectionMode) {\n      modeSelector.value = this.autoDirectionMode;\n      console.log('[调试] 更新UI选择器为:', this.autoDirectionMode);\n    }\n  }\n\n  /**\n   * 🔧 NEW: Build Cross-Sectional Map for all images\n   * @returns {Promise<Map>} Map of order numbers to array of {imageId, annotation} pairs\n   */\n  async buildCrossSectionalMap() {\n    const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n    const appState = window.PlantAnnotationTool?.appState;\n    \n    if (!plantDataManager || !appState?.currentPlant) {\n      throw new Error('Plant data manager or current plant not available');\n    }\n    \n    const crossSectionalMap = new Map();\n    \n    try {\n      // Get all images for current plant and view angle\n      const allImages = await plantDataManager.getPlantImages(\n        appState.currentPlant.id,\n        appState.currentPlant.selectedViewAngle\n      );\n      \n      if (!allImages || allImages.length === 0) {\n        throw new Error('No images found for current plant and view angle');\n      }\n      \n      console.log(`[Cross-Sectional] Analyzing ${allImages.length} images for directionless annotations`);\n      \n      // Analyze each image for directionless annotations\n      for (const image of allImages) {\n        try {\n          const annotations = await plantDataManager.getImageAnnotations(image.id);\n          \n          if (annotations && annotations.length > 0) {\n            // Find directionless annotations\n            const directionlessAnnotations = annotations.filter(ann => \n              !ann.direction || ann.direction === 'none' || ann.direction === null\n            );\n            \n            // Group by order number\n            for (const annotation of directionlessAnnotations) {\n              const order = annotation.order || 1;\n              \n              if (!crossSectionalMap.has(order)) {\n                crossSectionalMap.set(order, []);\n              }\n              \n              crossSectionalMap.get(order).push({\n                imageId: image.id,\n                imageName: image.name,\n                annotation: annotation\n              });\n            }\n          }\n        } catch (error) {\n          console.warn(`[Cross-Sectional] Failed to load annotations for image ${image.id}:`, error);\n        }\n      }\n      \n      // Sort each order group by image name for consistent processing order\n      for (const [order, imageAnnotationPairs] of crossSectionalMap) {\n        imageAnnotationPairs.sort((a, b) => a.imageName.localeCompare(b.imageName));\n      }\n      \n      console.log(`[Cross-Sectional] Built map with ${crossSectionalMap.size} order numbers`, \n        Array.from(crossSectionalMap.keys()).sort((a, b) => a - b));\n      \n      return crossSectionalMap;\n      \n    } catch (error) {\n      console.error('[Cross-Sectional] Failed to build cross-sectional map:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 NEW: Get all available order numbers across all images\n   * @returns {Array<number>} Sorted array of order numbers\n   */\n  getAvailableOrderNumbers() {\n    if (!this.crossSectionalMap) {\n      return [];\n    }\n    \n    return Array.from(this.crossSectionalMap.keys()).sort((a, b) => a - b);\n  }\n\n  /**\n   * 🔧 NEW: Get all images that have annotations with specific order\n   * @param {number} order - Order number to search for\n   * @returns {Array} Array of {imageId, imageName, annotation} objects\n   */\n  getImagesWithOrder(order) {\n    if (!this.crossSectionalMap || !this.crossSectionalMap.has(order)) {\n      return [];\n    }\n    \n    return this.crossSectionalMap.get(order);\n  }\n\n  /**\n   * 🔧 NEW: Initialize Cross-Sectional State\n   */\n  initializeCrossSectionalState() {\n    const availableOrders = this.getAvailableOrderNumbers();\n    \n    if (availableOrders.length === 0) {\n      throw new Error('No directionless annotations found across all images');\n    }\n    \n    this.crossSectionalState = {\n      currentOrder: availableOrders[0],\n      currentImageIndex: 0,\n      processedCount: 0,\n      totalCount: this.getAllCrossSectionalPoints().length,\n      availableOrders: availableOrders,\n      startTime: Date.now()\n    };\n    \n    console.log(`[Cross-Sectional] Initialized state:`, this.crossSectionalState);\n  }\n\n  /**\n   * 🔧 NEW: Get all cross-sectional points for progress tracking\n   * @returns {Array} All directionless annotation points across all images\n   */\n  getAllCrossSectionalPoints() {\n    const allPoints = [];\n    \n    if (!this.crossSectionalMap) {\n      return allPoints;\n    }\n    \n    for (const imageAnnotationPairs of this.crossSectionalMap.values()) {\n      allPoints.push(...imageAnnotationPairs);\n    }\n    \n    return allPoints;\n  }\n\n  /**\n   * 🔧 NEW: Get current cross-sectional annotation to process\n   * @returns {Object|null} Current annotation data or null if done\n   */\n  getCurrentCrossSectionalPoint() {\n    if (!this.crossSectionalState) {\n      return null;\n    }\n    \n    const { currentOrder, currentImageIndex } = this.crossSectionalState;\n    const imagesWithCurrentOrder = this.getImagesWithOrder(currentOrder);\n    \n    if (currentImageIndex >= imagesWithCurrentOrder.length) {\n      return null; // No more images for current order\n    }\n    \n    return imagesWithCurrentOrder[currentImageIndex];\n  }\n\n  /**\n   * 🔧 NEW: Process current cross-sectional point with direction\n   * @param {string|number} direction - Direction value ('left', 'right', or angle in degrees)\n   */\n  async processCurrentCrossSectionalPoint(direction) {\n    // 🔧 FIX: Check if state exists first\n    if (!this.crossSectionalState) {\n      console.warn('[Cross-Sectional] Cannot process point - state is null');\n      return;\n    }\n    \n    const currentPoint = this.getCurrentCrossSectionalPoint();\n    \n    if (!currentPoint) {\n      console.warn('[Cross-Sectional] No current point to process');\n      return;\n    }\n    \n    try {\n      // Update the annotation with direction\n      currentPoint.annotation.direction = direction;\n      \n      // Save to storage\n      const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n      if (plantDataManager) {\n        const allAnnotations = await plantDataManager.getImageAnnotations(currentPoint.imageId);\n        await plantDataManager.saveImageAnnotations(currentPoint.imageId, allAnnotations);\n      }\n      \n      // 🔧 FIX: Check state again before updating count\n      if (!this.crossSectionalState) {\n        console.warn('[Cross-Sectional] State became null during processing');\n        return;\n      }\n      \n      // Update progress\n      this.crossSectionalState.processedCount++;\n      \n      console.log(`[Cross-Sectional] Processed annotation #${currentPoint.annotation.order} in ${currentPoint.imageName} with direction: ${direction}`);\n      \n      // Move to next point\n      await this.advanceCrossSectionalProgress();\n      \n    } catch (error) {\n      console.error('[Cross-Sectional] Failed to process point:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 🔧 NEW: Advance cross-sectional processing to next point\n   */\n  async advanceCrossSectionalProgress() {\n    if (!this.crossSectionalState) {\n      return;\n    }\n    \n    const { currentOrder, currentImageIndex, availableOrders } = this.crossSectionalState;\n    const imagesWithCurrentOrder = this.getImagesWithOrder(currentOrder);\n    \n    // Check if there are more images with current order\n    if (currentImageIndex + 1 < imagesWithCurrentOrder.length) {\n      // 🔧 FIX: Check state still exists before updating\n      if (!this.crossSectionalState) {\n        console.warn('[Cross-Sectional] State became null during advance, cannot continue');\n        return;\n      }\n      \n      // Move to next image with same order\n      this.crossSectionalState.currentImageIndex++;\n      const nextImageData = imagesWithCurrentOrder[this.crossSectionalState.currentImageIndex];\n      \n      console.log(`[Cross-Sectional] Moving to next image for order ${currentOrder}: ${nextImageData.imageName}`);\n      \n      // Switch to next image\n      await this.switchToImageForCrossSectional(nextImageData.imageId);\n      \n    } else {\n      // Current order complete, move to next order\n      const currentOrderIndex = availableOrders.indexOf(currentOrder);\n      \n      if (currentOrderIndex + 1 < availableOrders.length) {\n        // 🔧 FIX: Check state still exists before updating\n        if (!this.crossSectionalState) {\n          console.warn('[Cross-Sectional] State became null during advance, cannot continue');\n          return;\n        }\n        \n        // Move to next order\n        const nextOrder = availableOrders[currentOrderIndex + 1];\n        this.crossSectionalState.currentOrder = nextOrder;\n        this.crossSectionalState.currentImageIndex = 0;\n        \n        const nextOrderImages = this.getImagesWithOrder(nextOrder);\n        if (nextOrderImages.length > 0) {\n          console.log(`[Cross-Sectional] Moving to next order ${nextOrder}, starting with: ${nextOrderImages[0].imageName}`);\n          \n          // Switch to first image with next order\n          await this.switchToImageForCrossSectional(nextOrderImages[0].imageId);\n        }\n      } else {\n        // All orders processed - complete cross-sectional mode\n        console.log('[Cross-Sectional] All orders processed, completing mode');\n        this.completeCrossSectionalMode();\n      }\n    }\n    \n    // Update progress UI\n    this.updateCrossSectionalProgressUI();\n  }\n\n  /**\n   * 🔧 NEW: Switch to specific image for cross-sectional processing\n   * @param {string} targetImageId - Image ID to switch to\n   */\n  async switchToImageForCrossSectional(targetImageId) {\n    try {\n      console.log(`[Cross-Sectional] Starting image switch to: ${targetImageId}`);\n      \n      const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n      const appState = window.PlantAnnotationTool?.appState;\n      \n      if (!plantDataManager || !appState?.currentPlant) {\n        throw new Error('Plant data manager or current plant not available');\n      }\n      \n      // Get image data\n      const allImages = await plantDataManager.getPlantImages(\n        appState.currentPlant.id,\n        appState.currentPlant.selectedViewAngle\n      );\n      \n      const targetImage = allImages.find(img => img.id === targetImageId);\n      if (!targetImage) {\n        throw new Error(`Image not found: ${targetImageId}`);\n      }\n      \n      console.log(`[Cross-Sectional] Switching to image: ${targetImage.name}`);\n      \n      // Use global image selection function\n      if (window.handleImageSelect) {\n        console.log(`[Cross-Sectional] Calling handleImageSelect...`);\n        await window.handleImageSelect(targetImage, true);\n        console.log(`[Cross-Sectional] handleImageSelect completed successfully`);\n      } else {\n        throw new Error('Global image selection function not available');\n      }\n      \n      // Wait for image to load and annotations to be ready\n      console.log(`[Cross-Sectional] Waiting for image to load...`);\n      await this.waitForImageLoad();\n      console.log(`[Cross-Sectional] Image loaded successfully`);\n      \n      // Select the annotation for current processing\n      const currentPoint = this.getCurrentCrossSectionalPoint();\n      if (currentPoint && currentPoint.annotation) {\n        console.log(`[Cross-Sectional] Looking for annotation #${currentPoint.annotation.order} in loaded keypoints`);\n        \n        // Find the annotation in the loaded keypoints\n        const loadedAnnotation = this.keypoints.find(kp => \n          kp.order === currentPoint.annotation.order\n        );\n        \n        if (loadedAnnotation) {\n          console.log(`[Cross-Sectional] Found annotation #${loadedAnnotation.order}, selecting it`);\n          this.state.selectedKeypoint = loadedAnnotation;\n          this.state.isDirectionSelectionMode = true;\n          \n          // Center view on the annotation\n          this.selectKeypointWithZoom(loadedAnnotation);\n        } else {\n          console.warn(`[Cross-Sectional] Could not find annotation #${currentPoint.annotation.order} in loaded keypoints`);\n        }\n      } else {\n        console.warn(`[Cross-Sectional] No current point available after image switch`);\n      }\n      \n    } catch (error) {\n      console.error('[Cross-Sectional] Failed to switch image:', error);\n      // Don't re-throw the error, continue with error handling\n      if (window.PlantAnnotationTool?.showError) {\n        window.PlantAnnotationTool.showError('Image Switch Failed', error.message);\n      }\n    }\n  }\n\n  /**\n   * 🔧 NEW: Wait for image load to complete\n   */\n  async waitForImageLoad(maxWaitTime = 5000) {\n    const startTime = Date.now();\n    \n    console.log(`[Cross-Sectional] Waiting for image load... (max ${maxWaitTime}ms)`);\n    \n    while (!this.imageLoaded && (Date.now() - startTime) < maxWaitTime) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    if (!this.imageLoaded) {\n      console.warn(`[Cross-Sectional] Image load timeout after ${maxWaitTime}ms`);\n      // Don't throw error, continue anyway\n      return false;\n    }\n    \n    console.log(`[Cross-Sectional] Image loaded in ${Date.now() - startTime}ms`);\n    return true;\n  }\n\n  /**\n   * 🔧 NEW: Complete cross-sectional mode\n   */\n  completeCrossSectionalMode() {\n    // 🔧 FIX: Check if state exists before accessing\n    if (!this.crossSectionalState) {\n      console.warn('[Cross-Sectional] Cannot complete - state is null');\n      // Just exit auto direction mode if state is already gone\n      this.exitAutoDirectionMode();\n      return;\n    }\n    \n    const duration = Date.now() - this.crossSectionalState.startTime;\n    const processedCount = this.crossSectionalState.processedCount;\n    \n    console.log(`[Cross-Sectional] Mode completed! Processed ${processedCount} annotations in ${duration}ms`);\n    \n    // Show completion message\n    if (window.updateProgressInfo) {\n      window.updateProgressInfo(`Cross-Sectional mode completed! Processed ${processedCount} annotations across all images.`);\n    }\n    \n    // Clean up state\n    this.crossSectionalState = null;\n    this.crossSectionalMap.clear();\n    \n    // Exit auto direction mode\n    this.exitAutoDirectionMode();\n  }\n\n  /**\n   * 🔧 NEW: Update cross-sectional progress UI\n   */\n  updateCrossSectionalProgressUI() {\n    const progressIndicator = document.getElementById('auto-direction-progress');\n    const progressCurrent = document.getElementById('progress-current');\n    const progressTotal = document.getElementById('progress-total');\n    const progressFill = document.getElementById('auto-direction-progress-fill');\n    const progressModeInfo = document.getElementById('progress-mode-info');\n    \n    if (!this.crossSectionalState) {\n      if (progressIndicator) {\n        progressIndicator.style.display = 'none';\n      }\n      return;\n    }\n    \n    const { processedCount, totalCount, currentOrder, availableOrders } = this.crossSectionalState;\n    const progressPercentage = totalCount > 0 ? (processedCount / totalCount) * 100 : 0;\n    \n    if (progressIndicator) {\n      progressIndicator.style.display = 'block';\n    }\n    \n    if (progressCurrent) {\n      progressCurrent.textContent = processedCount;\n    }\n    \n    if (progressTotal) {\n      progressTotal.textContent = totalCount;\n    }\n    \n    if (progressFill) {\n      progressFill.style.width = `${progressPercentage}%`;\n      progressFill.className = 'progress-fill cross-sectional-indicator';\n    }\n    \n    if (progressModeInfo) {\n      const currentOrderIndex = availableOrders.indexOf(currentOrder);\n      progressModeInfo.textContent = `Order ${currentOrder} (${currentOrderIndex + 1}/${availableOrders.length})`;\n    }\n  }\n\n  /**\n   * 🔧 NEW: Get Auto Direction Progress (works for both modes)\n   * @returns {Object} Progress information\n   */\n  getAutoDirectionProgress() {\n    if (this.autoDirectionMode === 'cross-sectional' && this.crossSectionalState) {\n      const { processedCount, totalCount, currentOrder, availableOrders } = this.crossSectionalState;\n      \n      return {\n        total: totalCount,\n        completed: processedCount,\n        percentage: totalCount > 0 ? Math.round((processedCount / totalCount) * 100) : 0,\n        currentOrder: currentOrder,\n        totalOrders: availableOrders.length,\n        mode: 'cross-sectional'\n      };\n    } else if (this.autoDirectionMode === 'longitudinal' && this.state.isAutoDirectionMode) {\n      const total = this.state.autoDirectionKeypoints.length;\n      const completed = this.state.autoDirectionIndex;\n      \n      return {\n        total: total,\n        completed: completed,\n        percentage: total > 0 ? Math.round((completed / total) * 100) : 0,\n        mode: 'longitudinal'\n      };\n    }\n    \n    return {\n      total: 0,\n      completed: 0,\n      percentage: 0,\n      mode: this.autoDirectionMode\n    };\n  }\n\n  /**\n   * 退出自动化方向选择模式\n   */\n  exitAutoDirectionMode() {\n    console.log('[调试] exitAutoDirectionMode 被调用', {\n      stackTrace: new Error().stack\n    });\n\n    // 🔧 FIX: Store the user's mode preference before resetting\n    const userModePreference = this.autoDirectionMode;\n    console.log('[调试] 保存用户模式偏好:', userModePreference);\n\n    this.state.isAutoDirectionMode = false;\n    this.state.autoDirectionKeypoints = [];\n    this.state.autoDirectionIndex = 0;\n\n    // 清理方向选择状态，但不需要强制退出（因为已经在退出了）\n    this.state.selectedKeypoint = null;\n    this.state.isDirectionSelectionMode = false;\n    this.state.directionSelectionPoint = null;\n\n    // 🔧 FIX: Only reset cross-sectional state if we're not in the middle of completion\n    // This prevents null reference errors during the completion process\n    if (this.autoDirectionMode === 'cross-sectional' && this.crossSectionalState) {\n      console.log('[调试] 延迟清理 cross-sectional 状态，让完成流程处理');\n      // Don't reset cross-sectional state here - let completeCrossSectionalMode handle it\n      // But preserve the user's mode preference\n      this.autoDirectionMode = userModePreference;\n    } else {\n      // For non-cross-sectional modes or if state is already null, reset state but preserve mode preference\n      this.crossSectionalState = null;\n      // 🔧 FIX: Don't reset autoDirectionMode to null - preserve user's choice\n      this.autoDirectionMode = userModePreference;\n    }\n\n    this.restoreNormalPreview();\n    this.render();\n\n    // 🔧 FIX: Reset auto direction button state when exiting auto direction mode\n    this.resetAutoDirectionButton();\n\n    // 🔧 FIX: Preserve the mode selector UI state\n    const modeSelector = document.getElementById('auto-direction-mode-selector');\n    if (modeSelector && userModePreference) {\n      modeSelector.value = userModePreference;\n      console.log('[调试] 恢复UI选择器状态:', userModePreference);\n    }\n\n    console.log('Exited auto direction mode, preserved mode preference:', userModePreference);\n  }\n\n  /**\n   * 通知预览管理器显示选中关键点的预览\n   */\n  notifySelectedKeypointPreview(keypoint) {\n    const branchPointPreviewManager = window.PlantAnnotationTool?.branchPointPreviewManager;\n    \n    if (branchPointPreviewManager && keypoint && keypoint.order) {\n      branchPointPreviewManager.showSpecificOrderPreview(keypoint.order);\n    }\n  }\n\n  /**\n   * 恢复正常的预览显示\n   */\n  restoreNormalPreview() {\n    // 通过全局对象访问分支点预览管理器\n    const branchPointPreviewManager = window.PlantAnnotationTool?.branchPointPreviewManager;\n    \n    if (branchPointPreviewManager) {\n      // 恢复到显示下一个要标注编号的预览\n      branchPointPreviewManager.restoreNormalPreview();\n    }\n  }\n\n  /**\n   * 处理右键菜单\n   */\n  handleContextMenu(event) {\n    event.preventDefault();\n    \n    const mousePos = this.getMousePos(event);\n    \n    // 首先检查是否点击了自定义标注\n    const clickedCustomAnnotation = this.getCustomAnnotationAt(mousePos);\n    if (clickedCustomAnnotation) {\n      this.removeCustomAnnotation(clickedCustomAnnotation);\n      return;\n    }\n    \n    // 如果没有自定义标注，检查常规关键点\n    const clickedKeypoint = this.getKeypointAt(mousePos);\n    if (clickedKeypoint) {\n      this.removeKeypoint(clickedKeypoint);\n    }\n  }\n\n  /**\n   * 处理滚轮缩放\n   */\n  handleWheel(event) {\n    event.preventDefault();\n    \n    // 🔧 NEW: 如果处于方向数量模式，用滚轮调整方向数量\n    if (this.state.isDirectionCountMode) {\n      this.handleScrollWheel(event);\n      return;\n    }\n    \n    const mousePos = this.getMousePos(event);\n    const delta = -event.deltaY;\n    const zoomFactor = 1 + (delta > 0 ? this.options.zoomSpeed : -this.options.zoomSpeed);\n    \n    this.zoomAt(mousePos.x, mousePos.y, zoomFactor);\n  }\n\n  /**\n   * 在指定点缩放\n   */\n  zoomAt(x, y, factor) {\n    const newScale = this.state.scale * factor;\n    \n    // 限制缩放范围\n    if (newScale < this.options.minZoom || newScale > this.options.maxZoom) {\n      return;\n    }\n    \n    // 计算缩放后的位移\n    this.state.translateX = x - (x - this.state.translateX) * factor;\n    this.state.translateY = y - (y - this.state.translateY) * factor;\n    this.state.scale = newScale;\n    \n    this.updateZoomInfo();\n    this.render();\n  }\n\n  /**\n   * 处理键盘按下\n   */\n  handleKeyDown(event) {\n    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {\n      return; // 在输入框中时不处理\n    }\n    \n    switch (event.key) {\n      case ' ':\n        event.preventDefault();\n        // 空格键准备平移\n        break;\n        \n      case 'r':\n      case 'R':\n        event.preventDefault();\n        this.resetView();\n        break;\n        \n      case '1':\n        event.preventDefault();\n        this.setZoom(1);\n        break;\n        \n      case 'z':\n        if (event.ctrlKey || event.metaKey) {\n          event.preventDefault();\n          if (event.shiftKey) {\n            this.redo();\n          } else {\n            this.undo();\n          }\n        }\n        break;\n        \n      case 'y':\n        if (event.ctrlKey || event.metaKey) {\n          event.preventDefault();\n          this.redo();\n        }\n        break;\n    }\n  }\n\n  /**\n   * 处理键盘抬起\n   */\n  handleKeyUp(event) {\n    // 可以在这里处理键盘抬起事件\n  }\n\n  /**\n   * 设置缩放级别\n   */\n  setZoom(scale) {\n    if (!this.imageElement || !this.imageLoaded) return;\n    \n    const centerX = this.canvas.width / 2;\n    const centerY = this.canvas.height / 2;\n    \n    this.zoomAt(centerX, centerY, scale / this.state.scale);\n  }\n\n  /**\n   * 更新缩放信息显示\n   */\n  updateZoomInfo() {\n    const zoomElement = document.getElementById('zoom-level');\n    if (zoomElement) {\n      zoomElement.textContent = Math.round(this.state.scale * 100) + '%';\n    }\n  }\n\n  /**\n   * 获取指定位置的标注点\n   */\n  getKeypointAt(screenPos) {\n    const threshold = this.options.baseKeypointRadius + 5;\n    \n    return this.keypoints.find(keypoint => {\n      const keypointScreen = this.imageToScreen(keypoint.x, keypoint.y);\n      const distance = Math.sqrt(\n        Math.pow(screenPos.x - keypointScreen.x, 2) +\n        Math.pow(screenPos.y - keypointScreen.y, 2)\n      );\n      return distance <= threshold;\n    });\n  }\n\n  /**\n   * 添加标注点（向后兼容方法）\n   */\n  addKeypoint(screenPos, direction = 'right') {\n    // 🔧 FIX: Use comprehensive bounds checking for annotation creation\n    if (!this.canCreateAnnotationAt(screenPos.x, screenPos.y)) {\n      console.warn('[AnnotationTool] Cannot add keypoint: position is outside valid annotation area');\n      return;\n    }\n    \n    const imagePos = this.screenToImage(screenPos.x, screenPos.y);\n    this.addKeypointWithDirection(imagePos.x, imagePos.y, direction);\n  }\n\n  /**\n   * 添加带方向的标注点（支持自定义类型）\n   */\n  addKeypointWithDirection(x, y, direction, customTypeId = null, width = null, height = null) {\n    // 🔧 FIX: Ensure image is loaded before creating keypoints\n    if (!this.imageElement || !this.imageLoaded) {\n      console.warn('[AnnotationTool] Cannot add keypoint: no image loaded');\n      return;\n    }\n\n    // 🔄 NEW: If in custom mode and a point type is selected, default to that type\n    if (!customTypeId && this.customAnnotationManager && this.customAnnotationManager.isInCustomMode()) {\n      const currentType = this.customAnnotationManager.getCurrentCustomType();\n      if (currentType && (currentType.type === 'point' || currentType.type === 'region')) {\n        customTypeId = currentType.id;\n        // Respect isDirectional: if false, strip direction\n        if (!currentType.metadata || currentType.metadata.isDirectional === false) {\n          direction = null;\n        }\n      }\n    }\n\n    // 🔧 FIX: 使用类型特定的序号分配\n    const order = customTypeId ? this.findNextAvailableOrderForType(customTypeId) : this.findNextAvailableOrder();\n\n    // 统一方向格式：将传统的left/right转换为角度\n    let normalizedDirection = direction;\n    if (direction === 'left') {\n      normalizedDirection = 180; // 左侧为180度\n    } else if (direction === 'right') {\n      normalizedDirection = 0;   // 右侧为0度\n    } else if (typeof direction === 'number') {\n      normalizedDirection = direction;\n    } else if (direction === undefined) {\n      // 保持 undefined，不写入 direction 字段\n      normalizedDirection = undefined;\n    } else {\n      normalizedDirection = 0;   // 默认为右侧\n    }\n\n    const keypoint = {\n      id: Date.now(),\n      x: x,\n      y: y,\n      timestamp: new Date().toISOString(),\n      ...(normalizedDirection !== undefined && { direction: normalizedDirection }),\n      ...(normalizedDirection !== undefined && { directionType: 'angle' }),\n      order: order,  // 添加序号字段\n      \n      // 🔄 NEW: 统一标注系统 - 支持自定义类型\n      annotationType: customTypeId ? 'custom' : 'regular',\n      ...(customTypeId && { customTypeId }),\n      ...(typeof width === 'number' && { width }),\n      ...(typeof height === 'number' && { height })\n    };\n\n    this.keypoints.push(keypoint);\n    this.saveState();\n    this.render();\n\n    // 自动保存到当前图像\n    this.autoSaveCurrentImage();\n\n    // 🔄 NEW: 实时同步 - 标注点添加\n    this.triggerRealTimeSync('ADD_KEYPOINT', keypoint);\n\n    // 同步分支点预览\n    this.syncBranchPointPreview();\n\n    // 🔧 FIX: Set flag to indicate we just created a new point\n    this.justCreatedNewPoint = true;\n\n    // 🔧 FIX: Only move to expected position if auto-move is enabled\n    if (this.state.autoMoveToExpectedPosition) {\n      this.moveToNextExpectedPosition();\n      this.justCreatedNewPoint = false; // Reset flag after moving\n    }\n\n    const typeDesc = customTypeId ? `custom(${customTypeId})` : 'regular';\n    const directionDesc = typeof normalizedDirection === 'number' ? `${normalizedDirection}°` : normalizedDirection;\n    console.log(`Added ${typeDesc} keypoint #${order} at (${x.toFixed(1)}, ${y.toFixed(1)}) with direction ${directionDesc}`);\n    \n    return keypoint;\n  }\n\n  /**\n   * 🔄 NEW: 添加自定义点标注（统一到keypoints系统）\n   */\n  addCustomPointAnnotation(x, y, customTypeId) {\n    // Use default angle from type metadata if provided\n    let direction = null;\n    try {\n      const customType = this.getCustomType(customTypeId);\n      if (customType && customType.metadata && typeof customType.metadata.defaultAngle === 'number') {\n        direction = customType.metadata.defaultAngle;\n      }\n    } catch (e) {\n      // Fallback to null (will default to 0° in addKeypointWithDirection)\n    }\n    return this.addKeypointWithDirection(x, y, direction, customTypeId);\n  }\n  \n  /**\n   * 🔄 NEW: 添加自定义区域标注（统一到keypoints系统）\n   */\n  addCustomRegionAnnotation(x, y, width, height, customTypeId) {\n    return this.addKeypointWithDirection(x, y, null, customTypeId, width, height);\n  }\n  \n  /**\n   * 🔄 NEW: 获取自定义类型定义\n   */\n  getCustomType(customTypeId) {\n    // 🔧 FIX: 直接从CustomAnnotationManager获取自定义类型\n    if (this.customAnnotationManager) {\n      return this.customAnnotationManager.getCustomType(customTypeId);\n    }\n    return this.customTypes?.get(customTypeId) || null;\n  }\n  \n  /**\n   * 🔄 NEW: 设置自定义类型定义\n   */\n  setCustomTypes(customTypes) {\n    this.customTypes = customTypes;\n  }\n  \n  /**\n   * 🔄 NEW: 处理自定义标注模式下的点击（统一版本）\n   */\n  handleUnifiedCustomAnnotationMode(mousePos) {\n    if (!this.customAnnotationManager) {\n      console.warn('Custom annotation manager not available');\n      return;\n    }\n    \n    try {\n      const customType = this.customAnnotationManager.getCurrentCustomType();\n      if (!customType) {\n        console.warn('No custom type selected');\n        return;\n      }\n      \n      const imagePos = this.screenToImage(mousePos.x, mousePos.y);\n      \n      if (customType.type === 'point') {\n        // 创建自定义点标注\n        const keypoint = this.addCustomPointAnnotation(imagePos.x, imagePos.y, customType.id);\n        if (keypoint) {\n          console.log('Created unified custom point annotation:', keypoint);\n        }\n      } else if (customType.type === 'region') {\n        // 开始拖拽区域标注\n        this.startUnifiedCustomRegionDrag(mousePos, customType.id);\n      }\n    } catch (error) {\n      console.error('Failed to handle unified custom annotation mode:', error);\n    }\n  }\n  \n  /**\n   * 🔄 NEW: 开始统一的自定义区域拖拽\n   */\n  startUnifiedCustomRegionDrag(mousePos, customTypeId) {\n    if (!this.canCreateAnnotationAt(mousePos.x, mousePos.y)) {\n      console.warn('Cannot create custom region annotation: position is outside valid area');\n      return;\n    }\n\n    this.state.isCustomRegionDragging = true;\n    this.state.customRegionStartPoint = mousePos;\n    this.state.customRegionCurrentPoint = mousePos;\n    this.state.customRegionTypeId = customTypeId;\n    this.canvas.style.cursor = 'crosshair';\n    \n    console.log('Started unified custom region drag at:', mousePos);\n  }\n  \n  /**\n   * 🔄 NEW: 完成统一的自定义区域拖拽\n   */\n  finishUnifiedCustomRegionDrag() {\n    if (!this.state.isCustomRegionDragging || !this.state.customRegionStartPoint || !this.state.customRegionCurrentPoint) {\n      this.resetCustomRegionDrag();\n      return;\n    }\n\n    const startPos = this.screenToImage(this.state.customRegionStartPoint.x, this.state.customRegionStartPoint.y);\n    const endPos = this.screenToImage(this.state.customRegionCurrentPoint.x, this.state.customRegionCurrentPoint.y);\n\n    // 检查拖拽距离是否足够\n    const width = Math.abs(endPos.x - startPos.x);\n    const height = Math.abs(endPos.y - startPos.y);\n    const minSize = 10; // 最小区域尺寸\n\n    if (width < minSize || height < minSize) {\n      console.log('Region too small, ignoring');\n      this.resetCustomRegionDrag();\n      return;\n    }\n\n    // 计算区域位置\n    const x = Math.min(startPos.x, endPos.x);\n    const y = Math.min(startPos.y, endPos.y);\n    \n    // 创建自定义区域标注\n    const keypoint = this.addCustomRegionAnnotation(x, y, width, height, this.state.customRegionTypeId);\n    \n    if (keypoint) {\n      console.log('Created unified custom region annotation:', keypoint);\n    }\n\n    this.resetCustomRegionDrag();\n  }\n  \n  /**\n   * 🔧 NEW: 为特定自定义类型找到下一个可用的编号（独立计数）\n   */\n  findNextAvailableOrderForType(customTypeId) {\n    // 只考虑相同自定义类型的标注\n    const sameTypeKeypoints = this.keypoints.filter(kp => \n      kp.annotationType === 'custom' && kp.customTypeId === customTypeId\n    );\n    \n    if (sameTypeKeypoints.length === 0) {\n      return 1;\n    }\n    \n    // 获取该类型所有现有的编号并排序\n    const existingOrders = sameTypeKeypoints\n      .map(kp => kp.order || 0)\n      .filter(order => order > 0)\n      .sort((a, b) => a - b);\n    \n    // 找到最小的缺失编号\n    for (let i = 1; i <= existingOrders.length + 1; i++) {\n      if (!existingOrders.includes(i)) {\n        return i;\n      }\n    }\n    \n    // 如果没有缺失，返回下一个编号\n    return existingOrders.length + 1;\n  }\n\n  /**\n   * 找到下一个可用的编号（最小的缺失编号）- 只考虑常规标注\n   */\n  findNextAvailableOrder() {\n    // 🔧 FIX: 只考虑常规标注的序号，实现独立计数\n    // 🐛 BUGFIX: Include fallback for annotations without annotationType field (loaded from storage)\n    const regularKeypoints = this.keypoints.filter(kp => \n      kp.annotationType === 'regular' || !kp.annotationType);\n    \n    if (regularKeypoints.length === 0) {\n      return 1;\n    }\n    \n    // 获取所有现有的编号并排序\n    const existingOrders = regularKeypoints\n      .map(kp => kp.order || 0)\n      .filter(order => order > 0)\n      .sort((a, b) => a - b);\n    \n    // 找到最小的缺失编号\n    for (let i = 1; i <= existingOrders.length + 1; i++) {\n      if (!existingOrders.includes(i)) {\n        return i;\n      }\n    }\n    \n    // 如果没有缺失，返回下一个编号\n    return existingOrders.length + 1;\n  }\n\n  /**\n   * 删除标注点\n   */\n  removeKeypoint(keypoint) {\n    const index = this.keypoints.indexOf(keypoint);\n    if (index !== -1) {\n      const removed = this.keypoints.splice(index, 1)[0];\n      \n      // 不再重新整理序号，保持其他标注点的编号不变\n      // this.reorderKeypoints(); // 移除这行\n      \n      this.saveState();\n      this.render();\n      \n      // 触发实时同步删除（如果启用）\n      this.triggerRealTimeSync('DELETE_KEYPOINT', removed);\n      \n      // 自动保存到当前图像\n      this.autoSaveCurrentImage();\n      \n      // 同步分支点预览\n      this.syncBranchPointPreview();\n      \n      console.log(`Removed keypoint #${removed.order || 'unknown'} (id: ${keypoint.id})`);\n      console.log(`下一个新增标注点将使用编号: ${this.findNextAvailableOrder()}`);\n    }\n  }\n\n  /**\n   * 清空所有标注点\n   */\n  clearKeypoints() {\n    if (this.keypoints.length > 0) {\n      this.keypoints = [];\n      this.saveState();\n      this.render();\n      \n      // 自动保存到当前图像（清空状态）\n      this.autoSaveCurrentImage();\n      \n      // 同步分支点预览\n      this.syncBranchPointPreview();\n      \n      console.log('Cleared all keypoints (unified system)');\n    }\n  }\n\n  /**\n   * 清空所有标注点但不触发自动保存 - 用于工作区清理（统一版本）\n   */\n  clearKeypointsWithoutSave() {\n    if (this.keypoints.length > 0) {\n      this.keypoints = [];\n      this.saveState();\n      this.render();\n      \n      // 同步分支点预览但不保存\n      this.syncBranchPointPreview();\n      \n      console.log('Cleared all keypoints (without auto-save, unified system)');\n    }\n  }\n\n  /**\n   * 重新整理标注点序号，确保序号连续\n   */\n  reorderKeypoints() {\n    // 先按照当前序号排序（如果有的话）\n    this.keypoints.sort((a, b) => {\n      const orderA = a.order || 0;\n      const orderB = b.order || 0;\n      return orderA - orderB;\n    });\n    \n    // 重新分配连续的序号\n    for (let i = 0; i < this.keypoints.length; i++) {\n      this.keypoints[i].order = i + 1;\n    }\n    \n    console.log(`Reordered ${this.keypoints.length} keypoints`);\n  }\n\n  /**\n   * 保存状态到历史记录\n   */\n  saveState() {\n    const state = {\n      keypoints: JSON.parse(JSON.stringify(this.keypoints)),\n      timestamp: Date.now()\n    };\n    \n    // 移除当前位置之后的历史记录\n    this.history = this.history.slice(0, this.historyIndex + 1);\n    \n    // 添加新状态\n    this.history.push(state);\n    this.historyIndex = this.history.length - 1;\n    \n    // 限制历史记录大小\n    if (this.history.length > this.maxHistorySize) {\n      this.history.shift();\n      this.historyIndex--;\n    }\n  }\n\n  /**\n   * 撤销\n   */\n  undo() {\n    if (this.historyIndex > 0) {\n      this.historyIndex--;\n      const state = this.history[this.historyIndex];\n      this.keypoints = JSON.parse(JSON.stringify(state.keypoints));\n      this.render();\n      \n      // 自动保存到当前图像\n      this.autoSaveCurrentImage();\n      \n      // 同步分支点预览\n      this.syncBranchPointPreview();\n      \n      console.log('Undo');\n    }\n  }\n\n  /**\n   * 重做\n   */\n  redo() {\n    if (this.historyIndex < this.history.length - 1) {\n      this.historyIndex++;\n      const state = this.history[this.historyIndex];\n      this.keypoints = JSON.parse(JSON.stringify(state.keypoints));\n      this.render();\n      \n      // 自动保存到当前图像\n      this.autoSaveCurrentImage();\n      \n      // 同步分支点预览\n      this.syncBranchPointPreview();\n      \n      console.log('Redo');\n    }\n  }\n\n  /**\n   * 获取标注数据（统一版本，包含自定义标注）\n   */\n  getAnnotationData() {\n    return {\n      keypoints: this.keypoints.map(kp => ({...kp})), // 包含所有标注：常规 + 自定义\n      imageInfo: this.currentImage ? {\n        name: this.currentImage.name,\n        width: this.imageElement?.width,\n        height: this.imageElement?.height\n      } : null,\n      viewState: {\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      }\n    };\n  }\n\n  /**\n   * 加载标注数据（统一版本，包含自定义标注）\n   */\n  loadAnnotationData(data) {\n    if (data.keypoints) {\n      this.keypoints = data.keypoints.map(kp => ({...kp})); // 包含所有标注：常规 + 自定义\n\n      // 🔧 DISABLED: 为没有序号的旧数据添加序号（兼容性处理）\n      // IMPORTANT: This automatic renumbering was causing order inconsistencies\n      // across frames in real-time sync. Annotations should maintain their\n      // original order numbers to ensure consistent synchronization.\n      // this.ensureKeypointOrders();\n      \n      console.log(`🔄 Loaded ${this.keypoints.length} keypoints (auto-renumbering disabled)`);\n    }\n\n    if (data.viewState) {\n      this.state.scale = data.viewState.scale || 1;\n      this.state.translateX = data.viewState.translateX || 0;\n      this.state.translateY = data.viewState.translateY || 0;\n      this.updateZoomInfo();\n    }\n\n    this.saveState();\n    this.render();\n  }\n\n  /**\n   * 确保所有标注点都有序号（兼容性处理）- 统一系统版本\n   */\n  ensureKeypointOrders() {\n    // 🔧 FIX: 使用类型感知的序号检查，与PlantDataManager保持一致\n    \n    // 按类型分组标注点\n    const annotationsByType = {};\n    \n    this.keypoints.forEach(keypoint => {\n      const typeKey = keypoint.annotationType === 'custom' \n        ? `custom:${keypoint.customTypeId || 'unknown'}`\n        : 'regular';\n      \n      if (!annotationsByType[typeKey]) {\n        annotationsByType[typeKey] = [];\n      }\n      annotationsByType[typeKey].push(keypoint);\n    });\n    \n    let hasOrderIssues = false;\n    let totalFixed = 0;\n    \n    // 为每个类型独立检查序号\n    Object.entries(annotationsByType).forEach(([typeKey, typeAnnotations]) => {\n      let typeHasIssues = false;\n      \n      // 检查该类型是否有序号问题\n      for (let i = 0; i < typeAnnotations.length; i++) {\n        if (typeof typeAnnotations[i].order !== 'number' || typeAnnotations[i].order <= 0) {\n          typeHasIssues = true;\n          break;\n        }\n      }\n      \n      // 检查该类型内部是否有重复序号\n      if (!typeHasIssues) {\n        const orders = typeAnnotations.map(kp => kp.order);\n        const uniqueOrders = [...new Set(orders)];\n        if (uniqueOrders.length !== orders.length) {\n          typeHasIssues = true;\n        }\n      }\n      \n      // 如果该类型有序号问题，重新分配\n      if (typeHasIssues) {\n        console.log(`发现 ${typeKey} 类型标注序号问题，正在为 ${typeAnnotations.length} 个标注点分配序号...`);\n        hasOrderIssues = true;\n        \n        // 按照原有顺序为该类型分配序号（从1开始）\n        for (let i = 0; i < typeAnnotations.length; i++) {\n          typeAnnotations[i].order = i + 1;\n        }\n        \n        totalFixed += typeAnnotations.length;\n        console.log(`已为 ${typeKey} 类型分配序号：1-${typeAnnotations.length}`);\n      }\n    });\n    \n    if (hasOrderIssues) {\n      console.log('发现传统数据或序号问题，正在为标注点添加/修复序号...');\n      console.log(`序号修复完成：共修复 ${totalFixed} 个标注点，保持类型特定编号系统`);\n    }\n  }\n\n  /**\n   * 销毁组件\n   */\n  destroy() {\n    // 移除事件监听器\n    // 这里应该移除所有绑定的事件监听器，但为了简化暂时省略\n    \n    // 清理资源\n    if (this.imageElement && this.imageElement.src.startsWith('blob:')) {\n      URL.revokeObjectURL(this.imageElement.src);\n    }\n    \n    console.log('AnnotationTool destroyed');\n  }\n\n  /**\n   * 开始方向标注\n   */\n  startDirectionAnnotation(mousePos) {\n    // 🔧 FIX: Use comprehensive bounds checking for direction annotation creation\n    if (!this.canCreateAnnotationAt(mousePos.x, mousePos.y)) {\n      if (window.PlantAnnotationTool?.showError) {\n        window.PlantAnnotationTool.showError('Invalid Position', 'Direction annotations can only be placed within the image area. Please click directly on the image.');\n      }\n      return;\n    }\n    \n    const imagePos = this.screenToImage(mousePos.x, mousePos.y);\n    \n    this.state.isDirectionDragging = true;\n    this.state.dragStartPoint = mousePos;\n    this.state.currentDragPoint = mousePos;\n    this.state.previewKeypoint = {\n      x: imagePos.x,\n      y: imagePos.y,\n      direction: 0, // 默认方向（0度，向右）\n      directionType: 'angle'\n    };\n    \n    this.canvas.style.cursor = 'grabbing';\n    console.log('Started direction annotation');\n  }\n\n  /**\n   * 更新方向拖拽\n   */\n  updateDirectionDragging(mousePos) {\n    this.state.currentDragPoint = mousePos;\n\n    // 计算拖拽方向角度\n    const deltaX = mousePos.x - this.state.dragStartPoint.x;\n    const deltaY = mousePos.y - this.state.dragStartPoint.y;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n    if (distance >= this.options.directionThreshold) {\n      // 计算角度（0-360度）\n      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\n      const normalizedAngle = (angle + 360) % 360;\n\n      this.state.previewKeypoint.direction = normalizedAngle;\n      this.state.previewKeypoint.directionType = 'angle';\n    } else {\n      // 距离不够，使用默认方向\n      this.state.previewKeypoint.direction = 0; // 默认向右\n      this.state.previewKeypoint.directionType = 'angle';\n    }\n\n    this.render();\n  }\n\n  /**\n   * 完成方向标注\n   */\n  finishDirectionAnnotation() {\n    if (!this.state.previewKeypoint) {\n      this.resetDirectionDragging();\n      return;\n    }\n\n    // 计算拖拽距离\n    const deltaX = this.state.currentDragPoint.x - this.state.dragStartPoint.x;\n    const deltaY = this.state.currentDragPoint.y - this.state.dragStartPoint.y;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n    let direction, directionType;\n\n    if (distance >= this.options.directionThreshold) {\n      // 拖拽距离足够，使用计算的角度方向\n      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\n      direction = (angle + 360) % 360;\n      directionType = 'angle';\n\n      console.log(`Added keypoint with angle direction ${direction.toFixed(1)}° at (${this.state.previewKeypoint.x.toFixed(1)}, ${this.state.previewKeypoint.y.toFixed(1)})`);\n    } else {\n      // 拖拽距离不够，当作普通点击，添加默认角度方向\n      direction = 0; // 默认向右（0度）\n      directionType = 'angle';\n\n      console.log(`Added default keypoint (0°) at (${this.state.previewKeypoint.x.toFixed(1)}, ${this.state.previewKeypoint.y.toFixed(1)})`);\n    }\n\n    // 添加带角度方向的标注点\n    this.addKeypointWithDirection(\n      this.state.previewKeypoint.x,\n      this.state.previewKeypoint.y,\n      direction\n    );\n\n    this.resetDirectionDragging();\n  }\n\n  /**\n   * 重置方向拖拽状态\n   */\n  resetDirectionDragging() {\n    this.state.isDirectionDragging = false;\n    this.state.dragStartPoint = null;\n    this.state.currentDragPoint = null;\n    this.state.previewKeypoint = null;\n    this.canvas.style.cursor = 'crosshair';\n    this.render();\n  }\n\n  /**\n   * 获取标注点显示策略\n   */\n  getKeypointDisplayStrategy() {\n    const scale = this.state.scale;\n    \n    // 计算实际的标注点半径（默认使用更小的基础半径）\n    const smallRadius = 2; // 更小的默认点半径\n    let actualRadius;\n    \n    if (scale >= 1.5) {\n      // 大缩放：使用能容纳文字的最小圆圈\n      const fontSize = Math.max(10, Math.min(16, 12 * scale));\n      \n      // 根据文字大小计算合适的圆圈半径\n      // 文字高度约等于fontSize，需要留一点边距\n      const textBasedRadius = Math.max(8, fontSize * 0.7); // 文字大小的70%作为半径\n      \n      // 限制最大半径，在高缩放时不要让圆圈过大\n      const maxRadiusForLargeScale = Math.min(12, 8 + (scale - 1.5) * 2); // 最大12px，缓慢增长\n      \n      actualRadius = Math.min(textBasedRadius, maxRadiusForLargeScale);\n      actualRadius = Math.max(8, actualRadius); // 最小保证8px\n    } else {\n      // 默认和小缩放：使用更小的点\n      actualRadius = smallRadius + (scale - 0.1) * 1.5; // 从2px到4px的范围\n      actualRadius = Math.max(smallRadius, Math.min(4, actualRadius));\n    }\n    \n    return {\n      scale: scale,\n      radius: actualRadius,\n      showInternalLabel: scale >= 1.5, // 只有在1.5倍缩放以上才内部显示\n      showExternalLabel: scale >= this.options.tinyThresholdScale, // 大部分情况下外部显示\n      showMinimalMode: scale < this.options.tinyThresholdScale,\n      fontSize: Math.max(10, Math.min(16, 12 * scale)),\n      directionFontSize: Math.max(8, Math.min(12, 10 * scale)),\n      labelOffset: 8, // 更小的偏移距离\n      borderWidth: Math.max(1, Math.min(2, 1.5 * scale))\n    };\n  }\n\n  /**\n   * 创建外部标签\n   */\n  createExternalLabel(x, y, label, direction, fillColor, strategy) {\n    const canvas = this.canvas;\n    const container = canvas.parentElement;\n    \n    // 创建标签元素\n    const labelElement = document.createElement('div');\n    labelElement.className = `keypoint-label ${direction === 'left' ? 'left-direction' : 'right-direction'}`;\n    labelElement.textContent = label.toString();\n    labelElement.dataset.keypointId = `${x}-${y}`;\n    \n    // 计算标签位置\n    const rect = canvas.getBoundingClientRect();\n    const containerRect = container.getBoundingClientRect();\n    \n    const offsetX = rect.left - containerRect.left;\n    const offsetY = rect.top - containerRect.top;\n    \n    // 根据标注点大小调整标签位置，让标签距离更远\n    const labelOffsetY = strategy.radius < 4 ? 12 : 15;\n    \n    labelElement.style.left = (offsetX + x - 6) + 'px'; // 居中对齐，稍微调整\n    labelElement.style.top = (offsetY + y - strategy.radius - labelOffsetY) + 'px';\n    \n    container.appendChild(labelElement);\n  }\n\n  /**\n   * 创建悬停提示\n   */\n  createTooltip(x, y, label, direction, keypoint) {\n    const canvas = this.canvas;\n    const container = canvas.parentElement;\n    \n    // 移除已存在的提示\n    const existingTooltip = container.querySelector('.keypoint-tooltip');\n    if (existingTooltip) {\n      existingTooltip.remove();\n    }\n    \n    // 创建提示元素\n    const tooltip = document.createElement('div');\n    tooltip.className = 'keypoint-tooltip';\n    \n    const directionText = direction === 'left' ? 'Left' : 'Right';\n    const coordinateText = `(${Math.round(keypoint.x)}, ${Math.round(keypoint.y)})`;\n    \n    tooltip.innerHTML = `\n      <div>分支点 #${label}</div>\n      <div>方向: ${directionText}</div>\n      <div>位置: ${coordinateText}</div>\n    `;\n    \n    // 计算提示位置\n    const rect = canvas.getBoundingClientRect();\n    const containerRect = container.getBoundingClientRect();\n    \n    const offsetX = rect.left - containerRect.left;\n    const offsetY = rect.top - containerRect.top;\n    \n    tooltip.style.left = (offsetX + x - 60) + 'px';\n    tooltip.style.top = (offsetY + y - 80) + 'px';\n    \n    container.appendChild(tooltip);\n    \n    // 自动移除提示\n    setTimeout(() => {\n      if (tooltip.parentElement) {\n        tooltip.remove();\n      }\n    }, 3000);\n  }\n\n  /**\n   * 清除所有标注点标签\n   */\n  clearKeypointLabels() {\n    if (!this.canvas || !this.canvas.parentElement) return;\n    \n    const container = this.canvas.parentElement;\n    const labels = container.querySelectorAll('.keypoint-label');\n    labels.forEach(label => label.remove());\n  }\n\n  /**\n   * 更新缩放级别指示器\n   */\n  updateZoomIndicator(strategy) {\n    const indicator = document.getElementById('zoom-indicator');\n    if (!indicator) return;\n    \n    // 移除所有状态类\n    indicator.classList.remove('small', 'tiny');\n    \n    if (strategy.showMinimalMode) {\n      indicator.classList.add('tiny');\n    } else if (strategy.showExternalLabel) {\n      indicator.classList.add('small');\n    }\n  }\n\n  /**\n   * 更新标注点大小信息\n   */\n  updateAnnotationSizeInfo(strategy) {\n    const sizeInfo = document.getElementById('annotation-size-info');\n    const sizeText = document.getElementById('size-info-text');\n    \n    if (!sizeInfo || !sizeText) return;\n    \n    let statusText = '';\n    let showInfo = false;\n    \n    if (strategy.showMinimalMode) {\n      statusText = '标注点: 极小模式（悬停查看详情）';\n      showInfo = true;\n    } else if (strategy.showExternalLabel) {\n      statusText = '标注点: 外部标签模式';\n      showInfo = true;\n    } else {\n      statusText = '标注点: 正常大小';\n      showInfo = this.keypoints.length > 0 && (strategy.scale < 0.8 || strategy.scale > 3);\n    }\n    \n    sizeText.textContent = statusText;\n    \n    if (showInfo) {\n      sizeInfo.classList.add('visible');\n      \n      // 自动隐藏\n      setTimeout(() => {\n        if (sizeInfo) {\n          sizeInfo.classList.remove('visible');\n        }\n      }, 2000);\n    } else {\n      sizeInfo.classList.remove('visible');\n    }\n  }\n\n  /**\n   * 同步分支点预览\n   */\n  syncBranchPointPreview() {\n    // 通过全局对象访问分支点预览管理器\n    const branchPointPreviewManager = window.PlantAnnotationTool?.branchPointPreviewManager;\n    const appState = window.PlantAnnotationTool?.appState;\n    \n    if (branchPointPreviewManager && appState?.currentPlant && appState?.currentImage) {\n      // 获取当前标注点数量并更新预览上下文\n      const currentKeypointCount = this.keypoints.length;\n      \n      // 异步更新预览上下文\n      setTimeout(async () => {\n        try {\n          const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n          if (plantDataManager) {\n            const images = await plantDataManager.getPlantImages(\n              appState.currentPlant.id, \n              appState.currentPlant.selectedViewAngle\n            );\n            const imageIndex = images.findIndex(img => img.id === appState.currentImage.id);\n            \n            await branchPointPreviewManager.updateContext(\n              appState.currentPlant.id,\n              appState.currentPlant.selectedViewAngle,\n              imageIndex,\n              currentKeypointCount\n            );\n          }\n        } catch (error) {\n          console.warn('同步分支点预览失败:', error);\n        }\n      }, 100);\n    }\n  }\n\n  /**\n   * 通知预览管理器显示被拖动点对应的预览\n   */\n  notifyDraggedKeypointPreview(keypoint) {\n    // 通过全局对象访问分支点预览管理器\n    const branchPointPreviewManager = window.PlantAnnotationTool?.branchPointPreviewManager;\n    \n    if (branchPointPreviewManager && keypoint && keypoint.order) {\n      // 告诉预览管理器显示这个编号的预览\n      branchPointPreviewManager.showSpecificOrderPreview(keypoint.order);\n    }\n  }\n\n  /**\n   * 🔧 NEW: 设置图像切换锁定状态\n   * @param {boolean} isLocked - 是否锁定\n   * @param {string} imageId - 正在加载的图像ID\n   */\n  setImageSwitchLock(isLocked, imageId = null) {\n    this.imageSwitchLock.isLocked = isLocked;\n    this.imageSwitchLock.currentLoadingImageId = imageId;\n    this.imageSwitchLock.lockStartTime = isLocked ? Date.now() : null;\n    \n    console.log(`[图像切换锁] ${isLocked ? '锁定' : '解锁'} - 图像: ${imageId || 'none'}`);\n  }\n  \n  /**\n   * 🔧 NEW: 验证当前图像一致性\n   * @param {string} expectedImageId - 期望的图像ID\n   * @returns {boolean} 是否一致\n   */\n  validateCurrentImageConsistency(expectedImageId) {\n    const appState = window.PlantAnnotationTool?.appState;\n    if (!appState?.currentImage?.id) {\n      console.warn('[一致性检查] 当前图像状态无效');\n      return false;\n    }\n    \n    const isConsistent = appState.currentImage.id === expectedImageId;\n    if (!isConsistent) {\n      console.warn(`[一致性检查] 不一致 - 期望: ${expectedImageId}, 实际: ${appState.currentImage.id}`);\n    }\n    \n    return isConsistent;\n  }\n  \n  /**\n   * 🔧 ENHANCED: 自动保存当前图像（带锁定机制）\n   */\n  async autoSaveCurrentImage() {\n    try {\n      const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n      const appState = window.PlantAnnotationTool?.appState;\n      \n      if (!plantDataManager || !appState?.currentPlant || !appState?.currentImage) {\n        console.warn('自动保存跳过：缺少必要的上下文信息');\n        return;\n      }\n      \n      // 🔧 NEW: 检查图像切换锁定状态\n      if (this.imageSwitchLock.isLocked) {\n        console.warn(`[自动保存] 跳过：图像切换进行中 (${this.imageSwitchLock.currentLoadingImageId})`);\n        return;\n      }\n      \n      // 🔧 FIX: 检查 currentImage 的有效性，防止 null 引用错误\n      if (!appState.currentImage || !appState.currentImage.id) {\n        console.warn('自动保存跳过：当前图像信息无效');\n        return;\n      }\n      \n      // 🔧 NEW: 记录当前图像ID，用于一致性验证\n      const currentImageId = appState.currentImage.id;\n      \n      // 获取当前标注数据\n      const annotationData = this.getAnnotationData();\n      \n      // 🔧 NEW: 在保存前再次验证图像一致性\n      if (!this.validateCurrentImageConsistency(currentImageId)) {\n        console.warn(`[自动保存] 跳过：图像状态在保存前发生变化 (${currentImageId})`);\n        return;\n      }\n      \n      // 保存到当前图像（即使没有标注点也要保存，表示清空状态）\n      await plantDataManager.saveImageAnnotations(\n        currentImageId,\n        annotationData.keypoints\n      );\n      \n      // 🔧 NEW: 在保存后验证图像状态仍然一致\n      if (!this.validateCurrentImageConsistency(currentImageId)) {\n        console.warn(`[自动保存] 警告：图像状态在保存后发生变化，数据可能已保存到错误图像 (${currentImageId})`);\n        return;\n      }\n      \n      console.log(`自动保存完成：${annotationData.keypoints.length} 个标注点已保存到图像 ${currentImageId}`);\n      \n      // 🔧 FIX: 自动保存后立即刷新缩略图状态（通过全局函数访问）\n      try {\n        // 尝试通过window对象访问全局函数\n        const refreshFunction = window.refreshThumbnailAnnotationStatus;\n        if (typeof refreshFunction === 'function') {\n          await refreshFunction(currentImageId);\n          console.log('自动保存后缩略图状态已刷新');\n        } else {\n          console.warn('refreshThumbnailAnnotationStatus 函数未找到，跳过缩略图刷新');\n        }\n      } catch (refreshError) {\n        console.warn('刷新缩略图状态失败:', refreshError);\n      }\n      \n    } catch (error) {\n      console.error('自动保存失败:', error);\n    }\n  }\n\n  /**\n   * 🔄 触发实时同步操作\n   * @param {string} operationType - 操作类型 ('ADD_KEYPOINT', 'MOVE_KEYPOINT', 'DELETE_KEYPOINT', 'EDIT_DIRECTION')\n   * @param {object} keypoint - 相关的关键点数据\n   * @param {object} previousPosition - 之前的位置（仅移动操作需要）\n   */\n  triggerRealTimeSync(operationType, keypoint, previousPosition = null) {\n    try {\n      // 获取实时同步管理器\n      const realTimeSyncManager = window.PlantAnnotationTool?.realTimeSyncManager;\n      \n      if (!realTimeSyncManager) {\n        console.warn('🔄 实时同步管理器未找到，跳过同步操作');\n        return;\n      }\n\n      // 检查是否启用了实时同步\n      if (!realTimeSyncManager.isRealTimeSyncEnabled()) {\n        console.log('🔄 实时同步已禁用，跳过同步操作');\n        return;\n      }\n\n      // 获取当前上下文\n      const appState = window.PlantAnnotationTool?.appState;\n      if (!appState?.currentPlant || !appState?.currentImage) {\n        console.warn('🔄 缺少当前植株或图像信息，跳过同步操作');\n        return;\n      }\n\n      // 🔧 Enhanced Debug: Log detailed keypoint information\n      const keypointInfo = {\n        id: keypoint?.id,\n        order: keypoint?.order,\n        annotationType: keypoint?.annotationType,\n        customTypeId: keypoint?.customTypeId,\n        x: keypoint?.x,\n        y: keypoint?.y\n      };\n\n      console.log(`🔄 触发实时同步: ${operationType}`, {\n        keypoint: keypointInfo,\n        plant: appState.currentPlant.id,\n        image: appState.currentImage.id,\n        isCustom: keypoint?.annotationType === 'custom'\n      });\n\n      // 🔧 FIX: Route custom annotations to custom annotation sync methods\n      // This is crucial for proper order-based synchronization\n      const isCustomAnnotation = keypoint?.annotationType === 'custom';\n      \n      if (isCustomAnnotation) {\n        // Use custom annotation sync methods for custom annotations\n        console.log(`🔄 Using custom annotation sync for ${operationType}`);\n        \n        switch (operationType) {\n          case 'ADD_KEYPOINT':\n            // Create sync data for custom annotation creation\n            const createSyncData = {\n              type: 'CUSTOM_ANNOTATION_CREATE',\n              annotation: keypoint,\n              context: {\n                imageId: appState.currentImage.id,\n                plantId: appState.currentPlant.id,\n                viewAngle: appState.currentPlant.selectedViewAngle,\n                appState: appState\n              },\n              timestamp: new Date().toISOString()\n            };\n            realTimeSyncManager.triggerCustomAnnotationSync(createSyncData);\n            break;\n            \n          case 'MOVE_KEYPOINT':\n            // Create sync data for custom annotation update\n            const updateSyncData = {\n              type: 'CUSTOM_ANNOTATION_UPDATE',\n              annotation: keypoint,\n              context: {\n                imageId: appState.currentImage.id,\n                plantId: appState.currentPlant.id,\n                viewAngle: appState.currentPlant.selectedViewAngle,\n                appState: appState,\n                positionChange: {\n                  from: previousPosition,\n                  to: { x: keypoint.x, y: keypoint.y }\n                }\n              },\n              timestamp: new Date().toISOString()\n            };\n            realTimeSyncManager.triggerCustomAnnotationSync(updateSyncData);\n            break;\n            \n          case 'DELETE_KEYPOINT':\n            // Create sync data for custom annotation deletion\n            const deleteSyncData = {\n              type: 'CUSTOM_ANNOTATION_DELETE',\n              annotation: keypoint,\n              context: {\n                imageId: appState.currentImage.id,\n                plantId: appState.currentPlant.id,\n                viewAngle: appState.currentPlant.selectedViewAngle,\n                appState: appState\n              },\n              timestamp: new Date().toISOString()\n            };\n            realTimeSyncManager.triggerCustomAnnotationSync(deleteSyncData);\n            break;\n            \n          default:\n            console.warn(`🔄 未知的自定义标注同步操作类型: ${operationType}`);\n        }\n      } else {\n        // Use regular keypoint sync methods for regular annotations\n        console.log(`🔄 Using regular keypoint sync for ${operationType}`);\n        \n        switch (operationType) {\n          case 'ADD_KEYPOINT':\n            realTimeSyncManager.triggerKeypointAddSync(\n              keypoint,\n              appState.currentImage,\n              appState.currentPlant\n            );\n            break;\n            \n          case 'MOVE_KEYPOINT':\n            realTimeSyncManager.triggerKeypointMoveSync(\n              keypoint,\n              previousPosition,\n              appState.currentImage,\n              appState.currentPlant\n            );\n            break;\n            \n          case 'DELETE_KEYPOINT':\n            realTimeSyncManager.triggerKeypointDeleteSync(\n              keypoint,\n              appState.currentImage,\n              appState.currentPlant\n            );\n            break;\n            \n          case 'EDIT_DIRECTION':\n            realTimeSyncManager.triggerDirectionEditSync(\n              keypoint,\n              appState.currentImage,\n              appState.currentPlant\n            );\n            break;\n            \n          default:\n            console.warn(`🔄 未知的常规标注同步操作类型: ${operationType}`);\n        }\n      }\n      \n    } catch (error) {\n      console.error('🔄 触发实时同步失败:', error);\n    }\n  }\n\n  /**\n   * 渲染方向指示器（统一处理所有方向类型）\n   */\n  renderDirectionIndicator(x, y, direction, keypoint) {\n    if (!direction) return;\n\n    let angleDegrees;\n    let directionText = '';\n\n    // 统一转换为角度\n    if (typeof direction === 'number') {\n      // 已经是角度\n      angleDegrees = direction;\n      directionText = `${angleDegrees.toFixed(1)}°`;\n    } else if (direction === 'left') {\n      // 左侧：180度\n      angleDegrees = 180;\n      directionText = 'Left (180°)';\n    } else if (direction === 'right') {\n      // 右侧：0度\n      angleDegrees = 0;\n      directionText = 'Right (0°)';\n    } else {\n      return; // 未知方向类型\n    }\n\n    this.renderDirectionArrow(x, y, angleDegrees, directionText, keypoint);\n  }\n\n  /**\n   * 渲染方向箭头（改进版 - 虚线从中心延伸）\n   */\n  renderDirectionArrow(x, y, angleDegrees, directionText, keypoint) {\n    const angleRadians = angleDegrees * Math.PI / 180;\n    const arrowLength = this.options.directionArrowLength;\n\n    // 计算箭头终点\n    const endX = x + Math.cos(angleRadians) * arrowLength;\n    const endY = y + Math.sin(angleRadians) * arrowLength;\n\n    // 绘制虚线主线\n    this.ctx.strokeStyle = '#10b981'; // 绿色\n    this.ctx.lineWidth = 3;\n    this.ctx.setLineDash([8, 4]); // 虚线样式\n    this.ctx.lineCap = 'round';\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(x, y);\n    this.ctx.lineTo(endX, endY);\n    this.ctx.stroke();\n\n    // 重置虚线样式\n    this.ctx.setLineDash([]);\n\n    // 绘制箭头头部（实线）\n    const headAngle1 = angleRadians + Math.PI * 0.8;\n    const headAngle2 = angleRadians - Math.PI * 0.8;\n    const headLength = 15;\n\n    this.ctx.strokeStyle = '#10b981';\n    this.ctx.lineWidth = 3;\n    this.ctx.lineCap = 'round';\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(endX, endY);\n    this.ctx.lineTo(endX + Math.cos(headAngle1) * headLength, endY + Math.sin(headAngle1) * headLength);\n    this.ctx.moveTo(endX, endY);\n    this.ctx.lineTo(endX + Math.cos(headAngle2) * headLength, endY + Math.sin(headAngle2) * headLength);\n    this.ctx.stroke();\n\n    // 绘制方向文本（带背景）\n    const textOffset = 20;\n    const textX = endX + Math.cos(angleRadians) * textOffset;\n    const textY = endY + Math.sin(angleRadians) * textOffset;\n\n    // 测量文本尺寸\n    this.ctx.font = 'bold 11px Arial';\n    const textMetrics = this.ctx.measureText(directionText);\n    const textWidth = textMetrics.width;\n    const textHeight = 11;\n\n    // 绘制文本背景\n    this.ctx.fillStyle = 'rgba(16, 185, 129, 0.9)';\n    this.ctx.fillRect(textX - textWidth/2 - 3, textY - textHeight/2 - 2, textWidth + 6, textHeight + 4);\n\n    // 绘制文本\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(directionText, textX, textY);\n  }\n\n  /**\n   * 渲染方向选择指引\n   */\n  renderDirectionSelectionGuide() {\n    if (!this.state.selectedKeypoint || !this.state.directionSelectionPoint) return;\n\n    const keypointScreen = this.imageToScreen(\n      this.state.selectedKeypoint.x,\n      this.state.selectedKeypoint.y\n    );\n\n    const guideX = this.state.directionSelectionPoint.x;\n    const guideY = this.state.directionSelectionPoint.y;\n\n    // 计算距离，只有足够远才显示指引\n    const distance = Math.sqrt(\n      Math.pow(guideX - keypointScreen.x, 2) +\n      Math.pow(guideY - keypointScreen.y, 2)\n    );\n\n    if (distance < 20) return; // 距离太近不显示\n\n    // 绘制虚线指引线\n    this.ctx.strokeStyle = '#f59e0b'; // 橙色\n    this.ctx.lineWidth = 3;\n    this.ctx.setLineDash([8, 4]);\n    this.ctx.lineCap = 'round';\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(keypointScreen.x, keypointScreen.y);\n    this.ctx.lineTo(guideX, guideY);\n    this.ctx.stroke();\n\n    // 绘制箭头头部\n    const deltaX = guideX - keypointScreen.x;\n    const deltaY = guideY - keypointScreen.y;\n    const angle = Math.atan2(deltaY, deltaX);\n    const normalizedAngle = (angle * 180 / Math.PI + 360) % 360;\n\n    const headAngle1 = angle + Math.PI * 0.8;\n    const headAngle2 = angle - Math.PI * 0.8;\n    const headLength = 12;\n\n    this.ctx.setLineDash([]); // 实线箭头\n    this.ctx.beginPath();\n    this.ctx.moveTo(guideX, guideY);\n    this.ctx.lineTo(guideX + Math.cos(headAngle1) * headLength, guideY + Math.sin(headAngle1) * headLength);\n    this.ctx.moveTo(guideX, guideY);\n    this.ctx.lineTo(guideX + Math.cos(headAngle2) * headLength, guideY + Math.sin(headAngle2) * headLength);\n    this.ctx.stroke();\n\n    // 绘制角度文本（带背景）\n    const textOffset = 25;\n    const textX = guideX + Math.cos(angle) * textOffset;\n    const textY = guideY + Math.sin(angle) * textOffset;\n    const angleText = `${normalizedAngle.toFixed(1)}°`;\n\n    // 测量文本尺寸\n    this.ctx.font = 'bold 12px Arial';\n    const textMetrics = this.ctx.measureText(angleText);\n    const textWidth = textMetrics.width;\n    const textHeight = 12;\n\n    // 绘制文本背景\n    this.ctx.fillStyle = 'rgba(245, 158, 11, 0.9)';\n    this.ctx.fillRect(textX - textWidth/2 - 4, textY - textHeight/2 - 2, textWidth + 8, textHeight + 4);\n\n    // 绘制文本\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(angleText, textX, textY);\n\n    // 重置线条样式\n    this.ctx.setLineDash([]);\n  }\n\n  /**\n   * 升级传统方向到角度方向\n   */\n  upgradeLegacyDirections() {\n    let upgraded = 0;\n\n    this.keypoints.forEach(keypoint => {\n      if (keypoint.direction === 'left' && keypoint.directionType !== 'angle') {\n        keypoint.direction = 180;\n        keypoint.directionType = 'angle';\n        upgraded++;\n      } else if (keypoint.direction === 'right' && keypoint.directionType !== 'angle') {\n        keypoint.direction = 0;\n        keypoint.directionType = 'angle';\n        upgraded++;\n      }\n    });\n\n    if (upgraded > 0) {\n      console.log(`Upgraded ${upgraded} legacy direction annotations to angle format`);\n      this.saveState();\n      this.render();\n      this.autoSaveCurrentImage();\n    }\n\n    return upgraded;\n  }\n\n  /**\n   * 设置自动切换到预期位置功能\n   */\n  setAutoMoveToExpectedPosition(enabled) {\n    this.state.autoMoveToExpectedPosition = enabled;\n    console.log(`自动切换到预期位置: ${enabled ? '开启' : '关闭'}`);\n  }\n\n  /**\n   * 获取目标缩放倍数（锁定倍数优先，否则保持当前倍数）\n   */\n  getTargetScale() {\n    // 获取锁定倍数设置\n    if (typeof window.getZoomLockSettings === 'function') {\n      const zoomSettings = window.getZoomLockSettings();\n      if (zoomSettings.isLocked) {\n        console.log(`[自动切换] 使用锁定倍数: ${zoomSettings.lockValue}x`);\n        return zoomSettings.lockValue;\n      }\n    }\n\n    // 非锁定状态：保持当前倍数\n    console.log(`[自动切换] 保持当前倍数: ${this.state.scale.toFixed(1)}x`);\n    return this.state.scale;\n  }\n\n  /**\n   * 移动视角到最高标记点并保持当前缩放\n   */\n  moveToHighestKeypoint() {\n    if (!this.keypoints || this.keypoints.length === 0) {\n      console.log('没有标注点，无法移动视角');\n      return false;\n    }\n\n    // 找到序号最大的标注点\n    const highestKeypoint = this.keypoints.reduce((highest, current) => {\n      const currentOrder = current.order || 0;\n      const highestOrder = highest.order || 0;\n      return currentOrder > highestOrder ? current : highest;\n    });\n\n    console.log(`移动视角到最高标记点 #${highestKeypoint.order}`);\n\n    // 保持当前缩放，只移动视角中心\n    const currentScale = this.state.scale;\n    const centerX = this.canvas.width / 2;\n    const centerY = this.canvas.height / 2;\n\n    // 计算新的平移，使最高标记点居中\n    this.state.translateX = centerX - (highestKeypoint.x * currentScale);\n    this.state.translateY = centerY - (highestKeypoint.y * currentScale);\n\n    // 确保图像不会超出边界\n    this.constrainView();\n\n    this.updateZoomInfo();\n    this.render();\n\n    console.log(`视角已移动到标注点 #${highestKeypoint.order}，保持缩放: ${currentScale.toFixed(1)}x`);\n    return true;\n  }\n\n  /**\n   * 移动到预期位置（基于预览图中的参考位置）\n   * @param {boolean} isImageSwitch - 是否是图片切换触发的\n   */\n  async moveToExpectedPosition(isImageSwitch = false) {\n    if (!this.state.autoMoveToExpectedPosition) {\n      return; // 功能未开启\n    }\n\n    try {\n      if (isImageSwitch) {\n        // 图片切换时的逻辑：分析切换到的新图像\n        await this.handleImageSwitchAutoMove();\n      } else {\n        // 标注点创建后的逻辑：移动到下一个预期位置\n        await this.moveToNextExpectedPosition();\n      }\n    } catch (error) {\n      console.error('[自动切换] 移动到预期位置失败:', error);\n    }\n  }\n\n  /**\n   * 处理图片切换时的自动移动\n   */\n  async handleImageSwitchAutoMove() {\n    // 分析新图像（当前加载的图像）的标注情况\n    const newImageAnnotations = this.keypoints || [];\n\n    console.log(`[自动切换] 图片切换：新图像有 ${newImageAnnotations.length} 个标注点`);\n\n    if (newImageAnnotations.length === 0) {\n      // 情况1: 新图像没有标注，移动到1号点位置\n      console.log('[自动切换] 新图像没有标注，移动到1号点位置');\n      await this.moveToPosition1();\n    } else {\n      // 检查新图像的标注点是否都没有方向\n      const hasDirectionAnnotations = newImageAnnotations.some(kp =>\n        kp.direction !== null && kp.direction !== undefined &&\n        (typeof kp.direction === 'number' || kp.directionType === 'angle')\n      );\n\n      if (!hasDirectionAnnotations) {\n        // 情况2: 新图像有标注但都没有方向，移动到几何中心\n        console.log('[自动切换] 新图像有无方向标注，移动到几何中心');\n        this.moveToAnnotationsCenter();\n      } else {\n        // 情况3: 新图像有方向标注，保持当前位置不动\n        console.log('[自动切换] 新图像有方向标注，保持当前位置');\n      }\n    }\n  }\n\n  /**\n   * 移动到1号位置（从预览图获取）\n   */\n  async moveToPosition1() {\n    try {\n      // 获取分支点预览管理器\n      const branchPointPreviewManager = window.PlantAnnotationTool?.branchPointPreviewManager;\n      if (!branchPointPreviewManager) {\n        console.log('[自动切换] 预览管理器不可用，无法获取1号位置');\n        return;\n      }\n\n      // 获取1号位置\n      const position1 = await branchPointPreviewManager.getExpectedPosition(1);\n\n      if (position1) {\n        console.log(`[自动切换] 移动到1号位置: (${position1.x.toFixed(1)}, ${position1.y.toFixed(1)})`);\n\n        // 检查是否需要应用锁定倍数\n        const zoomSettings = typeof window.getZoomLockSettings === 'function' ? window.getZoomLockSettings() : { isLocked: false };\n\n        if (zoomSettings.isLocked) {\n          // 锁定状态：使用锁定倍数\n          this.state.scale = zoomSettings.lockValue;\n          console.log(`[自动切换] 应用锁定倍数: ${zoomSettings.lockValue}x`);\n        } else {\n          // 非锁定状态：保持当前倍数\n          console.log(`[自动切换] 保持当前倍数: ${this.state.scale.toFixed(1)}x`);\n        }\n\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n\n        // 计算新的位置\n        this.state.translateX = centerX - (position1.x * this.state.scale);\n        this.state.translateY = centerY - (position1.y * this.state.scale);\n\n        // 确保图像不会超出边界\n        this.constrainView();\n\n        this.updateZoomInfo();\n        this.render();\n\n        console.log(`[自动切换] 视角已移动到1号位置，缩放: ${this.state.scale.toFixed(1)}x`);\n      } else {\n        console.log(`[自动切换] 未找到1号位置的参考坐标`);\n      }\n    } catch (error) {\n      console.error('[自动切换] 移动到1号位置失败:', error);\n    }\n  }\n\n  /**\n   * 移动到所有标注点的几何中心\n   */\n  moveToAnnotationsCenter() {\n    const annotations = this.keypoints || [];\n    if (annotations.length === 0) {\n      return;\n    }\n\n    // 计算几何中心\n    let sumX = 0, sumY = 0;\n    for (const annotation of annotations) {\n      sumX += annotation.x;\n      sumY += annotation.y;\n    }\n\n    const centerX_img = sumX / annotations.length;\n    const centerY_img = sumY / annotations.length;\n\n    console.log(`[自动切换] 移动到标注点几何中心: (${centerX_img.toFixed(1)}, ${centerY_img.toFixed(1)}), 共${annotations.length}个标注点`);\n\n    // 检查是否需要应用锁定倍数\n    const zoomSettings = typeof window.getZoomLockSettings === 'function' ? window.getZoomLockSettings() : { isLocked: false };\n\n    if (zoomSettings.isLocked) {\n      // 锁定状态：使用锁定倍数\n      this.state.scale = zoomSettings.lockValue;\n      console.log(`[自动切换] 应用锁定倍数: ${zoomSettings.lockValue}x`);\n    } else {\n      // 非锁定状态：保持当前倍数\n      console.log(`[自动切换] 保持当前倍数: ${this.state.scale.toFixed(1)}x`);\n    }\n\n    const centerX = this.canvas.width / 2;\n    const centerY = this.canvas.height / 2;\n\n    // 计算新的位置\n    this.state.translateX = centerX - (centerX_img * this.state.scale);\n    this.state.translateY = centerY - (centerY_img * this.state.scale);\n\n    // 确保图像不会超出边界\n    this.constrainView();\n\n    this.updateZoomInfo();\n    this.render();\n\n    console.log(`[自动切换] 视角已移动到标注点几何中心，缩放: ${this.state.scale.toFixed(1)}x`);\n  }\n\n  /**\n   * 移动到下一个预期位置（原有逻辑）\n   */\n  async moveToNextExpectedPosition() {\n    try {\n      // 获取分支点预览管理器\n      const branchPointPreviewManager = window.PlantAnnotationTool?.branchPointPreviewManager;\n      if (!branchPointPreviewManager) {\n        console.log('[自动切换] 预览管理器不可用');\n        return;\n      }\n\n      // 获取下一个要标注的编号\n      const nextOrder = this.findNextAvailableOrder();\n\n      // 从预览管理器获取预期位置\n      const expectedPosition = await branchPointPreviewManager.getExpectedPosition(nextOrder);\n\n      if (expectedPosition) {\n        console.log(`[自动切换] 移动到预期位置: 编号${nextOrder}, 坐标(${expectedPosition.x.toFixed(1)}, ${expectedPosition.y.toFixed(1)})`);\n\n        // 检查是否需要应用锁定倍数\n        const zoomSettings = typeof window.getZoomLockSettings === 'function' ? window.getZoomLockSettings() : { isLocked: false };\n\n        if (zoomSettings.isLocked) {\n          // 锁定状态：使用锁定倍数\n          this.state.scale = zoomSettings.lockValue;\n          console.log(`[自动切换] 应用锁定倍数: ${zoomSettings.lockValue}x`);\n        } else {\n          // 非锁定状态：保持当前倍数\n          console.log(`[自动切换] 保持当前倍数: ${this.state.scale.toFixed(1)}x`);\n        }\n\n        const centerX = this.canvas.width / 2;\n        const centerY = this.canvas.height / 2;\n\n        // 计算新的位置\n        this.state.translateX = centerX - (expectedPosition.x * this.state.scale);\n        this.state.translateY = centerY - (expectedPosition.y * this.state.scale);\n\n        // 确保图像不会超出边界\n        this.constrainView();\n\n        this.updateZoomInfo();\n        this.render();\n\n        console.log(`[自动切换] 视角已移动到预期位置，缩放: ${this.state.scale.toFixed(1)}x`);\n      } else {\n        console.log(`[自动切换] 未找到编号${nextOrder}的预期位置`);\n      }\n    } catch (error) {\n      console.error('[自动切换] 移动到下一个预期位置失败:', error);\n    }\n  }\n\n  /**\n   * 尝试自动切换到下一张图片继续自动化\n   */\n  tryAutoSwitchToNextImage() {\n    // 检查是否有全局的图片导航功能\n    if (typeof window.navigateToNextImage === 'function') {\n      // 调用全局的下一张图片函数（自动化模式，不循环）\n      window.navigateToNextImage(true).then(success => {\n        if (success) {\n          // 切换成功，延迟一点时间等待图片加载，然后重新开始自动化\n          setTimeout(() => {\n            this.restartAutoDirectionMode();\n          }, 300);\n        } else {\n          // 没有下一张图片，结束自动化\n          console.log('没有更多图片，结束自动化');\n          this.exitAutoDirectionMode();\n          this.resetAutoDirectionButton();\n\n          if (window.showSuccess) {\n            window.showSuccess('全部完成', '所有图片的方向设置已完成！');\n          }\n        }\n      });\n      return true; // 表示已经处理了切换逻辑\n    }\n\n    // 如果没有全局导航函数，尝试模拟右箭头键\n    if (typeof window.handleKeyDown === 'function') {\n      const rightArrowEvent = {\n        key: 'ArrowRight',\n        preventDefault: () => {},\n        stopPropagation: () => {}\n      };\n\n      window.handleKeyDown(rightArrowEvent);\n\n      // 延迟一点时间等待图片切换，然后重新开始自动化\n      setTimeout(() => {\n        this.restartAutoDirectionMode();\n      }, 200);\n      return true;\n    }\n\n    return false; // 无法切换到下一张图片\n  }\n\n  /**\n   * 重新开始自动化方向设置模式（用于图片切换后）\n   */\n  restartAutoDirectionMode() {\n    console.log('[调试] 重新开始自动化方向设置模式');\n\n    // 清除当前状态\n    this.state.isAutoDirectionMode = false;\n    this.state.autoDirectionKeypoints = [];\n    this.state.autoDirectionIndex = 0;\n\n    // 重新启动自动化模式\n    const success = this.startAutoDirectionMode();\n    if (!success) {\n      // 如果新图片没有需要设置方向的点，结束自动化\n      console.log('新图片没有需要设置方向的标注点，结束自动化');\n      this.exitAutoDirectionMode();\n      this.resetAutoDirectionButton();\n\n      if (window.showInfo) {\n        window.showInfo('自动化完成', '已完成所有图片的方向设置');\n      }\n    }\n  }\n\n  /**\n   * 重置自动化方向选择按钮状态\n   */\n  resetAutoDirectionButton() {\n    const autoDirectionBtn = document.getElementById('auto-direction-btn');\n    if (autoDirectionBtn) {\n      console.log('[调试] 重置按钮状态为正常模式');\n\n      // 移除暂停模式的事件监听器\n      if (autoDirectionBtn._pauseHandler) {\n        autoDirectionBtn.removeEventListener('click', autoDirectionBtn._pauseHandler);\n        autoDirectionBtn._pauseHandler = null;\n      }\n\n      // 更新按钮外观\n      autoDirectionBtn.textContent = 'Auto Direction';\n      autoDirectionBtn.classList.remove('active');\n\n      // 重新添加原始的点击事件\n      if (window.handleAutoDirectionSelection) {\n        autoDirectionBtn.addEventListener('click', window.handleAutoDirectionSelection);\n      }\n    }\n  }\n\n  /**\n   * 暂停自动化方向升级模式\n   */\n  pauseAutoDirectionMode() {\n    if (!this.state.isAutoDirectionMode) return;\n\n    const remaining = this.state.autoDirectionKeypoints.length - this.state.autoDirectionIndex;\n    const completed = this.state.autoDirectionIndex;\n\n    this.exitAutoDirectionMode();\n\n    // 重置按钮状态\n    this.resetAutoDirectionButton();\n\n    console.log(`方向升级模式已暂停，已完成 ${completed} 个，剩余 ${remaining} 个`);\n\n    // 显示暂停提示\n    if (window.showInfo) {\n      window.showInfo('升级暂停', `已完成 ${completed} 个标注点的升级，剩余 ${remaining} 个。可重新点击\"自动化方向选择\"继续。`);\n    }\n  }\n\n  /**\n   * 开始自定义标注拖拽\n   */\n  startCustomAnnotationDrag(annotation, mousePos) {\n    if (!this.customAnnotationRenderer) return;\n    \n    this.customAnnotationDragState.isDragging = true;\n    this.customAnnotationDragState.draggedAnnotation = annotation;\n    this.customAnnotationDragState.startPosition = mousePos;\n    \n    // 通知渲染器开始拖拽\n    this.customAnnotationRenderer.startDrag(annotation, mousePos);\n    \n    this.canvas.style.cursor = 'grabbing';\n    console.log('Started custom annotation drag:', annotation.id);\n  }\n  \n  /**\n   * 更新自定义标注拖拽\n   */\n  updateCustomAnnotationDrag(mousePos) {\n    if (!this.customAnnotationRenderer || !this.customAnnotationDragState.isDragging) return;\n    \n    // 更新拖拽位置\n    const updated = this.customAnnotationRenderer.updateDrag(mousePos);\n    \n    if (updated) {\n      this.render();\n    }\n  }\n  \n  /**\n   * 完成自定义标注拖拽\n   */\n  finishCustomAnnotationDrag() {\n    if (!this.customAnnotationRenderer || !this.customAnnotationDragState.isDragging) return;\n    \n    // 完成拖拽\n    const result = this.customAnnotationRenderer.finishDrag();\n    \n    if (result && result.moved) {\n      // 标注被移动了，触发保存和同步\n      this.customAnnotationManager.saveToStorage();\n      \n      // 触发更新事件\n      this.customAnnotationManager.triggerEvent('onAnnotationUpdate', result.annotation);\n      \n      // 实时同步\n      this.customAnnotationManager.triggerCustomAnnotationUpdateSync(result.annotation, {\n        imageId: this.getAppState()?.currentImage?.id,\n        positionChange: {\n          from: result.startPosition,\n          to: {\n            x: result.annotation.x,\n            y: result.annotation.y\n          }\n        },\n        timestamp: new Date().toISOString()\n      });\n      \n      // 🔧 FIX: 更新预览区域 - 同步分支点预览\n      this.syncBranchPointPreview();\n      \n      console.log('Custom annotation dragged and saved:', result.annotation.id);\n    }\n    \n    // 清除拖拽状态\n    this.customAnnotationDragState.isDragging = false;\n    this.customAnnotationDragState.draggedAnnotation = null;\n    this.customAnnotationDragState.startPosition = null;\n    \n    this.canvas.style.cursor = 'crosshair';\n    this.render();\n  }\n  \n  /**\n   * 取消自定义标注拖拽\n   */\n  cancelCustomAnnotationDrag() {\n    if (!this.customAnnotationRenderer || !this.customAnnotationDragState.isDragging) return;\n    \n    // 取消拖拽\n    this.customAnnotationRenderer.cancelDrag();\n    \n    // 清除拖拽状态\n    this.customAnnotationDragState.isDragging = false;\n    this.customAnnotationDragState.draggedAnnotation = null;\n    this.customAnnotationDragState.startPosition = null;\n    \n    this.canvas.style.cursor = 'crosshair';\n    this.render();\n    \n    console.log('Cancelled custom annotation drag');\n  }\n  \n  /**\n   * 获取应用状态\n   */\n  getAppState() {\n    return window.PlantAnnotationTool?.appState;\n  }\n  \n  /**\n   * 初始化自定义标注系统\n   */\n  async initializeCustomAnnotationSystem() {\n    try {\n      // 动态导入自定义标注管理器\n      const { CustomAnnotationManager } = await import('./CustomAnnotationManager.js');\n      this.customAnnotationManager = new CustomAnnotationManager(this);\n      \n      // 🔄 NEW: 设置实时同步管理器\n      const realTimeSyncManager = window.PlantAnnotationTool?.realTimeSyncManager;\n      if (realTimeSyncManager) {\n        this.customAnnotationManager.setRealTimeSyncManager(realTimeSyncManager);\n        console.log('Custom annotation real-time sync manager connected');\n      } else {\n        console.warn('Real-time sync manager not available for custom annotations');\n      }\n      \n      // 🔧 NEW: 添加模式变化监听器同步分支点预览\n      this.customAnnotationManager.addEventListener('onModeChange', (data) => {\n        console.log('Mode changed:', data.mode, 'Type:', data.typeId);\n        this.syncBranchPointPreview();\n      });\n      \n      console.log('CustomAnnotationManager initialized');\n      \n      // 动态导入自定义标注渲染器\n      const { CustomAnnotationRenderer } = await import('./CustomAnnotationRenderer.js');\n      this.customAnnotationRenderer = new CustomAnnotationRenderer(this, this.customAnnotationManager);\n      console.log('CustomAnnotationRenderer initialized');\n      \n      // 标记系统已就绪\n      this.customAnnotationSystemReady = true;\n      \n      // 通知系统自定义标注系统已准备就绪\n      if (window.onCustomAnnotationSystemReady && typeof window.onCustomAnnotationSystemReady === 'function') {\n        setTimeout(() => {\n          window.onCustomAnnotationSystemReady();\n        }, 100); // 给一个小延迟确保完全初始化\n      }\n      \n    } catch (error) {\n      console.warn('Failed to initialize custom annotation system:', error);\n    }\n  }\n\n  /**\n   * 渲染自定义标注（统一版本）\n   * 注意：在统一系统中，自定义标注已经集成到keypoints数组中，\n   * 并通过renderKeypoints方法统一渲染，此方法仅保留兼容性\n   */\n  renderCustomAnnotations() {\n    // 在统一系统中，自定义标注已经通过 renderKeypoints() 方法渲染\n    // 这里保留方法以维持兼容性，但不执行任何操作\n    console.debug('renderCustomAnnotations called (unified system - no action needed)');\n  }\n\n  /**\n   * 获取指定位置的自定义标注（统一版本）\n   */\n  getCustomAnnotationAt(mousePos) {\n    // 在统一系统中，自定义标注存储在keypoints数组中\n    const threshold = this.options.baseKeypointRadius + 5;\n    \n    return this.keypoints.find(keypoint => {\n      // 只检查自定义标注\n      if (keypoint.annotationType !== 'custom') return false;\n      \n      const keypointScreen = this.imageToScreen(keypoint.x, keypoint.y);\n      \n      if (keypoint.width && keypoint.height) {\n        // 区域标注 - 检查是否在矩形区域内\n        const bottomRight = this.imageToScreen(keypoint.x + keypoint.width, keypoint.y + keypoint.height);\n        return mousePos.x >= keypointScreen.x && mousePos.x <= bottomRight.x &&\n               mousePos.y >= keypointScreen.y && mousePos.y <= bottomRight.y;\n      } else {\n        // 点标注 - 检查距离\n        const distance = Math.sqrt(\n          Math.pow(mousePos.x - keypointScreen.x, 2) +\n          Math.pow(mousePos.y - keypointScreen.y, 2)\n        );\n        return distance <= threshold;\n      }\n    }) || null;\n  }\n\n  /**\n   * 处理自定义标注点击（统一版本）\n   */\n  handleCustomAnnotationClick(customAnnotation, mousePos) {\n    // 在统一系统中，自定义标注点击处理与常规标注相同\n    console.log('Custom annotation clicked:', customAnnotation.id, 'type:', customAnnotation.annotationType);\n    \n    // 可以在这里添加自定义标注特有的点击逻辑\n    // 例如显示自定义标注的详细信息\n    const customType = this.getCustomType(customAnnotation.customTypeId);\n    if (customType) {\n      console.log('Custom type:', customType.name, 'color:', customType.color);\n    }\n  }\n\n  /**\n   * 处理自定义标注模式下的点击\n   */\n  handleCustomAnnotationMode(mousePos) {\n    if (!this.customAnnotationManager) {\n      console.warn('Custom annotation manager not available');\n      return;\n    }\n    \n    // 🔧 NEW: 进入自定义标注模式时中断所有方向相关模式\n    this.interruptAllDirectionModes('custom_annotation_mode');\n    \n    try {\n      const appState = window.PlantAnnotationTool?.appState;\n      const currentImageId = appState?.currentImage?.id;\n      \n      if (!currentImageId) {\n        console.warn('No current image ID available for custom annotation');\n        return;\n      }\n      \n      const customType = this.customAnnotationManager.getCurrentCustomType();\n      if (!customType) {\n        console.warn('No custom type selected');\n        return;\n      }\n      \n      if (customType.type === 'region') {\n        // 区域类型：开始拖拽\n        this.startCustomRegionDrag(mousePos);\n      } else if (customType.type === 'point') {\n        // 点类型：使用统一系统直接创建点\n        const imagePos = this.screenToImage(mousePos.x, mousePos.y);\n        \n        // 🔧 FIX: 使用统一系统方法创建自定义点标注\n        const keypoint = this.addCustomPointAnnotation(imagePos.x, imagePos.y, customType.id);\n        \n        if (keypoint) {\n          console.log('Created unified custom point annotation:', keypoint);\n          // 渲染已经在addCustomPointAnnotation中触发\n        } else {\n          console.warn('Failed to create custom point annotation');\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to handle custom annotation mode:', error);\n    }\n  }\n\n  /**\n   * 开始自定义区域拖拽\n   */\n  startCustomRegionDrag(mousePos) {\n    if (!this.canCreateAnnotationAt(mousePos.x, mousePos.y)) {\n      console.warn('Cannot create custom region annotation: position is outside valid area');\n      return;\n    }\n\n    this.state.isCustomRegionDragging = true;\n    this.state.customRegionStartPoint = mousePos;\n    this.state.customRegionCurrentPoint = mousePos;\n    this.canvas.style.cursor = 'crosshair';\n    \n    console.log('Started custom region drag at:', mousePos);\n  }\n\n  /**\n   * 更新自定义区域拖拽\n   */\n  updateCustomRegionDrag(mousePos) {\n    if (!this.state.isCustomRegionDragging) return;\n    \n    this.state.customRegionCurrentPoint = mousePos;\n    this.render(); // 重新渲染以显示拖拽预览\n  }\n\n  /**\n   * 完成自定义区域拖拽\n   */\n  finishCustomRegionDrag() {\n    if (!this.state.isCustomRegionDragging || !this.state.customRegionStartPoint || !this.state.customRegionCurrentPoint) {\n      this.resetCustomRegionDrag();\n      return;\n    }\n\n    const startPos = this.screenToImage(this.state.customRegionStartPoint.x, this.state.customRegionStartPoint.y);\n    const endPos = this.screenToImage(this.state.customRegionCurrentPoint.x, this.state.customRegionCurrentPoint.y);\n\n    // 检查拖拽距离是否足够\n    const width = Math.abs(endPos.x - startPos.x);\n    const height = Math.abs(endPos.y - startPos.y);\n    const minSize = 10; // 最小区域尺寸\n\n    if (width < minSize || height < minSize) {\n      console.log('Region too small, ignoring');\n      this.resetCustomRegionDrag();\n      return;\n    }\n\n    // 获取当前图像ID\n    const appState = window.PlantAnnotationTool?.appState;\n    const imageId = appState?.currentImage?.id;\n\n    if (!imageId) {\n      console.warn('No current image ID available for custom region annotation');\n      this.resetCustomRegionDrag();\n      return;\n    }\n\n    // 创建区域标注\n    try {\n      const currentCustomType = this.customAnnotationManager.getCurrentCustomType();\n      if (!currentCustomType) {\n        console.warn('No custom type selected for region annotation');\n        this.resetCustomRegionDrag();\n        return;\n      }\n      \n      // 计算区域位置\n      const x = Math.min(startPos.x, endPos.x);\n      const y = Math.min(startPos.y, endPos.y);\n      \n      // 🔧 FIX: 使用统一系统方法创建自定义区域标注\n      const keypoint = this.addCustomRegionAnnotation(x, y, width, height, currentCustomType.id);\n      \n      if (keypoint) {\n        console.log('Created unified custom region annotation:', keypoint);\n        // 渲染已经在addCustomRegionAnnotation中触发\n      } else {\n        console.warn('Failed to create custom region annotation');\n      }\n    } catch (error) {\n      console.error('Error creating custom region annotation:', error);\n    }\n\n    this.resetCustomRegionDrag();\n  }\n\n  /**\n   * 重置自定义区域拖拽状态\n   */\n  resetCustomRegionDrag() {\n    this.state.isCustomRegionDragging = false;\n    this.state.customRegionStartPoint = null;\n    this.state.customRegionCurrentPoint = null;\n    this.canvas.style.cursor = 'crosshair';\n    this.render();\n  }\n\n  /**\n   * 删除自定义标注（统一版本）\n   * @param {Object} customAnnotation - 要删除的自定义标注 keypoint\n   */\n  removeCustomAnnotation(customAnnotation) {\n    // 在统一系统中，自定义标注也是keypoint，直接调用removeKeypoint\n    this.removeKeypoint(customAnnotation);\n  }\n\n  /**\n   * 获取自定义标注管理器\n   */\n  getCustomAnnotationManager() {\n    return this.customAnnotationManager;\n  }\n\n  /**\n   * 获取自定义标注渲染器\n   */\n  getCustomAnnotationRenderer() {\n    return this.customAnnotationRenderer;\n  }\n\n  // 🔧 NEW: Multi-Direction Annotation Methods\n  \n  /**\n   * 处理中键点击 - 进入/退出方向数量选择模式\n   */\n  handleMiddleMouseButton(mousePos) {\n    // 只有在选中了标注点时才允许进入方向数量模式\n    if (!this.state.selectedKeypoint) {\n      console.log('[多方向] 未选中标注点，忽略中键点击');\n      return;\n    }\n\n    if (this.state.isDirectionCountMode) {\n      // 退出方向数量模式并应用选择的方向数量\n      this.exitDirectionCountMode();\n    } else {\n      // 进入方向数量模式\n      this.enterDirectionCountMode();\n    }\n  }\n\n  /**\n   * 进入方向数量选择模式\n   */\n  enterDirectionCountMode() {\n    console.log('[多方向] 进入方向数量选择模式');\n    \n    this.state.isDirectionCountMode = true;\n    this.state.currentDirectionCount = this.state.selectedKeypoint.maxDirections || 1;\n    \n    // 显示提示信息\n    this.showDirectionCountPrompt('使用滚轮调整方向数量，再次按中键确认');\n    \n    // 改变光标样式\n    this.canvas.style.cursor = 'help';\n  }\n\n  /**\n   * 退出方向数量选择模式\n   */\n  exitDirectionCountMode() {\n    console.log('[多方向] 退出方向数量选择模式，应用方向数量:', this.state.currentDirectionCount);\n    \n    // 应用选择的方向数量到当前标注点\n    if (this.state.selectedKeypoint) {\n      // 🔧 BUG FIX: 确保标注点具有多方向支持\n      this.ensureMultiDirectionSupport(this.state.selectedKeypoint);\n      \n      this.state.selectedKeypoint.maxDirections = this.state.currentDirectionCount;\n      \n      // 如果新的方向数量小于已有方向数量，需要截断\n      if (this.state.selectedKeypoint.directions.length > this.state.currentDirectionCount) {\n        this.state.selectedKeypoint.directions = this.state.selectedKeypoint.directions.slice(0, this.state.currentDirectionCount);\n        console.log('[多方向] 截断directions数组到', this.state.currentDirectionCount, '个');\n      }\n    }\n    \n    this.state.isDirectionCountMode = false;\n    this.hideDirectionCountPrompt();\n    \n    // 恢复光标样式\n    this.canvas.style.cursor = 'crosshair';\n    \n    // 开始设置方向\n    this.startMultiDirectionSetting();\n  }\n\n  /**\n   * 处理滚轮调整方向数量\n   */\n  handleScrollWheel(event) {\n    if (!this.state.isDirectionCountMode) {\n      return;\n    }\n\n    const delta = -event.deltaY;\n    const direction = delta > 0 ? 1 : -1;\n    \n    // 调整方向数量（限制在1-8之间）\n    const newCount = Math.max(1, Math.min(8, this.state.currentDirectionCount + direction));\n    \n    if (newCount !== this.state.currentDirectionCount) {\n      this.state.currentDirectionCount = newCount;\n      this.updateDirectionCountDisplay();\n      console.log('[多方向] 方向数量调整为:', newCount);\n    }\n  }\n\n  /**\n   * 显示方向数量提示\n   */\n  showDirectionCountPrompt(message) {\n    // 创建或更新提示框\n    let prompt = document.getElementById('direction-count-prompt');\n    if (!prompt) {\n      prompt = document.createElement('div');\n      prompt.id = 'direction-count-prompt';\n      prompt.style.cssText = `\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        background: rgba(0, 0, 0, 0.8);\n        color: white;\n        padding: 15px 20px;\n        border-radius: 8px;\n        font-size: 14px;\n        z-index: 10000;\n        pointer-events: none;\n        font-family: Arial, sans-serif;\n      `;\n      document.body.appendChild(prompt);\n    }\n    \n    prompt.innerHTML = `\n      <div style=\"margin-bottom: 8px;\">${message}</div>\n      <div style=\"font-size: 18px; font-weight: bold; text-align: center;\">\n        方向数量: ${this.state.currentDirectionCount}\n      </div>\n    `;\n  }\n\n  /**\n   * 隐藏方向数量提示\n   */\n  hideDirectionCountPrompt() {\n    const prompt = document.getElementById('direction-count-prompt');\n    if (prompt) {\n      prompt.remove();\n    }\n  }\n\n  /**\n   * 更新方向数量显示\n   */\n  updateDirectionCountDisplay() {\n    const prompt = document.getElementById('direction-count-prompt');\n    if (prompt) {\n      prompt.innerHTML = `\n        <div style=\"margin-bottom: 8px;\">使用滚轮调整方向数量，再次按中键确认</div>\n        <div style=\"font-size: 18px; font-weight: bold; text-align: center;\">\n          方向数量: ${this.state.currentDirectionCount}\n        </div>\n      `;\n    }\n  }\n\n  /**\n   * 开始多方向设置\n   */\n  startMultiDirectionSetting() {\n    if (!this.state.selectedKeypoint) {\n      return;\n    }\n\n    // 🔧 FIX: Initialize counter based on existing directions\n    this.state.directionsSet = this.state.selectedKeypoint.directions.length;\n    this.state.isDirectionSelectionMode = true;\n    \n    // 显示进度提示\n    this.showMultiDirectionProgress();\n    \n    console.log(`[多方向] 开始设置 ${this.state.selectedKeypoint.maxDirections} 个方向 (已有 ${this.state.directionsSet} 个)`);\n  }\n\n  /**\n   * 显示多方向设置进度\n   */\n  showMultiDirectionProgress() {\n    const keypoint = this.state.selectedKeypoint;\n    if (!keypoint) return;\n    \n    // 🔧 FIX: Use actual directions count for accuracy\n    const actualDirections = keypoint.directions.length;\n    const progress = `${actualDirections}/${keypoint.maxDirections}`;\n    \n    let message;\n    if (actualDirections >= keypoint.maxDirections) {\n      message = `所有方向已设置完成 ${progress}`;\n    } else {\n      message = `设置方向 ${progress} - 点击设置第 ${actualDirections + 1} 个方向`;\n    }\n    \n    // 更新或创建进度提示\n    let progressPrompt = document.getElementById('multi-direction-progress');\n    if (!progressPrompt) {\n      progressPrompt = document.createElement('div');\n      progressPrompt.id = 'multi-direction-progress';\n      progressPrompt.style.cssText = `\n        position: fixed;\n        top: 20px;\n        right: 20px;\n        background: rgba(16, 185, 129, 0.9);\n        color: white;\n        padding: 10px 15px;\n        border-radius: 6px;\n        font-size: 13px;\n        z-index: 10000;\n        pointer-events: none;\n        font-family: Arial, sans-serif;\n      `;\n      document.body.appendChild(progressPrompt);\n    }\n    \n    progressPrompt.textContent = message;\n    \n    // 🔧 FIX: Auto-hide progress when all directions are set\n    if (actualDirections >= keypoint.maxDirections) {\n      setTimeout(() => {\n        this.hideMultiDirectionProgress();\n      }, 2000); // Hide after 2 seconds\n    }\n  }\n\n  /**\n   * 隐藏多方向设置进度\n   */\n  hideMultiDirectionProgress() {\n    const progressPrompt = document.getElementById('multi-direction-progress');\n    if (progressPrompt) {\n      progressPrompt.remove();\n    }\n  }\n\n  /**\n   * 添加方向到标注点\n   */\n  addDirectionToKeypoint(keypoint, direction) {\n    // 🔧 BUG FIX: 确保标注点具有多方向支持\n    this.ensureMultiDirectionSupport(keypoint);\n    \n    if (keypoint.directions.length >= keypoint.maxDirections) {\n      console.warn('[多方向] 已达到最大方向数量:', keypoint.maxDirections);\n      return false;\n    }\n    \n    keypoint.directions.push(direction);\n    console.log('[多方向] 添加方向成功:', direction, '到keypoint #' + keypoint.order);\n    return true;\n  }\n\n  /**\n   * 从标注点移除方向\n   */\n  removeDirectionFromKeypoint(keypoint, index) {\n    // 🔧 BUG FIX: 确保标注点具有多方向支持\n    this.ensureMultiDirectionSupport(keypoint);\n    \n    if (index < 0 || index >= keypoint.directions.length) {\n      console.warn('[多方向] 无效的方向索引:', index);\n      return false;\n    }\n    \n    const removedDirection = keypoint.directions[index];\n    keypoint.directions.splice(index, 1);\n    console.log('[多方向] 移除方向成功:', removedDirection, '从keypoint #' + keypoint.order);\n    return true;\n  }\n\n  /**\n   * 完成多方向设置\n   */\n  finishMultiDirectionSetting() {\n    console.log('[多方向] 完成多方向设置');\n    \n    // 清理UI提示\n    this.hideMultiDirectionProgress();\n    \n    // 🔧 FIX: Ensure state consistency before cleanup\n    if (this.state.selectedKeypoint) {\n      // Sync counter with actual directions\n      this.state.directionsSet = this.state.selectedKeypoint.directions.length;\n      \n      // 🔧 FIX: Verify completion state\n      const isComplete = this.state.selectedKeypoint.directions.length >= this.state.selectedKeypoint.maxDirections;\n      console.log(`[多方向] 设置状态: ${this.state.selectedKeypoint.directions.length}/${this.state.selectedKeypoint.maxDirections} (${isComplete ? '完成' : '未完成'})`);\n    }\n    \n    // 重置状态\n    this.state.isDirectionSelectionMode = false;\n    this.state.directionsSet = 0;\n    this.state.selectedKeypoint = null;\n    \n    // 恢复光标样式\n    this.canvas.style.cursor = 'crosshair';\n    \n    // 保存状态\n    this.saveState();\n    this.autoSaveCurrentImage();\n    \n    // 同步分支点预览\n    this.syncBranchPointPreview();\n    \n    // 自动切换到预期位置\n    this.moveToNextExpectedPosition();\n    \n    console.log('[多方向] 多方向设置完成');\n  }\n\n  /**\n   * 中断方向数量模式\n   */\n  interruptDirectionCountMode(reason) {\n    if (this.state.isDirectionCountMode) {\n      console.log('[多方向] 方向数量模式被中断:', reason);\n      \n      this.state.isDirectionCountMode = false;\n      this.state.currentDirectionCount = 1;\n      this.state.selectedKeypoint = null;\n      \n      this.hideDirectionCountPrompt();\n      this.hideMultiDirectionProgress();\n      \n      // 恢复光标样式\n      this.canvas.style.cursor = 'crosshair';\n    }\n  }\n\n  /**\n   * 中断多方向设置模式\n   */\n  interruptMultiDirectionSetting(reason) {\n    if (this.state.isDirectionSelectionMode && this.state.selectedKeypoint && this.state.selectedKeypoint.maxDirections > 1) {\n      console.log('[多方向] 多方向设置被中断:', reason);\n      \n      // 🔧 FIX: Ensure progress display is properly cleaned up\n      this.hideMultiDirectionProgress();\n      \n      // 重置状态\n      this.state.isDirectionSelectionMode = false;\n      this.state.directionsSet = 0;\n      this.state.selectedKeypoint = null;\n      \n      // 恢复光标样式\n      this.canvas.style.cursor = 'crosshair';\n      \n      // 重新渲染以清除任何视觉提示\n      this.render();\n    }\n  }\n\n  /**\n   * 中断所有方向相关模式\n   */\n  interruptAllDirectionModes(reason) {\n    console.log('[多方向] 中断所有方向模式:', reason);\n    \n    // 中断方向数量模式\n    this.interruptDirectionCountMode(reason);\n    \n    // 中断多方向设置模式\n    this.interruptMultiDirectionSetting(reason);\n    \n    // 🔧 FIX: Handle auto direction mode preservation BEFORE calling cancelDirectionSelection\n    // Cross-sectional mode needs to persist across image switches\n    if (this.state.isAutoDirectionMode) {\n      if (this.autoDirectionMode === 'cross-sectional' && reason === 'image_switch') {\n        // For cross-sectional mode during image switch, only clear current selection\n        // but preserve the overall cross-sectional state and progress\n        console.log('[Cross-Sectional] Preserving cross-sectional mode during image switch');\n        this.state.selectedKeypoint = null;\n        this.state.isDirectionSelectionMode = false;\n        this.state.directionSelectionPoint = null;\n        // Return early to avoid calling cancelDirectionSelection with forceExit\n        return;\n      } else if (this.autoDirectionMode === 'cross-sectional' && reason === 'custom_annotation_mode') {\n        // For cross-sectional mode when entering custom annotation, only pause\n        console.log('[Cross-Sectional] Pausing cross-sectional mode for custom annotation');\n        this.state.selectedKeypoint = null;\n        this.state.isDirectionSelectionMode = false;\n        this.state.directionSelectionPoint = null;\n        // Return early to avoid calling cancelDirectionSelection with forceExit\n        return;\n      } else {\n        // For other cases or longitudinal mode, exit completely\n        // This includes plant_switch which should exit cross-sectional mode\n        this.exitAutoDirectionMode();\n      }\n    }\n    \n    // 中断常规方向选择模式 (only if we didn't return early above)\n    if (this.state.isDirectionSelectionMode) {\n      this.cancelDirectionSelection(true);\n    }\n  }\n\n  /**\n   * 检查标注点是否可以有多个方向\n   */\n  canHaveMultipleDirections(keypoint) {\n    return keypoint && keypoint.annotationType === 'regular';\n  }\n\n  /**\n   * 🔧 BUG FIX: 确保标注点具有多方向支持的必要属性\n   */\n  ensureMultiDirectionSupport(keypoint) {\n    if (!keypoint) return;\n    \n    // 确保directions数组存在\n    if (!keypoint.directions) {\n      keypoint.directions = [];\n      \n      // 如果有旧的单方向数据，迁移到新格式\n      if (keypoint.direction !== null && keypoint.direction !== undefined) {\n        if (typeof keypoint.direction === 'number') {\n          keypoint.directions.push({ angle: keypoint.direction, type: 'angle' });\n        } else if (keypoint.direction === 'left') {\n          keypoint.directions.push({ angle: 180, type: 'angle' });\n        } else if (keypoint.direction === 'right') {\n          keypoint.directions.push({ angle: 0, type: 'angle' });\n        }\n        console.log('[多方向] 迁移单方向数据到新格式:', keypoint.direction, '→', keypoint.directions);\n      }\n    }\n    \n    // 确保maxDirections属性存在\n    if (!keypoint.maxDirections) {\n      keypoint.maxDirections = Math.max(1, keypoint.directions.length);\n      console.log('[多方向] 初始化maxDirections为', keypoint.maxDirections, 'for keypoint #' + keypoint.order);\n    }\n    \n    // 确保annotationType存在\n    if (!keypoint.annotationType) {\n      keypoint.annotationType = 'regular';\n    }\n  }\n\n  /**\n   * 渲染多个方向箭头\n   */\n  renderMultipleDirections(keypoint) {\n    // 🔧 BUG FIX: 确保标注点具有多方向支持\n    this.ensureMultiDirectionSupport(keypoint);\n    \n    // 如果没有方向数据，不渲染\n    if (keypoint.directions.length === 0) {\n      return;\n    }\n\n    const screenPos = this.imageToScreen(keypoint.x, keypoint.y);\n    \n    keypoint.directions.forEach((direction, index) => {\n      const angleDegrees = direction.angle;\n      const directionText = `${(index + 1)}/${keypoint.directions.length}`;\n      \n      // 渲染方向箭头，使用不同的颜色或样式来区分\n      this.renderDirectionArrow(screenPos.x, screenPos.y, angleDegrees, directionText, keypoint);\n    });\n  }\n\n  /**\n   * 渲染方向箭头（改进版 - 支持多方向显示）\n   */\n  renderDirectionArrow(x, y, angleDegrees, directionText, keypoint) {\n    const angleRadians = angleDegrees * Math.PI / 180;\n    const arrowLength = this.options.directionArrowLength;\n\n    // 计算箭头终点\n    const endX = x + Math.cos(angleRadians) * arrowLength;\n    const endY = y + Math.sin(angleRadians) * arrowLength;\n\n    // 绘制虚线主线\n    this.ctx.strokeStyle = '#10b981'; // 绿色\n    this.ctx.lineWidth = 3;\n    this.ctx.setLineDash([8, 4]); // 虚线样式\n    this.ctx.lineCap = 'round';\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(x, y);\n    this.ctx.lineTo(endX, endY);\n    this.ctx.stroke();\n\n    // 重置虚线样式\n    this.ctx.setLineDash([]);\n\n    // 绘制箭头头部（实线）\n    const headAngle1 = angleRadians + Math.PI * 0.8;\n    const headAngle2 = angleRadians - Math.PI * 0.8;\n    const headLength = 15;\n\n    this.ctx.strokeStyle = '#10b981';\n    this.ctx.lineWidth = 3;\n    this.ctx.lineCap = 'round';\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(endX, endY);\n    this.ctx.lineTo(endX + Math.cos(headAngle1) * headLength, endY + Math.sin(headAngle1) * headLength);\n    this.ctx.moveTo(endX, endY);\n    this.ctx.lineTo(endX + Math.cos(headAngle2) * headLength, endY + Math.sin(headAngle2) * headLength);\n    this.ctx.stroke();\n\n    // 绘制方向文本（带背景）\n    const textOffset = 20;\n    const textX = endX + Math.cos(angleRadians) * textOffset;\n    const textY = endY + Math.sin(angleRadians) * textOffset;\n\n    // 测量文本尺寸\n    this.ctx.font = 'bold 11px Arial';\n    const textMetrics = this.ctx.measureText(directionText);\n    const textWidth = textMetrics.width;\n    const textHeight = 11;\n\n    // 绘制文本背景\n    this.ctx.fillStyle = 'rgba(16, 185, 129, 0.9)';\n    this.ctx.fillRect(textX - textWidth/2 - 3, textY - textHeight/2 - 2, textWidth + 6, textHeight + 4);\n\n    // 绘制文本\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(directionText, textX, textY);\n  }\n\n  /**\n   * 🔧 NEW: Enhanced direction data structure with click coordinates\n   */\n  enhanceDirectionData(keypoint, clickData) {\n    return {\n      ...keypoint,\n      directionClick: {\n        x: clickData.clickX,\n        y: clickData.clickY,\n        screenX: clickData.screenX,\n        screenY: clickData.screenY,\n        timestamp: clickData.timestamp\n      }\n    };\n  }\n\n  /**\n   * 🔧 NEW: Enhanced multi-direction data structure with click coordinates\n   */\n  enhanceMultiDirectionData(keypoint, clickDataArray) {\n    const enhancedDirections = keypoint.directions.map((direction, index) => {\n      const clickData = clickDataArray[index];\n      return {\n        ...direction,\n        clickPosition: clickData ? {\n          x: clickData.clickX,\n          y: clickData.clickY,\n          screenX: clickData.screenX,\n          screenY: clickData.screenY,\n          timestamp: clickData.timestamp\n        } : null\n      };\n    });\n\n    return {\n      ...keypoint,\n      directions: enhancedDirections\n    };\n  }\n\n  /**\n   * 🔧 NEW: Handle direction selection click with coordinate recording\n   */\n  handleDirectionSelectionClick(event) {\n    if (!this.state.selectedKeypoint || !this.state.isDirectionSelectionMode) {\n      return;\n    }\n\n    const screenCoords = this.getEventCoordinates(event);\n    const imageCoords = this.screenToImage(screenCoords.x, screenCoords.y);\n    \n    // Validate click coordinates\n    if (!this.validateDirectionClick(this.state.selectedKeypoint, {\n      clickX: imageCoords.x,\n      clickY: imageCoords.y,\n      screenX: screenCoords.x,\n      screenY: screenCoords.y\n    })) {\n      return;\n    }\n\n    // Calculate angle from keypoint to click position\n    const angle = this.calculateAngleFromClick(this.state.selectedKeypoint, imageCoords);\n    \n    // Record click data\n    const clickData = {\n      x: imageCoords.x,\n      y: imageCoords.y,\n      screenX: screenCoords.x,\n      screenY: screenCoords.y,\n      timestamp: Date.now()\n    };\n\n    // Update keypoint with direction and click data\n    this.state.selectedKeypoint.direction = angle;\n    this.state.selectedKeypoint.directionType = 'angle';\n    this.state.selectedKeypoint.directionClick = clickData;\n\n    // Trigger UI update\n    this.render();\n    \n    // Exit direction selection mode\n    this.state.isDirectionSelectionMode = false;\n    this.state.selectedKeypoint = null;\n  }\n\n  /**\n   * 🔧 NEW: Validate direction click coordinates\n   */\n  validateDirectionClick(keypoint, clickData) {\n    // Check if click is within image bounds\n    if (!this.isClickWithinImageBounds(clickData)) {\n      return false;\n    }\n\n    // Check if click is within canvas bounds\n    if (!this.isClickWithinCanvasBounds(clickData)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * 🔧 NEW: Calculate angle from keypoint to click position\n   */\n  calculateAngleFromClick(keypoint, clickPosition) {\n    const deltaX = clickPosition.x - keypoint.x;\n    const deltaY = clickPosition.y - keypoint.y;\n    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;\n    return (angle + 360) % 360;\n  }\n\n  /**\n   * 🔧 NEW: Check if click is within canvas bounds\n   */\n  isClickWithinCanvasBounds(clickData) {\n    return clickData.screenX >= 0 && clickData.screenX <= this.canvas.width &&\n           clickData.screenY >= 0 && clickData.screenY <= this.canvas.height;\n  }\n\n  /**\n   * 🔧 NEW: Check if click is within image bounds\n   */\n  isClickWithinImageBounds(clickData) {\n    if (!this.currentImage) return false;\n    \n    return clickData.x >= 0 && clickData.x <= this.currentImage.width &&\n           clickData.y >= 0 && clickData.y <= this.currentImage.height;\n  }\n\n  /**\n   * 🔧 NEW: Convert screen coordinates to image coordinates\n   */\n  screenToImage(screenX, screenY) {\n    const imageX = (screenX - this.state.translateX) / this.state.scale;\n    const imageY = (screenY - this.state.translateY) / this.state.scale;\n    return { x: imageX, y: imageY };\n  }\n\n  /**\n   * 🔧 NEW: Handle multi-direction click with coordinate recording\n   */\n  handleMultiDirectionClick(event) {\n    if (!this.state.selectedKeypoint || !this.state.selectedKeypoint.maxDirections) {\n      return false;\n    }\n\n    const keypoint = this.state.selectedKeypoint;\n    if (keypoint.directions.length >= keypoint.maxDirections) {\n      return false;\n    }\n\n    const screenCoords = this.getEventCoordinates(event);\n    const imageCoords = this.screenToImage(screenCoords.x, screenCoords.y);\n    \n    // Calculate angle and add new direction\n    const angle = this.calculateAngleFromClick(keypoint, imageCoords);\n    \n    keypoint.directions.push({\n      angle: angle,\n      type: 'angle',\n      clickPosition: {\n        x: imageCoords.x,\n        y: imageCoords.y,\n        screenX: screenCoords.x,\n        screenY: screenCoords.y,\n        timestamp: Date.now()\n      }\n    });\n\n    return true;\n  }\n\n  /**\n   * 🔧 NEW: Get annotation data with click coordinates\n   */\n  getAnnotationData() {\n    return {\n      keypoints: this.keypoints.map(kp => ({\n        ...kp,\n        directionClick: kp.directionClick || null\n      }))\n    };\n  }\n\n  /**\n   * 🔧 NEW: Serialize annotation data with click coordinates\n   */\n  serializeAnnotationData(keypoints) {\n    return JSON.stringify(keypoints.map(kp => ({\n      ...kp,\n      directionClick: kp.directionClick || null\n    })));\n  }\n\n  /**\n   * 🔧 NEW: Deserialize annotation data with click coordinates\n   */\n  deserializeAnnotationData(data) {\n    const keypoints = JSON.parse(data);\n    return keypoints.map(kp => ({\n      ...kp,\n      directionClick: kp.directionClick || null\n    }));\n  }\n\n  /**\n   * 🔧 NEW: Get event coordinates from mouse/touch event\n   */\n  getEventCoordinates(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    };\n  }\n\n  /**\n   * 🔧 NEW: SIFT匹配功能 - 基于上一帧调整当前帧标注\n   */\n  async performSiftMatching() {\n    console.log('[SIFT] 开始执行SIFT匹配');\n    \n    try {\n      // 验证前置条件\n      const validation = await this.validateMatchingPreconditions();\n      if (!validation.isValid) {\n        console.error('[SIFT] 前置条件验证失败:', validation.errors);\n        this.showSiftError('SIFT匹配前置条件不满足', validation.errors.join('\\n'));\n        return;\n      }\n\n      // 获取当前和上一帧的标注数据\n      const currentAnnotations = [...this.keypoints];\n      const previousAnnotations = await this.getPreviousFrameAnnotations();\n      \n      if (!previousAnnotations || previousAnnotations.length === 0) {\n        this.showSiftError('无法获取上一帧标注数据', '请确保上一帧存在标注点');\n        return;\n      }\n\n      // 获取图像数据\n      const currentImageData = this.getCurrentImageData();\n      const previousImageData = await this.getPreviousImageData();\n\n      // 执行SIFT匹配\n      const { SiftMatcher } = await import('./SiftMatcher.js');\n      const siftMatcher = new SiftMatcher();\n      \n      const calibratedAnnotations = await siftMatcher.calibrateAnnotations(\n        previousAnnotations,\n        currentAnnotations,\n        previousImageData,\n        currentImageData\n      );\n\n      // 计算匹配质量\n      const quality = siftMatcher.calculateMatchingQuality(calibratedAnnotations);\n      \n      console.log('[SIFT] 匹配完成:', {\n        原始标注: currentAnnotations.length,\n        校准标注: calibratedAnnotations.length,\n        平均置信度: `${(quality.averageConfidence * 100).toFixed(1)}%`,\n        平均偏移: `${quality.averageOffset.toFixed(2)}px`,\n        成功匹配: quality.successfulMatches\n      });\n\n      // 显示确认对话框\n      this.showCalibrationPreview(currentAnnotations, calibratedAnnotations, quality);\n\n    } catch (error) {\n      console.error('[SIFT] 匹配过程出错:', error);\n      this.showSiftError('SIFT匹配失败', error.message);\n    }\n  }\n\n  /**\n   * 🔧 NEW: 验证SIFT匹配前置条件\n   */\n  async validateMatchingPreconditions() {\n    const errors = [];\n    \n    // 检查当前图像\n    if (!this.currentImage || !this.imageElement) {\n      errors.push('当前图像未加载');\n    }\n    \n    // 检查当前标注\n    if (!this.keypoints || this.keypoints.length === 0) {\n      errors.push('当前图像没有标注点');\n    }\n    \n    // 检查是否有上一帧\n    if (!(await this.hasPreviousFrame())) {\n      errors.push('没有上一帧图像可用作参考');\n    }\n    \n    return {\n      hasCurrentImage: !!this.currentImage,\n      hasPreviousImage: await this.hasPreviousFrame(),\n      hasCurrentAnnotations: this.keypoints && this.keypoints.length > 0,\n      hasPreviousAnnotations: await this.hasPreviousFrameAnnotations(),\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * 🔧 NEW: 检查是否有上一帧\n   */\n  async hasPreviousFrame() {\n    if (!window.PlantAnnotationTool?.plantDataManager) {\n      return false;\n    }\n    \n    const currentPlant = window.PlantAnnotationTool.appState.currentPlant;\n    if (!currentPlant || !currentPlant.selectedViewAngle) {\n      return false;\n    }\n    \n    return await this.getPreviousFrameId() !== null;\n  }\n\n  /**\n   * 🔧 NEW: 检查是否有上一帧标注\n   */\n  async hasPreviousFrameAnnotations() {\n    const previousAnnotations = await this.getPreviousFrameAnnotations();\n    return previousAnnotations && previousAnnotations.length > 0;\n  }\n\n  /**\n   * 🔧 NEW: 获取上一帧ID\n   */\n  async getPreviousFrameId() {\n    if (!window.PlantAnnotationTool?.plantDataManager) {\n      return null;\n    }\n    \n    const currentPlant = window.PlantAnnotationTool.appState.currentPlant;\n    if (!currentPlant || !currentPlant.selectedViewAngle || !currentPlant.selectedImage) {\n      return null;\n    }\n    \n    // 获取当前视角的所有图像\n    const images = await window.PlantAnnotationTool.plantDataManager.getPlantImages(\n      currentPlant.id, \n      currentPlant.selectedViewAngle\n    );\n    \n    if (!images || images.length === 0) {\n      return null;\n    }\n    \n    // 找到当前图像的索引\n    const currentIndex = images.findIndex(img => img.id === currentPlant.selectedImage.id);\n    \n    if (currentIndex <= 0) {\n      return null; // 没有上一帧\n    }\n    \n    return images[currentIndex - 1].id;\n  }\n\n  /**\n   * 🔧 NEW: 获取上一帧标注数据\n   */\n  async getPreviousFrameAnnotations() {\n    const previousFrameId = await this.getPreviousFrameId();\n    if (!previousFrameId) {\n      return null;\n    }\n    \n    // 从数据管理器获取上一帧的标注\n    const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n    if (!plantDataManager) {\n      return null;\n    }\n    \n    try {\n      const annotations = plantDataManager.getImageAnnotations(previousFrameId);\n      return annotations || [];\n    } catch (error) {\n      console.warn('[SIFT] 获取上一帧标注失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 🔧 NEW: 获取当前图像数据\n   */\n  getCurrentImageData() {\n    if (!this.imageElement) {\n      throw new Error('当前图像未加载');\n    }\n    \n    // 🔧 FIX: If image is already loaded but might be tainted, reload with CORS\n    if (this.imageElement.complete && !this.imageElement.crossOrigin) {\n      console.warn('[SIFT] 图像已加载但未设置CORS，需要重新加载');\n      throw new Error('图像需要重新加载以支持CORS访问，请重新选择图像');\n    }\n    \n    // 创建临时canvas来获取图像数据\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = this.imageElement.width;\n    tempCanvas.height = this.imageElement.height;\n    const tempCtx = tempCanvas.getContext('2d');\n    \n    try {\n      tempCtx.drawImage(this.imageElement, 0, 0);\n      return tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\n    } catch (error) {\n      console.error('[SIFT] 获取图像数据失败:', error);\n      throw new Error('无法获取图像数据，可能是跨域问题。请重新选择图像。');\n    }\n  }\n\n  /**\n   * 🔧 NEW: 获取上一帧图像数据\n   */\n  async getPreviousImageData() {\n    const previousFrameId = await this.getPreviousFrameId();\n    if (!previousFrameId) {\n      throw new Error('无法获取上一帧图像ID');\n    }\n    \n    // 获取上一帧图像的路径\n    const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n    if (!plantDataManager) {\n      throw new Error('植物数据管理器不可用');\n    }\n    \n    const currentPlant = window.PlantAnnotationTool.appState.currentPlant;\n    const images = await plantDataManager.getPlantImages(currentPlant.id, currentPlant.selectedViewAngle);\n    const previousImage = images.find(img => img.id === previousFrameId);\n    \n    if (!previousImage) {\n      throw new Error('找不到上一帧图像');\n    }\n    \n    // 🔧 FIX: 创建正确的图像URL（使用与主图像相同的方法）\n    const imageURL = await plantDataManager.fileSystemManager.createImageURL(previousImage);\n    \n    // 加载上一帧图像\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    \n    return new Promise((resolve, reject) => {\n      img.onload = () => {\n        const tempCanvas = document.createElement('canvas');\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        const tempCtx = tempCanvas.getContext('2d');\n        \n        try {\n          tempCtx.drawImage(img, 0, 0);\n          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);\n          resolve(imageData);\n        } catch (error) {\n          console.error('[SIFT] 获取上一帧图像数据失败:', error);\n          reject(new Error('无法获取上一帧图像数据，可能是跨域问题'));\n        }\n      };\n      \n      img.onerror = () => {\n        console.error('[SIFT] 上一帧图像加载失败:', imageURL);\n        reject(new Error('加载上一帧图像失败'));\n      };\n      \n      img.src = imageURL;\n    });\n  }\n\n  /**\n   * 🔧 NEW: 显示非阻塞式校准预览和确认提示\n   */\n  showCalibrationPreview(originalAnnotations, calibratedAnnotations, quality) {\n    // 创建预览模式状态\n    this.calibrationPreviewState = {\n      originalAnnotations: [...originalAnnotations],\n      calibratedAnnotations: [...calibratedAnnotations],\n      quality,\n      isActive: true,\n      showOriginal: true,\n      showCalibrated: true,\n      showArrows: true\n    };\n    \n    // 显示非阻塞式提示\n    this.showNonBlockingNotification(quality);\n    \n    // 绑定键盘事件\n    this.bindCalibrationKeyboardEvents();\n    \n    // 重新渲染以显示预览\n    this.render();\n    \n    console.log('[SIFT] 校准预览已显示');\n  }\n\n  /**\n   * 🔧 NEW: 显示非阻塞式通知\n   */\n  showNonBlockingNotification(quality) {\n    // 创建通知元素\n    const notification = document.createElement('div');\n    notification.className = 'sift-notification';\n    notification.innerHTML = `\n      <div class=\"notification-content\">\n        <div class=\"notification-header\">\n          <h3>🔍 SIFT Match Result</h3>\n          <button class=\"close-btn\" onclick=\"this.parentElement.parentElement.parentElement.remove()\">×</button>\n        </div>\n        <div class=\"quality-info\">\n          <p><strong>Match Quality:</strong> ${(quality.qualityScore * 100).toFixed(1)}%</p>\n          <p><strong>Average Confidence:</strong> ${(quality.averageConfidence * 100).toFixed(1)}%</p>\n          <p><strong>Average Offset:</strong> ${quality.averageOffset.toFixed(2)}px</p>\n          <p><strong>Successful Matches:</strong> ${quality.successfulMatches}/${quality.totalAnnotations}</p>\n        </div>\n        \n        <div class=\"notification-actions\">\n          <button class=\"btn-accept\" title=\"Accept Adjustment (Shortcut: A)\">✓ Accept Adjustment (A)</button>\n          <button class=\"btn-reject\" title=\"Reject Adjustment (Shortcut: R)\">✗ Reject Adjustment (R)</button>\n        </div>\n        \n        <div class=\"notification-help\">\n          <small>Shortcuts: A=Accept, R=Reject, ESC=Cancel</small>\n        </div>\n      </div>\n    `;\n    \n    // 添加样式\n    notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      max-width: 350px;\n      background: white;\n      border: 1px solid #ddd;\n      border-radius: 8px;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n      z-index: 10000;\n      font-family: Arial, sans-serif;\n      animation: slideIn 0.3s ease-out;\n    `;\n    \n    // 添加动画样式\n    if (!document.getElementById('sift-notification-style')) {\n      const style = document.createElement('style');\n      style.id = 'sift-notification-style';\n      style.textContent = `\n        @keyframes slideIn {\n          from {\n            transform: translateX(100%);\n            opacity: 0;\n          }\n          to {\n            transform: translateX(0);\n            opacity: 1;\n          }\n        }\n        .sift-notification .notification-content {\n          padding: 15px;\n        }\n        .sift-notification .notification-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 10px;\n        }\n        .sift-notification .notification-header h3 {\n          margin: 0;\n          font-size: 16px;\n          color: #333;\n        }\n        .sift-notification .close-btn {\n          background: none;\n          border: none;\n          font-size: 18px;\n          cursor: pointer;\n          color: #666;\n          padding: 0;\n          width: 20px;\n          height: 20px;\n        }\n        .sift-notification .close-btn:hover {\n          color: #000;\n        }\n        .sift-notification .quality-info {\n          margin-bottom: 15px;\n          font-size: 13px;\n          color: #666;\n        }\n        .sift-notification .quality-info p {\n          margin: 3px 0;\n        }\n        .sift-notification .notification-actions {\n          display: flex;\n          gap: 10px;\n          margin-bottom: 10px;\n        }\n        .sift-notification .btn-accept,\n        .sift-notification .btn-reject {\n          flex: 1;\n          padding: 8px 12px;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 12px;\n          font-weight: 500;\n        }\n        .sift-notification .btn-accept {\n          background: #10b981;\n          color: white;\n        }\n        .sift-notification .btn-accept:hover {\n          background: #059669;\n        }\n        .sift-notification .btn-reject {\n          background: #ef4444;\n          color: white;\n        }\n        .sift-notification .btn-reject:hover {\n          background: #dc2626;\n        }\n        .sift-notification .notification-help {\n          text-align: center;\n          color: #999;\n          border-top: 1px solid #eee;\n          padding-top: 8px;\n        }\n      `;\n      document.head.appendChild(style);\n    }\n    \n    // 绑定按钮事件\n    const acceptBtn = notification.querySelector('.btn-accept');\n    const rejectBtn = notification.querySelector('.btn-reject');\n    \n    acceptBtn.addEventListener('click', () => {\n      this.applyCalibrationResults();\n    });\n    \n    rejectBtn.addEventListener('click', () => {\n      this.cancelCalibration();\n    });\n    \n    // 添加到页面\n    document.body.appendChild(notification);\n    \n    // 存储引用以便后续清理\n    this.calibrationNotification = notification;\n    \n    // 自动隐藏时间（30秒）\n    this.notificationTimeout = setTimeout(() => {\n      this.cancelCalibration();\n    }, 30000);\n  }\n\n  /**\n   * 🔧 NEW: 绑定校准键盘事件\n   */\n  bindCalibrationKeyboardEvents() {\n    this.calibrationKeyboardHandler = (event) => {\n      if (!this.calibrationPreviewState?.isActive) return;\n      \n      switch (event.key.toLowerCase()) {\n        case 'a':\n          event.preventDefault();\n          this.applyCalibrationResults();\n          break;\n        case 'r':\n          event.preventDefault();\n          this.cancelCalibration();\n          break;\n        case 'p':\n          event.preventDefault();\n          this.toggleCalibrationPreview();\n          break;\n        case 'escape':\n          event.preventDefault();\n          this.cancelCalibration();\n          break;\n      }\n    };\n    \n    document.addEventListener('keydown', this.calibrationKeyboardHandler);\n  }\n\n  /**\n   * 🔧 NEW: 切换校准预览\n   */\n  toggleCalibrationPreview() {\n    if (!this.calibrationPreviewState) return;\n    \n    this.calibrationPreviewState.showOriginal = !this.calibrationPreviewState.showOriginal;\n    this.calibrationPreviewState.showCalibrated = !this.calibrationPreviewState.showCalibrated;\n    this.calibrationPreviewState.showArrows = !this.calibrationPreviewState.showArrows;\n    \n    this.render();\n  }\n\n  /**\n   * 🔧 NEW: 应用校准结果\n   */\n  async applyCalibrationResults() {\n    if (!this.calibrationPreviewState) return;\n    \n    try {\n      console.log('[SIFT] 应用校准结果');\n      \n      // 保存历史记录\n      this.saveState();\n      \n      // 应用校准后的标注\n      this.keypoints = [...this.calibrationPreviewState.calibratedAnnotations];\n      \n      // 清理预览状态\n      this.cleanupCalibrationPreview();\n      \n      // 重新渲染\n      this.render();\n      \n      // 触发自动保存\n      if (window.PlantAnnotationTool?.autoSave) {\n        await window.PlantAnnotationTool.autoSave();\n      }\n      \n      // 显示成功提示\n      this.showSiftSuccess('SIFT匹配成功应用', `已调整 ${this.keypoints.length} 个标注点`);\n      \n    } catch (error) {\n      console.error('[SIFT] 应用校准结果失败:', error);\n      this.showSiftError('应用校准结果失败', error.message);\n    }\n  }\n\n  /**\n   * 🔧 NEW: 取消校准\n   */\n  cancelCalibration() {\n    console.log('[SIFT] 取消校准');\n    \n    // 清理预览状态\n    this.cleanupCalibrationPreview();\n    \n    // 重新渲染\n    this.render();\n    \n    this.showSiftInfo('已取消SIFT匹配', '标注点保持原始位置');\n  }\n\n  /**\n   * 🔧 NEW: 清理校准预览\n   */\n  cleanupCalibrationPreview() {\n    // 移除通知\n    if (this.calibrationNotification) {\n      this.calibrationNotification.remove();\n      this.calibrationNotification = null;\n    }\n    \n    // 清除自动隐藏定时器\n    if (this.notificationTimeout) {\n      clearTimeout(this.notificationTimeout);\n      this.notificationTimeout = null;\n    }\n    \n    // 移除键盘事件监听\n    if (this.calibrationKeyboardHandler) {\n      document.removeEventListener('keydown', this.calibrationKeyboardHandler);\n      this.calibrationKeyboardHandler = null;\n    }\n    \n    // 清理状态\n    this.calibrationPreviewState = null;\n  }\n\n  /**\n   * 🔧 NEW: 显示SIFT错误消息\n   */\n  showSiftError(title, message) {\n    console.error(`[SIFT] ${title}: ${message}`);\n    if (window.PlantAnnotationTool?.showError) {\n      window.PlantAnnotationTool.showError(title, message);\n    } else {\n      alert(`${title}\\n${message}`);\n    }\n  }\n\n  /**\n   * 🔧 NEW: 显示SIFT成功消息\n   */\n  showSiftSuccess(title, message) {\n    console.log(`[SIFT] ${title}: ${message}`);\n    if (window.PlantAnnotationTool?.showSuccess) {\n      window.PlantAnnotationTool.showSuccess(title, message);\n    } else {\n      alert(`${title}\\n${message}`);\n    }\n  }\n\n  /**\n   * 🔧 NEW: 显示SIFT信息消息\n   */\n  showSiftInfo(title, message) {\n    console.log(`[SIFT] ${title}: ${message}`);\n    if (window.PlantAnnotationTool?.showInfo) {\n      window.PlantAnnotationTool.showInfo(title, message);\n    } else {\n      alert(`${title}\\n${message}`);\n    }\n  }\n\n  /**\n   * 🔧 NEW: 创建匹配可视化\n   */\n  createMatchingVisualizations(data, type) {\n    const visualizations = [];\n    \n    if (type === 'original') {\n      data.forEach((annotation, index) => {\n        visualizations.push({\n          type: 'original',\n          x: annotation.x,\n          y: annotation.y,\n          color: '#ff4444',\n          size: 8,\n          label: annotation.order?.toString() || (index + 1).toString()\n        });\n      });\n    } else if (type === 'adjusted') {\n      data.forEach((annotation, index) => {\n        visualizations.push({\n          type: 'adjusted',\n          x: annotation.x,\n          y: annotation.y,\n          color: '#44ff44',\n          size: 8,\n          label: annotation.order?.toString() || (index + 1).toString()\n        });\n      });\n    } else if (type === 'arrows') {\n      data.forEach((annotation, index) => {\n        if (annotation.calibrationData) {\n          visualizations.push({\n            type: 'arrow',\n            from: { x: annotation.calibrationData.originalX, y: annotation.calibrationData.originalY },\n            to: { x: annotation.x, y: annotation.y },\n            color: '#ffaa00',\n            width: 2,\n            label: `${annotation.calibrationData.offset.toFixed(1)}px`\n          });\n        }\n      });\n    }\n    \n    return visualizations;\n  }\n\n  /**\n   * 🔧 NEW: 渲染校准预览\n   */\n  renderCalibrationPreview() {\n    if (!this.calibrationPreviewState) return;\n    \n    const { originalAnnotations, calibratedAnnotations, showOriginal, showCalibrated, showArrows } = this.calibrationPreviewState;\n    \n    // Render original positions (red)\n    if (showOriginal) {\n      originalAnnotations.forEach((annotation, index) => {\n        const screenPos = this.imageToScreen(annotation.x, annotation.y);\n        this.renderCalibrationPoint(screenPos.x, screenPos.y, '#ff4444', annotation.order || (index + 1), 'Original');\n      });\n    }\n    \n    // Render calibrated positions (green)\n    if (showCalibrated) {\n      calibratedAnnotations.forEach((annotation, index) => {\n        const screenPos = this.imageToScreen(annotation.x, annotation.y);\n        this.renderCalibrationPoint(screenPos.x, screenPos.y, '#44ff44', annotation.order || (index + 1), 'Calibrated');\n      });\n    }\n    \n    // 渲染移动箭头（橙色）\n    if (showArrows) {\n      calibratedAnnotations.forEach((annotation, index) => {\n        if (annotation.calibrationData) {\n          const originalPos = this.imageToScreen(annotation.calibrationData.originalX, annotation.calibrationData.originalY);\n          const calibratedPos = this.imageToScreen(annotation.x, annotation.y);\n          \n          this.renderCalibrationArrow(\n            originalPos.x, originalPos.y,\n            calibratedPos.x, calibratedPos.y,\n            annotation.calibrationData.offset\n          );\n        }\n      });\n    }\n  }\n\n  /**\n   * 🔧 NEW: 渲染校准点\n   */\n  renderCalibrationPoint(x, y, color, order, type) {\n    const radius = 8;\n    \n    // 绘制圆形\n    this.ctx.beginPath();\n    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);\n    this.ctx.fillStyle = color;\n    this.ctx.fill();\n    \n    // 绘制边框\n    this.ctx.strokeStyle = '#ffffff';\n    this.ctx.lineWidth = 2;\n    this.ctx.stroke();\n    \n    // 绘制序号\n    this.ctx.fillStyle = '#ffffff';\n    this.ctx.font = 'bold 12px Arial';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(order.toString(), x, y);\n    \n    // 绘制类型标签\n    this.ctx.fillStyle = color;\n    this.ctx.font = '10px Arial';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'top';\n    this.ctx.fillText(type, x, y + radius + 2);\n  }\n\n  /**\n   * 🔧 NEW: 渲染校准箭头\n   */\n  renderCalibrationArrow(x1, y1, x2, y2, offset) {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    \n    if (distance < 2) return; // 太小的偏移不显示箭头\n    \n    // 绘制箭头线\n    this.ctx.beginPath();\n    this.ctx.moveTo(x1, y1);\n    this.ctx.lineTo(x2, y2);\n    this.ctx.strokeStyle = '#ffaa00';\n    this.ctx.lineWidth = 3;\n    this.ctx.setLineDash([5, 3]);\n    this.ctx.stroke();\n    this.ctx.setLineDash([]); // 重置虚线\n    \n    // 绘制箭头头部\n    const angle = Math.atan2(dy, dx);\n    const headLength = 12;\n    const headAngle = Math.PI / 6;\n    \n    this.ctx.beginPath();\n    this.ctx.moveTo(x2, y2);\n    this.ctx.lineTo(\n      x2 - headLength * Math.cos(angle - headAngle),\n      y2 - headLength * Math.sin(angle - headAngle)\n    );\n    this.ctx.moveTo(x2, y2);\n    this.ctx.lineTo(\n      x2 - headLength * Math.cos(angle + headAngle),\n      y2 - headLength * Math.sin(angle + headAngle)\n    );\n    this.ctx.strokeStyle = '#ffaa00';\n    this.ctx.lineWidth = 3;\n    this.ctx.stroke();\n    \n    // 绘制偏移距离标签\n    const midX = (x1 + x2) / 2;\n    const midY = (y1 + y2) / 2;\n    \n    this.ctx.fillStyle = '#ffaa00';\n    this.ctx.font = 'bold 10px Arial';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(`${offset.toFixed(1)}px`, midX, midY - 8);\n  }\n}","/**\n * 分支点定位预览管理器\n * \n * 功能：\n * - 在工作区左上角显示预览窗口\n * - 显示上一张图像的对应分支点位置\n * - 帮助标注者快速定位当前应该标注的位置\n * - 基于分支点序号的一致性逻辑\n */\n\nexport class BranchPointPreviewManager {\n  constructor() {\n    this.previewWindow = null;\n    this.previewCanvas = null;\n    this.previewCtx = null;\n    this.previewTitle = null;\n    this.previewLoading = null;\n    this.noPreview = null;\n    this.zoomSlider = null;\n    this.zoomValue = null;\n    this.plantDataManager = null;\n    \n    // 状态管理\n    this.isVisible = false;\n    this.isDragging = false;\n    this.dragStartX = 0;\n    this.dragStartY = 0;\n    this.windowStartX = 0;\n    this.windowStartY = 0;\n    this.zoomLevel = 2; // 默认2倍放大\n    \n    // 特定预览模式状态\n    this.isShowingSpecificOrder = false; // 是否正在显示特定编号的预览\n    this.specificTargetOrder = null; // 当前显示的特定编号\n    \n    // 上下文信息\n    this.currentPlantId = null;\n    this.currentViewAngle = null;\n    this.currentImageIndex = -1;\n    this.currentKeypointCount = 0; // 当前图像的标注点数量\n    \n    // 缓存数据，用于实时更新\n    this.previousImageData = null;\n    this.previousAnnotations = [];\n    this.cachedImageElement = null; // 缓存加载的图像元素\n    \n    this.initializeElements();\n  }\n\n  /**\n   * 初始化DOM元素\n   */\n  initializeElements() {\n    this.previewWindow = document.getElementById('branch-point-preview');\n    this.previewCanvas = document.getElementById('preview-canvas');\n    this.previewTitle = document.getElementById('preview-title');\n    this.previewLoading = document.getElementById('preview-loading');\n    this.noPreview = document.getElementById('no-preview');\n    this.zoomSlider = document.getElementById('zoom-slider');\n    this.zoomValue = document.getElementById('zoom-value');\n    \n    if (this.previewCanvas) {\n      this.previewCtx = this.previewCanvas.getContext('2d');\n      // 初始canvas尺寸\n      this.updateCanvasSize();\n      \n      // 监听窗口大小变化\n      const resizeObserver = new ResizeObserver(() => {\n        this.updateCanvasSize();\n        if (this.isVisible && this.previousImageData && this.previousAnnotations) {\n          // 重新渲染预览\n          this.renderPreview(this.previousImageData, this.previousAnnotations);\n        }\n      });\n      \n      if (this.previewWindow) {\n        resizeObserver.observe(this.previewWindow);\n      }\n    }\n    \n    // 绑定缩放滑块事件\n    this.bindZoomControls();\n    \n    // 绑定拖拽事件\n    this.bindDragEvents();\n    \n    console.log('BranchPointPreviewManager 初始化完成');\n  }\n\n  /**\n   * 更新canvas尺寸\n   */\n  updateCanvasSize() {\n    if (!this.previewCanvas || !this.previewWindow) return;\n    \n    const container = this.previewCanvas.parentElement;\n    if (!container) return;\n    \n    const containerRect = container.getBoundingClientRect();\n    const width = Math.max(100, containerRect.width - 4); // 减去padding\n    const height = Math.max(80, containerRect.height - 4);\n    \n    // 只有在尺寸真正改变时才更新\n    if (this.previewCanvas.width !== width || this.previewCanvas.height !== height) {\n      this.previewCanvas.width = width;\n      this.previewCanvas.height = height;\n      this.previewCanvas.style.width = width + 'px';\n      this.previewCanvas.style.height = height + 'px';\n      \n      console.log('Canvas尺寸更新:', width, 'x', height);\n      \n      // 尺寸改变后立即使用缓存数据重新渲染，避免白屏\n      if (this.isVisible && this.cachedImageElement && this.previousAnnotations) {\n        this.renderCachedPreview();\n      } else if (this.isVisible && this.previousImageData && this.previousAnnotations) {\n        // 如果没有缓存的图像元素，使用原始数据重新渲染\n        setTimeout(() => {\n          this.renderPreview(this.previousImageData, this.previousAnnotations);\n        }, 50);\n      }\n    }\n  }\n\n  /**\n   * 使用缓存的图像数据立即重新渲染预览\n   */\n  renderCachedPreview() {\n    if (!this.cachedImageElement || !this.previousAnnotations || !this.previewCanvas || !this.previewCtx) {\n      return;\n    }\n    \n    // 获取下一个要标注的编号\n    const nextOrder = this.getNextOrderToAnnotate();\n    \n    // 在上一张图像的标注中查找对应编号的标注点\n    const targetAnnotation = this.previousAnnotations.find(annotation => annotation.order === nextOrder);\n    \n    // 如果没有对应编号的标注点，显示无预览\n    if (!targetAnnotation) {\n      this.showNoPreview(`上一张图像暂无第${nextOrder}个分支点`);\n      return;\n    }\n    \n    const img = this.cachedImageElement;\n    \n    try {\n      // 计算局部区域（围绕目标标注点，根据缩放级别调整）\n      const baseCropSize = 200; // 基础裁剪区域大小\n      const cropSize = Math.round(baseCropSize / this.zoomLevel); // 根据缩放级别调整裁剪区域\n      const centerX = targetAnnotation.x;\n      const centerY = targetAnnotation.y;\n      \n      // 计算裁剪区域，确保不超出图像边界\n      const cropX = Math.max(0, Math.min(img.width - cropSize, centerX - cropSize / 2));\n      const cropY = Math.max(0, Math.min(img.height - cropSize, centerY - cropSize / 2));\n      const actualCropWidth = Math.min(cropSize, img.width - cropX);\n      const actualCropHeight = Math.min(cropSize, img.height - cropY);\n      \n      // 设置canvas尺寸\n      const canvasWidth = this.previewCanvas.width;\n      const canvasHeight = this.previewCanvas.height;\n      \n      // 清空canvas\n      this.previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n      \n      // 绘制局部放大图\n      this.previewCtx.drawImage(\n        img,\n        cropX, cropY, actualCropWidth, actualCropHeight, // 源图裁剪区域\n        0, 0, canvasWidth, canvasHeight // 目标区域\n      );\n      \n      // 计算标注点在预览canvas中的位置\n      const scaleX = canvasWidth / actualCropWidth;\n      const scaleY = canvasHeight / actualCropHeight;\n      const pointX = (centerX - cropX) * scaleX;\n      const pointY = (centerY - cropY) * scaleY;\n      \n      // 绘制目标标注点（高亮）\n      this.renderLocalizedAnnotation(pointX, pointY, nextOrder, targetAnnotation.direction);\n      \n      // 绘制其他标注点（如果在视图范围内）\n      this.previousAnnotations.forEach((annotation) => {\n        if (annotation.order === nextOrder) return; // 跳过目标点，已经绘制\n        \n        // 检查是否在裁剪区域内\n        if (annotation.x >= cropX && annotation.x <= cropX + actualCropWidth &&\n            annotation.y >= cropY && annotation.y <= cropY + actualCropHeight) {\n          \n          const otherX = (annotation.x - cropX) * scaleX;\n          const otherY = (annotation.y - cropY) * scaleY;\n          this.renderLocalizedAnnotation(otherX, otherY, annotation.order || 0, annotation.direction, false);\n        }\n      });\n      \n      // 绘制放大倍数提示\n      this.renderZoomInfo(scaleX, scaleY);\n      \n      console.log('使用缓存数据快速重新渲染完成');\n      \n    } catch (error) {\n      console.error('缓存渲染失败:', error);\n      // 如果缓存渲染失败，回退到完整重新渲染\n      if (this.previousImageData && this.previousAnnotations) {\n        this.renderPreview(this.previousImageData, this.previousAnnotations);\n      }\n    }\n  }\n\n  /**\n   * 绑定拖拽事件\n   */\n  bindDragEvents() {\n    const header = document.querySelector('.preview-header');\n    if (!header || !this.previewWindow) return;\n    \n    header.addEventListener('mousedown', (e) => {\n      e.preventDefault();\n      this.startDrag(e);\n    });\n    \n    document.addEventListener('mousemove', (e) => {\n      if (this.isDragging) {\n        this.drag(e);\n      }\n    });\n    \n    document.addEventListener('mouseup', () => {\n      this.endDrag();\n    });\n  }\n\n  /**\n   * 开始拖拽\n   */\n  startDrag(e) {\n    this.isDragging = true;\n    this.dragStartX = e.clientX;\n    this.dragStartY = e.clientY;\n    \n    const rect = this.previewWindow.getBoundingClientRect();\n    this.windowStartX = rect.left;\n    this.windowStartY = rect.top;\n    \n    this.previewWindow.style.cursor = 'grabbing';\n    document.body.style.userSelect = 'none';\n  }\n\n  /**\n   * 拖拽中\n   */\n  drag(e) {\n    if (!this.isDragging) return;\n    \n    const deltaX = e.clientX - this.dragStartX;\n    const deltaY = e.clientY - this.dragStartY;\n    \n    const newX = this.windowStartX + deltaX;\n    const newY = this.windowStartY + deltaY;\n    \n    // 限制在窗口范围内\n    const maxX = window.innerWidth - this.previewWindow.offsetWidth;\n    const maxY = window.innerHeight - this.previewWindow.offsetHeight;\n    \n    const constrainedX = Math.max(0, Math.min(maxX, newX));\n    const constrainedY = Math.max(0, Math.min(maxY, newY));\n    \n    this.previewWindow.style.left = constrainedX + 'px';\n    this.previewWindow.style.top = constrainedY + 'px';\n  }\n\n  /**\n   * 结束拖拽\n   */\n  endDrag() {\n    if (!this.isDragging) return;\n    \n    this.isDragging = false;\n    this.previewWindow.style.cursor = '';\n    document.body.style.userSelect = '';\n  }\n\n  /**\n   * 设置植物数据管理器引用\n   */\n  setPlantDataManager(plantDataManager) {\n    this.plantDataManager = plantDataManager;\n  }\n\n  /**\n   * 显示/隐藏预览窗口\n   */\n  toggleVisibility(show = null) {\n    if (!this.previewWindow) return;\n    \n    this.isVisible = show !== null ? show : !this.isVisible;\n    \n    if (this.isVisible) {\n      this.previewWindow.classList.remove('hidden');\n      this.updatePreview();\n    } else {\n      this.previewWindow.classList.add('hidden');\n    }\n    \n    console.log(`分支点预览窗口: ${this.isVisible ? '显示' : '隐藏'}`);\n  }\n\n  /**\n   * 更新当前上下文\n   */\n  async updateContext(plantId, viewAngle, imageIndex, currentKeypointCount = 0) {\n    this.currentPlantId = plantId;\n    this.currentViewAngle = viewAngle;\n    this.currentImageIndex = imageIndex;\n    this.currentKeypointCount = currentKeypointCount; // 当前图像的标注点数量\n    \n    if (this.isVisible) {\n      await this.updatePreview();\n    }\n  }\n\n  /**\n   * 更新预览内容\n   */\n  async updatePreview() {\n    if (!this.isVisible || !this.plantDataManager || !this.currentPlantId) {\n      return;\n    }\n    \n    try {\n      this.showLoading(true);\n      \n      // 获取上一张图像\n      const previousImageData = await this.getPreviousImage();\n      \n      if (!previousImageData) {\n        this.showNoPreview('This is the first image');\n        return;\n      }\n      \n      // 获取上一张图像的标注数据\n      const previousAnnotations = await this.plantDataManager.getImageAnnotations(previousImageData.id);\n      \n      if (!previousAnnotations || previousAnnotations.length === 0) {\n        this.showNoPreview('This image has no annotations');\n        return;\n      }\n      \n      // 更新预览标题\n      this.updatePreviewTitle(previousImageData, previousAnnotations.length);\n      \n      // 渲染预览\n      await this.renderPreview(previousImageData, previousAnnotations);\n      \n      this.showLoading(false);\n      \n    } catch (error) {\n      console.error('Update branch point preview failed:', error);\n      this.showNoPreview('Preview loading failed');\n    }\n  }\n\n  /**\n   * 获取上一张图像\n   */\n  async getPreviousImage() {\n    if (!this.plantDataManager || this.currentImageIndex <= 0) {\n      return null;\n    }\n    \n    try {\n      const images = await this.plantDataManager.getPlantImages(\n        this.currentPlantId, \n        this.currentViewAngle\n      );\n      \n      const previousIndex = this.currentImageIndex - 1;\n      return images[previousIndex] || null;\n      \n    } catch (error) {\n      console.error('Get previous image failed:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 更新预览标题\n   */\n  updatePreviewTitle(imageData, annotationCount) {\n    if (this.previewTitle) {\n      const timeString = imageData.timeString || 'Unknown time';\n      \n      // 获取下一个要标注的编号（最小的缺失编号）\n      const nextOrder = this.getNextOrderToAnnotate();\n      \n      this.previewTitle.textContent = `Reference: ${nextOrder}th branch point`;\n      this.previewTitle.title = `${timeString} - Current need to annotate the position of the ${nextOrder}th branch point`;\n    }\n  }\n\n  /**\n   * 获取下一个要标注的编号（最小的缺失编号）- 支持自定义标注类型\n   */\n  getNextOrderToAnnotate() {\n    // 从AnnotationTool获取下一个可用编号\n    const annotationTool = window.PlantAnnotationTool?.annotationTool;\n    if (!annotationTool) {\n      console.warn('[Preview] AnnotationTool is not available, using fallback');\n      return this.currentKeypointCount + 1;\n    }\n\n    // 🔧 FIX: 检查是否处于自定义标注模式\n    const customAnnotationManager = annotationTool.getCustomAnnotationManager();\n    const isInCustomMode = customAnnotationManager?.isInCustomMode();\n    \n    if (isInCustomMode) {\n      // 自定义标注模式：获取当前自定义类型的下一个编号\n      const currentCustomType = customAnnotationManager.getCurrentCustomType();\n      if (currentCustomType && typeof annotationTool.findNextAvailableOrderForType === 'function') {\n        const nextOrder = annotationTool.findNextAvailableOrderForType(currentCustomType.id);\n        console.log(`[Preview] Custom mode - get next order for type ${currentCustomType.id}: ${nextOrder}, current keypoint count: ${this.currentKeypointCount}`);\n        return nextOrder;\n      }\n    } else {\n      // 常规标注模式：获取常规标注的下一个编号\n      if (typeof annotationTool.findNextAvailableOrder === 'function') {\n        const nextOrder = annotationTool.findNextAvailableOrder();\n        console.log(`[Preview] Regular mode - get next order: ${nextOrder}, current keypoint count: ${this.currentKeypointCount}`);\n        return nextOrder;\n      }\n    }\n\n    // 后备方案：简单计算\n    const fallbackOrder = this.currentKeypointCount + 1;\n    console.log(`[Preview] Using fallback to calculate next order: ${fallbackOrder}, current keypoint count: ${this.currentKeypointCount}`);\n    return fallbackOrder;\n  }\n\n  /**\n   * 渲染预览图像和标注\n   */\n  async renderPreview(imageData, annotations) {\n    if (!this.previewCanvas || !this.previewCtx) return;\n    \n    // 获取下一个要标注的编号\n    const nextOrder = this.getNextOrderToAnnotate();\n    \n    // 🔧 FIX: 根据当前标注模式进行不同的匹配逻辑\n    const annotationTool = window.PlantAnnotationTool?.annotationTool;\n    const customAnnotationManager = annotationTool?.getCustomAnnotationManager();\n    const isInCustomMode = customAnnotationManager?.isInCustomMode();\n    \n    let targetAnnotation;\n    let previewMessage;\n    \n    if (isInCustomMode) {\n      // 自定义标注模式：匹配编号和自定义类型\n      const currentCustomType = customAnnotationManager.getCurrentCustomType();\n      if (currentCustomType) {\n        targetAnnotation = annotations.find(annotation => \n          annotation.order === nextOrder && \n          annotation.annotationType === 'custom' && \n          annotation.customTypeId === currentCustomType.id\n        );\n        previewMessage = `This image has no ${nextOrder}th ${currentCustomType.name} annotation`;\n      } else {\n        previewMessage = `This image has no ${nextOrder}th custom annotation`;\n      }\n    } else {\n      // 迁移后常规标注视为内置类型\n      targetAnnotation = annotations.find(annotation => \n        annotation.order === nextOrder && \n        (\n          (annotation.annotationType === 'custom' && annotation.customTypeId === 'builtin-regular-keypoint') ||\n          (!annotation.annotationType && !annotation.customTypeId) // 兜底兼容旧数据\n        )\n      );\n      previewMessage = `This image has no ${nextOrder}th branch point`;\n    }\n    \n    // 如果没有对应的标注点，显示无预览\n    if (!targetAnnotation) {\n      this.showNoPreview(previewMessage);\n      return;\n    }\n    \n    this.hideLoading();\n    this.hideNoPreview();\n    \n    try {\n      console.log('Start loading preview image:', imageData);\n      \n      // 获取图像URL的多种方式\n      let imageURL;\n      \n      // 方式1：如果有file对象，直接使用\n      if (imageData.file && imageData.file instanceof File) {\n        imageURL = URL.createObjectURL(imageData.file);\n          console.log('Create URL using file object:', imageURL);\n      }\n      // 方式2：如果有现成的URL\n      else if (imageData.url) {\n        imageURL = imageData.url;\n        console.log('Use existing URL:', imageURL);\n      }\n      // 方式3：使用FileSystemManager (HTTP后端或传统文件系统)\n      else if (this.plantDataManager?.fileSystemManager) {\n        try {\n          imageURL = await this.plantDataManager.fileSystemManager.createImageURL(imageData);\n          console.log('Create URL using FileSystemManager:', imageURL);\n        } catch (error) {\n          console.warn('Create URL using FileSystemManager failed:', error);\n          \n          // 如果是传统文件系统，尝试直接从handle读取\n          if (imageData.handle) {\n            try {\n              const file = await imageData.handle.getFile();\n              imageURL = URL.createObjectURL(file);\n              console.log('Create URL directly from handle:', imageURL);\n            } catch (handleError) {\n              console.error('Create URL from handle also failed:', handleError);\n              throw new Error('无法获取图像数据：所有方法都失败');\n            }\n          } else {\n            throw error;\n          }\n        }\n      }\n      else {\n        throw new Error('无法获取图像数据：缺少必要的图像信息或文件系统管理器');\n      }\n      \n      // 加载图像\n      const img = new Image();\n      img.crossOrigin = 'anonymous'; // 🔧 FIX: Prevent canvas taint issues\n      await new Promise((resolve, reject) => {\n        img.onload = () => {\n          console.log('Image loaded successfully:', img.width, 'x', img.height);\n          resolve();\n        };\n        img.onerror = (error) => {\n          console.error('Image loading failed:', error);\n          reject(new Error('Image loading failed'));\n        };\n        img.src = imageURL;\n      });\n      \n      // 计算局部区域（围绕目标标注点，根据缩放级别调整）\n      const baseCropSize = 200; // 基础裁剪区域大小\n      const cropSize = Math.round(baseCropSize / this.zoomLevel); // 根据缩放级别调整裁剪区域\n      const centerX = targetAnnotation.x;\n      const centerY = targetAnnotation.y;\n      \n      // 计算裁剪区域，确保不超出图像边界\n      const cropX = Math.max(0, Math.min(img.width - cropSize, centerX - cropSize / 2));\n      const cropY = Math.max(0, Math.min(img.height - cropSize, centerY - cropSize / 2));\n      const actualCropWidth = Math.min(cropSize, img.width - cropX);\n      const actualCropHeight = Math.min(cropSize, img.height - cropY);\n      \n      // 设置canvas尺寸\n      const canvasWidth = this.previewCanvas.width;\n      const canvasHeight = this.previewCanvas.height;\n      \n      // 清空canvas\n      this.previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n      \n      // 绘制局部放大图\n      this.previewCtx.drawImage(\n        img,\n        cropX, cropY, actualCropWidth, actualCropHeight, // 源图裁剪区域\n        0, 0, canvasWidth, canvasHeight // 目标区域\n      );\n      \n      // 计算标注点在预览canvas中的位置\n      const scaleX = canvasWidth / actualCropWidth;\n      const scaleY = canvasHeight / actualCropHeight;\n      const pointX = (centerX - cropX) * scaleX;\n      const pointY = (centerY - cropY) * scaleY;\n      \n      // 绘制目标标注点（高亮）\n      this.renderLocalizedAnnotation(pointX, pointY, nextOrder, targetAnnotation.direction);\n      \n      // 绘制其他标注点（如果在视图范围内）\n      annotations.forEach((annotation) => {\n        if (annotation.order === nextOrder) return; // 跳过目标点，已经绘制\n        \n        // 检查是否在裁剪区域内\n        if (annotation.x >= cropX && annotation.x <= cropX + actualCropWidth &&\n            annotation.y >= cropY && annotation.y <= cropY + actualCropHeight) {\n          \n          const otherX = (annotation.x - cropX) * scaleX;\n          const otherY = (annotation.y - cropY) * scaleY;\n          this.renderLocalizedAnnotation(otherX, otherY, annotation.order || 0, annotation.direction, false);\n        }\n      });\n      \n      // 绘制放大倍数提示\n      this.renderZoomInfo(scaleX, scaleY);\n      \n      // 缓存成功渲染的数据，用于实时更新\n      this.previousImageData = imageData;\n      this.previousAnnotations = annotations;\n      this.cachedImageElement = img;\n      \n      // 清理临时URL\n      if (imageURL && imageURL.startsWith('blob:') && !imageData.url) {\n        setTimeout(() => URL.revokeObjectURL(imageURL), 5000);\n      }\n      \n      console.log('Preview rendering completed');\n      \n    } catch (error) {\n      console.error('Preview rendering failed:', error);\n      this.showNoPreview(`Preview loading failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * 渲染局部化的标注点\n   */\n  renderLocalizedAnnotation(x, y, label, direction, isTarget = true) {\n    // 根据是否为目标点设置样式\n    let fillColor, radius, borderWidth;\n\n    if (isTarget) {\n      fillColor = '#ffeb3b'; // 黄色高亮\n      radius = 5; // 缩小目标圆圈\n      borderWidth = 2;\n\n      // 绘制外圈提示（更小的虚线圆圈）\n      this.previewCtx.beginPath();\n      this.previewCtx.arc(x, y, radius + 3, 0, 2 * Math.PI);\n      this.previewCtx.strokeStyle = '#ff9800';\n      this.previewCtx.lineWidth = 1;\n      this.previewCtx.setLineDash([2, 2]);\n      this.previewCtx.stroke();\n      this.previewCtx.setLineDash([]);\n    } else {\n      // 根据方向类型设置颜色\n      if (typeof direction === 'number') {\n        fillColor = '#4CAF50'; // 绿色表示角度方向\n      } else {\n        fillColor = direction === 'left' ? '#ff6666' : '#6666ff'; // 传统颜色\n      }\n      radius = 3;\n      borderWidth = 1;\n    }\n\n    // 绘制标注点\n    this.previewCtx.beginPath();\n    this.previewCtx.arc(x, y, radius, 0, 2 * Math.PI);\n    this.previewCtx.fillStyle = fillColor;\n    this.previewCtx.fill();\n\n    // 绘制边框\n    this.previewCtx.strokeStyle = '#ffffff';\n    this.previewCtx.lineWidth = borderWidth;\n    this.previewCtx.stroke();\n\n    // 绘制方向箭头（如果有方向信息）\n    this.renderDirectionArrow(x, y, direction, isTarget);\n\n    // 绘制序号\n    this.previewCtx.fillStyle = isTarget ? '#000000' : '#ffffff';\n    this.previewCtx.font = `bold ${isTarget ? 8 : 6}px Arial`;\n    this.previewCtx.textAlign = 'center';\n    this.previewCtx.textBaseline = 'middle';\n    this.previewCtx.fillText(label.toString(), x, y);\n\n    // 如果是目标点，添加小箭头指示\n    if (isTarget) {\n      this.previewCtx.fillStyle = '#ff9800';\n      this.previewCtx.font = 'bold 8px Arial';\n      this.previewCtx.fillText('▼', x, y - radius - 8);\n\n      this.previewCtx.fillStyle = '#ff9800';\n      this.previewCtx.font = 'bold 6px Arial';\n      this.previewCtx.textAlign = 'center';\n      this.previewCtx.fillText('Target', x, y + radius + 8);\n    }\n  }\n\n  /**\n   * 渲染方向箭头（与主标注区域样式一致）\n   */\n  renderDirectionArrow(x, y, direction, isTarget = false) {\n    if (!direction) return;\n\n    let angleDegrees;\n\n    // 统一转换为角度\n    if (typeof direction === 'number') {\n      angleDegrees = direction;\n    } else if (direction === 'left') {\n      angleDegrees = 180;\n    } else if (direction === 'right') {\n      angleDegrees = 0;\n    } else {\n      return; // 无效方向\n    }\n\n    const angleRadians = angleDegrees * Math.PI / 180;\n\n    // 🔧 FIX: 增加箭头尺寸以提高可见性\n    const arrowLength = isTarget ? 25 : 18;  // 增加箭头长度 (原来: 15/10)\n    const headLength = isTarget ? 7 : 5;     // 增加箭头头部尺寸 (原来: 4/3)\n    const lineWidth = isTarget ? 3 : 2;      // 增加线条宽度 (原来: 2/1)\n\n    // 计算箭头终点\n    const endX = x + Math.cos(angleRadians) * arrowLength;\n    const endY = y + Math.sin(angleRadians) * arrowLength;\n\n    this.previewCtx.save();\n\n    // 绘制虚线主线（绿色）\n    this.previewCtx.strokeStyle = '#10b981'; // 与主标注区域相同的绿色\n    this.previewCtx.lineWidth = lineWidth;\n    this.previewCtx.setLineDash([4, 2]); // 虚线样式\n    this.previewCtx.lineCap = 'round';\n\n    this.previewCtx.beginPath();\n    this.previewCtx.moveTo(x, y);\n    this.previewCtx.lineTo(endX, endY);\n    this.previewCtx.stroke();\n\n    // 绘制箭头头部（实线）\n    this.previewCtx.setLineDash([]);\n    this.previewCtx.strokeStyle = '#10b981';\n    this.previewCtx.lineWidth = lineWidth;\n    this.previewCtx.lineCap = 'round';\n\n    const headAngle1 = angleRadians + Math.PI * 0.8;\n    const headAngle2 = angleRadians - Math.PI * 0.8;\n\n    this.previewCtx.beginPath();\n    this.previewCtx.moveTo(endX, endY);\n    this.previewCtx.lineTo(endX + Math.cos(headAngle1) * headLength, endY + Math.sin(headAngle1) * headLength);\n    this.previewCtx.moveTo(endX, endY);\n    this.previewCtx.lineTo(endX + Math.cos(headAngle2) * headLength, endY + Math.sin(headAngle2) * headLength);\n    this.previewCtx.stroke();\n\n    this.previewCtx.restore();\n  }\n\n  /**\n   * 渲染放大倍数信息\n   */\n  renderZoomInfo(scaleX, scaleY) {\n    const actualScale = this.zoomLevel; // 使用用户设置的缩放级别\n    const zoomText = `${actualScale}x zoom`;\n    \n    this.previewCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.previewCtx.fillRect(5, 5, 60, 16);\n    \n    this.previewCtx.fillStyle = '#ffffff';\n    this.previewCtx.font = '8px Arial';\n    this.previewCtx.textAlign = 'left';\n    this.previewCtx.textBaseline = 'middle';\n    this.previewCtx.fillText(zoomText, 8, 13);\n  }\n\n  /**\n   * 显示加载状态\n   */\n  showLoading(show) {\n    if (this.previewLoading) {\n      this.previewLoading.style.display = show ? 'block' : 'none';\n    }\n    if (this.noPreview) {\n      this.noPreview.style.display = 'none';\n    }\n  }\n\n  /**\n   * 显示无预览状态\n   */\n  showNoPreview(message) {\n    this.showLoading(false);\n    if (this.noPreview) {\n      this.noPreview.textContent = message;\n      this.noPreview.style.display = 'block';\n    }\n    \n    // 清空canvas\n    if (this.previewCanvas && this.previewCtx) {\n      this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);\n    }\n  }\n\n  /**\n   * 当标注点变化时更新预览中的高亮\n   */\n  highlightCorrespondingPoints(currentAnnotations) {\n    if (!this.isVisible || !currentAnnotations) return;\n    \n    // 这里可以实现高亮逻辑，比如当前正在标注的点在预览中特殊显示\n    // 暂时简单重新渲染\n    this.updatePreview();\n  }\n\n  /**\n   * 获取指定编号的预期位置（用于自动切换功能）\n   */\n  async getExpectedPosition(targetOrder) {\n    try {\n      // 如果没有缓存的预览数据，先更新预览\n      if (!this.previousImageData || !this.previousAnnotations) {\n        console.log(`[Expected position] No cached preview data, trying to get previous image`);\n\n        // 获取上一张图像\n        const previousImageData = await this.getPreviousImage();\n        if (!previousImageData) {\n          console.log(`[Expected position] No previous image data`);\n          return null;\n        }\n\n        // 获取上一张图像的标注数据\n        const previousAnnotations = await this.plantDataManager.getImageAnnotations(previousImageData.id);\n        if (!previousAnnotations || previousAnnotations.length === 0) {\n          console.log(`[Expected position] Previous image has no annotations`);\n          return null;\n        }\n\n        // 更新缓存\n        this.previousImageData = previousImageData;\n        this.previousAnnotations = previousAnnotations;\n      }\n\n      // 在上一张图像的标注中查找对应编号的标注点\n      const targetAnnotation = this.previousAnnotations.find(annotation => annotation.order === targetOrder);\n\n      if (!targetAnnotation) {\n        console.log(`[Expected position] No annotation found for order ${targetOrder} in previous image`);\n        return null;\n      }\n\n      console.log(`[Expected position] Found reference position for order ${targetOrder}: (${targetAnnotation.x.toFixed(1)}, ${targetAnnotation.y.toFixed(1)})`);\n\n      return {\n        x: targetAnnotation.x,\n        y: targetAnnotation.y,\n        order: targetAnnotation.order,\n        sourceImage: this.previousImageData.timeString || 'Previous image'\n      };\n\n    } catch (error) {\n      console.error('[Expected position] Get expected position failed:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 重置预览状态\n   */\n  reset() {\n    this.currentPlantId = null;\n    this.currentViewAngle = null;\n    this.currentImageIndex = -1;\n    this.previousImageData = null;\n    this.previousAnnotations = [];\n    \n    if (this.isVisible) {\n      this.showNoPreview('Please choose an image');\n    }\n  }\n\n  /**\n   * 获取预览状态\n   */\n  getStatus() {\n    return {\n      isVisible: this.isVisible,\n      currentPlantId: this.currentPlantId,\n      currentViewAngle: this.currentViewAngle,\n      currentImageIndex: this.currentImageIndex,\n      hasPreviousData: this.previousImageData !== null\n    };\n  }\n\n  /**\n   * 隐藏加载状态\n   */\n  hideLoading() {\n    this.showLoading(false);\n  }\n\n  /**\n   * 隐藏无预览状态\n   */\n  hideNoPreview() {\n    if (this.noPreview) {\n      this.noPreview.style.display = 'none';\n    }\n  }\n\n  /**\n   * 绑定缩放控制事件\n   */\n  bindZoomControls() {\n    if (!this.zoomSlider || !this.zoomValue) return;\n    \n    this.zoomSlider.addEventListener('input', (e) => {\n      this.zoomLevel = parseFloat(e.target.value);\n      this.zoomValue.textContent = this.zoomLevel + 'x';\n      \n      // 立即使用缓存数据重新渲染，避免延迟\n      if (this.isVisible && this.cachedImageElement && this.previousAnnotations) {\n        this.renderCachedPreview();\n      } else if (this.isVisible && this.previousImageData && this.previousAnnotations) {\n        // 如果没有缓存，回退到完整重新渲染\n        this.renderPreview(this.previousImageData, this.previousAnnotations);\n      }\n    });\n    \n    // 设置初始值\n    this.zoomSlider.value = this.zoomLevel;\n    this.zoomValue.textContent = this.zoomLevel + 'x';\n  }\n\n  /**\n   * 显示特定编号的预览（拖动时使用）\n   */\n  async showSpecificOrderPreview(targetOrder) {\n    if (!this.isVisible || !this.plantDataManager || !this.currentPlantId) {\n      return;\n    }\n    \n    // 标记当前处于特定预览模式\n    this.isShowingSpecificOrder = true;\n    this.specificTargetOrder = targetOrder;\n    \n    try {\n      // 获取上一张图像\n      const previousImageData = await this.getPreviousImage();\n      \n      if (!previousImageData) {\n        this.showNoPreview('This is the first image');\n        return;\n      }\n      \n      // 获取上一张图像的标注数据\n      const previousAnnotations = await this.plantDataManager.getImageAnnotations(previousImageData.id);\n      \n      if (!previousAnnotations || previousAnnotations.length === 0) {\n        this.showNoPreview('This image has no annotations');\n        return;\n      }\n      \n      // 查找对应编号的标注点\n      const targetAnnotation = previousAnnotations.find(annotation => annotation.order === targetOrder);\n      \n      if (!targetAnnotation) {\n        this.showNoPreview(`This image has no ${targetOrder}th branch point`);\n        return;\n      }\n      \n      // 更新预览标题\n      this.updateSpecificPreviewTitle(previousImageData, targetOrder);\n      \n      // 渲染特定编号的预览\n      await this.renderSpecificOrderPreview(previousImageData, previousAnnotations, targetOrder);\n      \n    } catch (error) {\n      console.error('Show specific order preview failed:', error);\n      this.showNoPreview('Preview loading failed');\n    }\n  }\n\n  /**\n   * 恢复正常预览显示\n   */\n  async restoreNormalPreview() {\n    // 清除特定预览模式标记\n    this.isShowingSpecificOrder = false;\n    this.specificTargetOrder = null;\n    \n    // 恢复到正常的预览更新\n    await this.updatePreview();\n  }\n\n  /**\n   * 更新特定预览的标题\n   */\n  updateSpecificPreviewTitle(imageData, targetOrder) {\n    if (this.previewTitle) {\n      const timeString = imageData.timeString || 'Unknown time';\n      this.previewTitle.textContent = `Dragging: ${targetOrder}th branch point`;\n      this.previewTitle.title = `${timeString} - Dragging ${targetOrder}th branch point, reference position from previous image`;\n    }\n  }\n\n  /**\n   * 渲染特定编号的预览\n   */\n  async renderSpecificOrderPreview(imageData, annotations, targetOrder) {\n    if (!this.previewCanvas || !this.previewCtx) return;\n    \n    // 查找目标标注点\n    const targetAnnotation = annotations.find(annotation => annotation.order === targetOrder);\n    \n    if (!targetAnnotation) {\n      this.showNoPreview(`This image has no ${targetOrder}th branch point`);\n      return;\n    }\n    \n    this.hideLoading();\n    this.hideNoPreview();\n    \n    try {\n      console.log('Render specific order preview:', targetOrder);\n      \n      // 获取图像URL的多种方式（与renderPreview保持一致）\n      let imageURL;\n      \n      // 方式1：如果有file对象，直接使用\n      if (imageData.file && imageData.file instanceof File) {\n        imageURL = URL.createObjectURL(imageData.file);\n      }\n      // 方式2：如果有现成的URL\n      else if (imageData.url) {\n        imageURL = imageData.url;\n      }\n      // 方式3：使用FileSystemManager (HTTP后端或传统文件系统)\n      else if (this.plantDataManager?.fileSystemManager) {\n        try {\n          imageURL = await this.plantDataManager.fileSystemManager.createImageURL(imageData);\n        } catch (error) {\n          console.warn('Create URL using FileSystemManager failed:', error);\n          \n          // 如果是传统文件系统，尝试直接从handle读取\n          if (imageData.handle) {\n            try {\n              const file = await imageData.handle.getFile();\n              imageURL = URL.createObjectURL(file);\n            } catch (handleError) {\n              console.error('Create URL from handle also failed:', handleError);\n              throw new Error('Failed to get image data: all methods failed');\n            }\n          } else {\n            throw error;\n          }\n        }\n      }\n      else {\n        throw new Error('Failed to get image data: missing necessary image information or file system manager');\n      }\n      \n      // 加载图像\n      const img = new Image();\n      img.crossOrigin = 'anonymous'; // 🔧 FIX: Prevent canvas taint issues\n      await new Promise((resolve, reject) => {\n        img.onload = () => resolve();\n        img.onerror = () => reject(new Error('Image loading failed'));\n        img.src = imageURL;\n      });\n      \n      // 计算局部区域\n      const baseCropSize = 200;\n      const cropSize = Math.round(baseCropSize / this.zoomLevel);\n      const centerX = targetAnnotation.x;\n      const centerY = targetAnnotation.y;\n      \n      const cropX = Math.max(0, Math.min(img.width - cropSize, centerX - cropSize / 2));\n      const cropY = Math.max(0, Math.min(img.height - cropSize, centerY - cropSize / 2));\n      const actualCropWidth = Math.min(cropSize, img.width - cropX);\n      const actualCropHeight = Math.min(cropSize, img.height - cropY);\n      \n      const canvasWidth = this.previewCanvas.width;\n      const canvasHeight = this.previewCanvas.height;\n      \n      // 清空canvas\n      this.previewCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n      \n      // 绘制局部放大图\n      this.previewCtx.drawImage(\n        img,\n        cropX, cropY, actualCropWidth, actualCropHeight,\n        0, 0, canvasWidth, canvasHeight\n      );\n      \n      // 计算标注点位置\n      const scaleX = canvasWidth / actualCropWidth;\n      const scaleY = canvasHeight / actualCropHeight;\n      const pointX = (centerX - cropX) * scaleX;\n      const pointY = (centerY - cropY) * scaleY;\n      \n      // 绘制目标标注点（特殊高亮）\n      this.renderDraggedAnnotation(pointX, pointY, targetOrder, targetAnnotation.direction);\n      \n      // 绘制其他标注点\n      annotations.forEach((annotation) => {\n        if (annotation.order === targetOrder) return;\n        \n        if (annotation.x >= cropX && annotation.x <= cropX + actualCropWidth &&\n            annotation.y >= cropY && annotation.y <= cropY + actualCropHeight) {\n          \n          const otherX = (annotation.x - cropX) * scaleX;\n          const otherY = (annotation.y - cropY) * scaleY;\n          this.renderLocalizedAnnotation(otherX, otherY, annotation.order || 0, annotation.direction, false);\n        }\n      });\n      \n      // 绘制放大倍数提示\n      this.renderZoomInfo(scaleX, scaleY);\n      \n      // 清理临时URL\n      if (imageURL && imageURL.startsWith('blob:') && !imageData.url) {\n        setTimeout(() => URL.revokeObjectURL(imageURL), 5000);\n      }\n      \n      console.log('Specific order preview rendering completed');\n      \n    } catch (error) {\n      console.error('Specific order preview rendering failed:', error);\n      this.showNoPreview(`Preview loading failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * 渲染被拖动的标注点（特殊样式）\n   */\n  renderDraggedAnnotation(x, y, label, direction) {\n    // 使用特殊的颜色和样式表示正在拖动\n    const fillColor = '#ff9800'; // 橙色表示拖动状态\n    const radius = 6;\n    const borderWidth = 3;\n    \n    // 绘制脉冲效果的外圈\n    this.previewCtx.beginPath();\n    this.previewCtx.arc(x, y, radius + 5, 0, 2 * Math.PI);\n    this.previewCtx.strokeStyle = '#ff9800';\n    this.previewCtx.lineWidth = 2;\n    this.previewCtx.setLineDash([3, 3]);\n    this.previewCtx.stroke();\n    this.previewCtx.setLineDash([]);\n    \n    // 绘制主标注点\n    this.previewCtx.beginPath();\n    this.previewCtx.arc(x, y, radius, 0, 2 * Math.PI);\n    this.previewCtx.fillStyle = fillColor;\n    this.previewCtx.fill();\n    \n    // 绘制边框\n    this.previewCtx.strokeStyle = '#ffffff';\n    this.previewCtx.lineWidth = borderWidth;\n    this.previewCtx.stroke();\n\n    // 绘制方向箭头（如果有方向信息）\n    this.renderDirectionArrow(x, y, direction, true);\n\n    // 绘制序号\n    this.previewCtx.fillStyle = '#000000';\n    this.previewCtx.font = 'bold 9px Arial';\n    this.previewCtx.textAlign = 'center';\n    this.previewCtx.textBaseline = 'middle';\n    this.previewCtx.fillText(label.toString(), x, y);\n    \n    // 添加拖动指示\n    this.previewCtx.fillStyle = '#ff9800';\n    this.previewCtx.font = 'bold 7px Arial';\n    this.previewCtx.fillText('Dragging', x, y + radius + 12);\n  }\n} ","/**\n * 笔记管理器\n * \n * 功能：\n * - 管理植物级和图像级笔记\n * - 与HttpFileSystemManager集成\n * - 独立于跳过功能的笔记系统\n * - 支持搜索、过滤和统计\n */\n\nexport class NoteManager {\n  constructor(httpFileSystemManager) {\n    this.httpManager = httpFileSystemManager;\n    this.notes = new Map(); // 笔记缓存\n    this.cacheTimestamps = new Map(); // 缓存时间戳\n    this.isInitialized = false;\n    this.cacheExpiration = 5 * 60 * 1000; // 5分钟缓存过期\n    this.requestQueue = new Map(); // 请求队列防止重复请求\n    this.noteCounts = new Map(); // 笔记数量缓存\n    \n    // Performance optimizations\n    this.bulkNoteData = null; // 批量笔记数据缓存\n    this.bulkDataTimestamp = 0; // 批量数据时间戳\n    this.performanceMetrics = {\n      requestCount: 0,\n      bulkRequestCount: 0,\n      cacheHits: 0,\n      networkTime: 0\n    };\n  }\n\n  /**\n   * 获取基础URL (用于NoteUI兼容性)\n   */\n  get baseUrl() {\n    return this.httpManager.baseUrl;\n  }\n\n  /**\n   * 初始化笔记管理器\n   */\n  async initialize() {\n    try {\n      await this.httpManager.ensureConnection();\n      this.isInitialized = true;\n      console.log('NoteManager 初始化成功');\n      return true;\n    } catch (error) {\n      console.error('NoteManager 初始化失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 确保连接可用\n   */\n  async ensureConnection() {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n    await this.httpManager.ensureConnection();\n  }\n\n  /**\n   * 添加植物笔记\n   */\n  async addPlantNote(plantId, noteData) {\n    if (!plantId) {\n      throw new Error('植物ID不能为空');\n    }\n    if (!noteData.title || !noteData.content) {\n      throw new Error('笔记标题和内容不能为空');\n    }\n\n    await this.ensureConnection();\n\n    return this.httpManager.withRetry(async () => {\n      const response = await fetch(`${this.httpManager.baseUrl}/notes/plant/${encodeURIComponent(plantId)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(noteData)\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n\n      if (result.success) {\n        // 🔧 FIX: Force complete cache clear for immediate visibility of new note\n        this.clearCache();\n        console.log(`植物笔记创建成功: ${result.data.noteId} - 缓存已完全清除`);\n        return result.data.noteId;\n      }\n\n      throw new Error(result.error || '创建植物笔记失败');\n    }, `创建植物 ${plantId} 笔记`);\n  }\n\n  /**\n   * 添加图像笔记\n   */\n  async addImageNote(plantId, imageId, noteData) {\n    if (!plantId) {\n      throw new Error('植物ID不能为空');\n    }\n    if (!imageId) {\n      throw new Error('图像ID不能为空');\n    }\n    if (!noteData.title || !noteData.content) {\n      throw new Error('笔记标题和内容不能为空');\n    }\n\n    await this.ensureConnection();\n\n    return this.httpManager.withRetry(async () => {\n      const response = await fetch(`${this.httpManager.baseUrl}/notes/image/${encodeURIComponent(plantId)}/${encodeURIComponent(imageId)}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(noteData)\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n\n      if (result.success) {\n        // 🔧 FIX: Force complete cache clear for immediate visibility of new note\n        this.clearCache();\n        console.log(`图像笔记创建成功: ${result.data.noteId} - 缓存已完全清除`);\n        return result.data.noteId;\n      }\n\n      throw new Error(result.error || '创建图像笔记失败');\n    }, `创建图像 ${imageId} 笔记`);\n  }\n\n  /**\n   * 获取植物笔记 (优化版本，优先使用批量数据)\n   */\n  async getPlantNotes(plantId) {\n    if (!plantId) {\n      throw new Error('植物ID不能为空');\n    }\n\n    await this.ensureConnection();\n\n    const cacheKey = `plant_${plantId}`;\n    \n    // 首先检查是否有批量数据缓存\n    if (this.bulkNoteData && !this.isBulkDataExpired()) {\n      const plantNotes = this.bulkNoteData.plantNotes[plantId] || [];\n      this.notes.set(cacheKey, plantNotes);\n      this.performanceMetrics.cacheHits++;\n      return plantNotes;\n    }\n    \n    // 检查独立缓存\n    if (this.notes.has(cacheKey) && !this.isCacheExpired(cacheKey)) {\n      this.performanceMetrics.cacheHits++;\n      return this.notes.get(cacheKey);\n    }\n\n    return this.httpManager.withRetry(async () => {\n      const startTime = performance.now();\n      const url = `${this.httpManager.baseUrl}/notes/plant/${encodeURIComponent(plantId)}`;\n      console.log(`[NoteManager] 请求植物笔记 URL: ${url}`);\n      \n      try {\n        const response = await fetch(url);\n        this.performanceMetrics.requestCount++;\n\n        if (!response.ok) {\n          console.error(`[NoteManager] 请求失败: ${response.status} ${response.statusText}`);\n          \n          // 提供更详细的错误信息\n          if (response.status === 404) {\n            // 404 可能表示该植物没有笔记，返回空数组而不是抛出错误\n            const emptyResult = [];\n            this.setCache(cacheKey, emptyResult);\n            return emptyResult;\n          } else if (response.status === 500) {\n            throw new Error(`服务器内部错误 (500): 请检查后端服务状态`);\n          } else if (response.status === 403) {\n            throw new Error(`访问被拒绝 (403): 请检查权限设置`);\n          } else {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n          }\n        }\n\n        const result = await response.json();\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n\n        if (result.success) {\n          // 缓存结果\n          this.setCache(cacheKey, result.data);\n          console.log(`[NoteManager] 成功获取植物 ${plantId} 的 ${result.data.length} 条笔记`);\n          return result.data;\n        }\n\n        throw new Error(result.error || '获取植物笔记失败');\n      } catch (fetchError) {\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n        // 网络错误处理\n        if (fetchError.name === 'TypeError' && fetchError.message.includes('fetch')) {\n          throw new Error(`网络连接失败: 无法连接到后端服务 (${url})`);\n        }\n        throw fetchError;\n      }\n    }, `获取植物 ${plantId} 笔记`);\n  }\n\n  /**\n   * 获取图像笔记 (优化版本，优先使用批量数据)\n   */\n  async getImageNotes(plantId, imageId) {\n    if (!plantId) {\n      throw new Error('植物ID不能为空');\n    }\n    if (!imageId) {\n      throw new Error('图像ID不能为空');\n    }\n\n    await this.ensureConnection();\n\n    const cacheKey = `image_${plantId}_${imageId}`;\n    \n    // 首先检查是否有批量数据缓存\n    if (this.bulkNoteData && !this.isBulkDataExpired()) {\n      const imageNotes = this.bulkNoteData.imageNotes[imageId] || [];\n      this.notes.set(cacheKey, imageNotes);\n      this.performanceMetrics.cacheHits++;\n      return imageNotes;\n    }\n    \n    // 检查独立缓存\n    if (this.notes.has(cacheKey) && !this.isCacheExpired(cacheKey)) {\n      this.performanceMetrics.cacheHits++;\n      return this.notes.get(cacheKey);\n    }\n\n    return this.httpManager.withRetry(async () => {\n      const startTime = performance.now();\n      const url = `${this.httpManager.baseUrl}/notes/image/${encodeURIComponent(plantId)}/${encodeURIComponent(imageId)}`;\n      console.log(`[NoteManager] 请求图像笔记 URL: ${url}`);\n      \n      try {\n        const response = await fetch(url);\n        this.performanceMetrics.requestCount++;\n\n        if (!response.ok) {\n          console.error(`[NoteManager] 请求失败: ${response.status} ${response.statusText}`);\n          \n          // 提供更详细的错误信息\n          if (response.status === 404) {\n            // 404 可能表示该图像没有笔记，返回空数组而不是抛出错误\n            const emptyResult = [];\n            this.setCache(cacheKey, emptyResult);\n            return emptyResult;\n          } else if (response.status === 500) {\n            throw new Error(`服务器内部错误 (500): 请检查后端服务状态`);\n          } else if (response.status === 403) {\n            throw new Error(`访问被拒绝 (403): 请检查权限设置`);\n          } else {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n          }\n        }\n\n        const result = await response.json();\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n\n        if (result.success) {\n          // 缓存结果\n          this.setCache(cacheKey, result.data);\n          console.log(`[NoteManager] 成功获取图像 ${imageId} 的 ${result.data.length} 条笔记`);\n          return result.data;\n        }\n\n        throw new Error(result.error || '获取图像笔记失败');\n      } catch (fetchError) {\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n        // 网络错误处理\n        if (fetchError.name === 'TypeError' && fetchError.message.includes('fetch')) {\n          throw new Error(`网络连接失败: 无法连接到后端服务 (${url})`);\n        }\n        throw fetchError;\n      }\n    }, `获取图像 ${imageId} 笔记`);\n  }\n\n  /**\n   * 更新笔记\n   */\n  async updateNote(noteId, updates) {\n    if (!noteId) {\n      throw new Error('笔记ID不能为空');\n    }\n\n    await this.ensureConnection();\n\n    return this.httpManager.withRetry(async () => {\n      const response = await fetch(`${this.httpManager.baseUrl}/notes/${encodeURIComponent(noteId)}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(updates)\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n\n      if (result.success) {\n        // 清除相关缓存\n        this.clearCache();\n        console.log(`笔记更新成功: ${noteId}`);\n        return result.data;\n      }\n\n      throw new Error(result.error || '更新笔记失败');\n    }, `更新笔记 ${noteId}`);\n  }\n\n  /**\n   * 删除笔记\n   */\n  async deleteNote(noteId) {\n    if (!noteId) {\n      throw new Error('笔记ID不能为空');\n    }\n\n    await this.ensureConnection();\n\n    return this.httpManager.withRetry(async () => {\n      const response = await fetch(`${this.httpManager.baseUrl}/notes/${encodeURIComponent(noteId)}`, {\n        method: 'DELETE'\n      });\n\n      if (!response.ok) {\n        // 🔧 FIX: Handle 404 gracefully - note may already be deleted\n        if (response.status === 404) {\n          console.warn(`笔记 ${noteId} 不存在或已被删除`);\n          // Clear cache and return success since the goal (note not existing) is achieved\n          this.clearCache();\n          return true;\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n\n      if (result.success) {\n        // 清除相关缓存\n        this.clearCache();\n        console.log(`笔记删除成功: ${noteId}`);\n        return true;\n      }\n\n      throw new Error(result.error || '删除笔记失败');\n    }, `删除笔记 ${noteId}`);\n  }\n\n  /**\n   * 获取单个笔记\n   */\n  async getNote(noteId) {\n    if (!noteId) {\n      throw new Error('笔记ID不能为空');\n    }\n\n    await this.ensureConnection();\n\n    return this.httpManager.withRetry(async () => {\n      const response = await fetch(`${this.httpManager.baseUrl}/notes/${encodeURIComponent(noteId)}`);\n\n      if (!response.ok) {\n        if (response.status === 404) {\n          return null;\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n\n      if (result.success) {\n        return result.data;\n      }\n\n      throw new Error(result.error || '获取笔记失败');\n    }, `获取笔记 ${noteId}`);\n  }\n\n  /**\n   * 搜索笔记\n   */\n  async searchNotes(query, filters = {}) {\n    await this.ensureConnection();\n\n    return this.httpManager.withRetry(async () => {\n      const searchParams = new URLSearchParams();\n      \n      if (query) {\n        searchParams.append('query', query);\n      }\n      \n      if (filters.plantId) {\n        searchParams.append('plantId', filters.plantId);\n      }\n      \n      if (filters.noteType) {\n        searchParams.append('noteType', filters.noteType);\n      }\n      \n      if (filters.author) {\n        searchParams.append('author', filters.author);\n      }\n\n      const searchUrl = `${this.httpManager.baseUrl}/notes/search?${searchParams}`;\n      console.log('[NoteManager] Making search request to:', searchUrl);\n      \n      const response = await fetch(searchUrl);\n\n      if (!response.ok) {\n        const error = new Error(`HTTP ${response.status}: ${response.statusText}`);\n        error.url = searchUrl;\n        error.status = response.status;\n        console.error('[NoteManager] Search request failed:', error);\n        throw error;\n      }\n\n      const result = await response.json();\n\n      if (result.success) {\n        return result.data;\n      }\n\n      throw new Error(result.error || '搜索笔记失败');\n    }, '搜索笔记');\n  }\n\n  /**\n   * 获取笔记统计\n   */\n  async getStats() {\n    await this.ensureConnection();\n\n    return this.httpManager.withRetry(async () => {\n      const response = await fetch(`${this.httpManager.baseUrl}/notes/stats`);\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n\n      if (result.success) {\n        return result.data;\n      }\n\n      throw new Error(result.error || '获取笔记统计失败');\n    }, '获取笔记统计');\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache() {\n    this.notes.clear();\n    this.cacheTimestamps.clear();\n    this.noteCounts.clear();\n    \n    // 🔧 FIX: Clear bulk data cache to prevent stale data issues\n    this.bulkNoteData = null;\n    this.bulkDataTimestamp = 0;\n    \n    console.log('笔记缓存已完全清除 (包括批量数据缓存)');\n  }\n\n  /**\n   * 使特定缓存失效\n   */\n  invalidateCache(plantId, imageId = null) {\n    const plantKey = `plant_${plantId}`;\n    this.notes.delete(plantKey);\n    \n    if (imageId) {\n      const imageKey = `image_${plantId}_${imageId}`;\n      this.notes.delete(imageKey);\n    }\n  }\n\n  /**\n   * 获取缓存统计\n   */\n  getCacheStats() {\n    return {\n      cacheSize: this.notes.size,\n      isInitialized: this.isInitialized,\n      cacheKeys: Array.from(this.notes.keys())\n    };\n  }\n\n  /**\n   * 验证笔记数据格式\n   */\n  validateNoteData(noteData) {\n    const errors = [];\n\n    if (!noteData.title || noteData.title.trim() === '') {\n      errors.push('标题不能为空');\n    }\n\n    if (!noteData.content || noteData.content.trim() === '') {\n      errors.push('内容不能为空');\n    }\n\n    if (noteData.title && noteData.title.length > 100) {\n      errors.push('标题长度不能超过100字符');\n    }\n\n    if (noteData.content && noteData.content.length > 5000) {\n      errors.push('内容长度不能超过5000字符');\n    }\n\n    if (noteData.noteType && !['general', 'observation', 'annotation'].includes(noteData.noteType)) {\n      errors.push('笔记类型必须是 general、observation 或 annotation');\n    }\n\n    if (noteData.tags && !Array.isArray(noteData.tags)) {\n      errors.push('标签必须是数组');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * 格式化笔记数据用于显示\n   */\n  formatNoteForDisplay(note) {\n    return {\n      ...note,\n      formattedTimestamp: new Date(note.timestamp).toLocaleString('zh-CN'),\n      formattedLastModified: new Date(note.lastModified).toLocaleString('zh-CN'),\n      shortContent: note.content.length > 100 ? \n        note.content.substring(0, 100) + '...' : \n        note.content,\n      tagsText: note.tags.join(', ')\n    };\n  }\n\n  /**\n   * 清理资源\n   */\n  cleanup() {\n    this.clearCache();\n    this.isInitialized = false;\n    \n    // 清理定时器（如果有）\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n    \n    console.log('NoteManager 清理完成');\n  }\n\n  /**\n   * 启动自动清理\n   */\n  startAutoCleanup() {\n    // 每10分钟清理一次过期缓存\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupExpiredCache();\n    }, 10 * 60 * 1000);\n  }\n\n  /**\n   * 检查缓存是否过期\n   */\n  isCacheExpired(key) {\n    const timestamp = this.cacheTimestamps.get(key);\n    if (!timestamp) return true;\n    return Date.now() - timestamp > this.cacheExpiration;\n  }\n\n  /**\n   * 设置缓存\n   */\n  setCache(key, data) {\n    this.notes.set(key, data);\n    this.cacheTimestamps.set(key, Date.now());\n  }\n\n  /**\n   * 防重复请求装饰器\n   */\n  async withRequestDeduplication(key, requestFn) {\n    // 如果已有相同请求在进行，返回该请求\n    if (this.requestQueue.has(key)) {\n      return this.requestQueue.get(key);\n    }\n\n    // 创建新请求\n    const requestPromise = requestFn();\n    this.requestQueue.set(key, requestPromise);\n\n    try {\n      const result = await requestPromise;\n      this.requestQueue.delete(key);\n      return result;\n    } catch (error) {\n      this.requestQueue.delete(key);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取笔记数量（快速检查）\n   */\n  async getNoteCount(plantId, imageId = null) {\n    const countKey = imageId ? `image_${plantId}_${imageId}` : `plant_${plantId}`;\n    \n    // 如果有缓存的数量，直接返回\n    if (this.noteCounts.has(countKey)) {\n      return this.noteCounts.get(countKey);\n    }\n\n    // 如果有完整的笔记缓存，计算数量\n    const cacheKey = imageId ? `image_${plantId}_${imageId}` : `plant_${plantId}`;\n    if (this.notes.has(cacheKey) && !this.isCacheExpired(cacheKey)) {\n      const notes = this.notes.get(cacheKey);\n      const count = notes.length;\n      this.noteCounts.set(countKey, count);\n      return count;\n    }\n\n    // 异步获取笔记（不阻塞UI）\n    this.loadNotesAsync(plantId, imageId);\n    return 0; // 返回默认值\n  }\n\n  /**\n   * 异步加载笔记（后台加载）\n   */\n  async loadNotesAsync(plantId, imageId = null) {\n    try {\n      if (imageId) {\n        await this.getImageNotes(plantId, imageId);\n      } else {\n        await this.getPlantNotes(plantId);\n      }\n    } catch (error) {\n      console.warn('后台加载笔记失败:', error);\n    }\n  }\n\n  /**\n   * 预加载笔记（性能优化）\n   */\n  async preloadNotes(plantId, imageIds = []) {\n    const promises = [];\n    \n    // 预加载植物笔记\n    promises.push(this.loadNotesAsync(plantId));\n    \n    // 预加载图像笔记\n    imageIds.forEach(imageId => {\n      promises.push(this.loadNotesAsync(plantId, imageId));\n    });\n    \n    try {\n      await Promise.allSettled(promises);\n      console.log(`预加载完成: 植物 ${plantId} 和 ${imageIds.length} 个图像的笔记`);\n    } catch (error) {\n      console.warn('预加载笔记失败:', error);\n    }\n  }\n\n  /**\n   * 批量获取所有笔记数据 (性能优化的核心方法)\n   */\n  async getAllNotesInBulk() {\n    console.log('[NoteManager] 开始批量获取所有笔记数据...');\n    \n    await this.ensureConnection();\n    \n    // 检查批量数据缓存\n    if (this.bulkNoteData && !this.isBulkDataExpired()) {\n      console.log('[NoteManager] 使用缓存的批量笔记数据');\n      this.performanceMetrics.cacheHits++;\n      return this.bulkNoteData;\n    }\n\n    return this.httpManager.withRetry(async () => {\n      const startTime = performance.now();\n      const url = `${this.httpManager.baseUrl}/notes/bulk`;\n      console.log(`[NoteManager] 请求批量笔记数据 URL: ${url}`);\n      \n      try {\n        const response = await fetch(url, {\n          headers: {\n            'Cache-Control': 'no-cache'\n          }\n        });\n        this.performanceMetrics.bulkRequestCount++;\n\n        if (!response.ok) {\n          if (response.status === 404) {\n            console.warn('[NoteManager] 批量笔记端点不存在，将回退到单独请求模式');\n            return null; // 表示不支持批量API\n          }\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const result = await response.json();\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n\n        if (result.success) {\n          // 缓存批量数据\n          this.bulkNoteData = {\n            plantNotes: result.data.plantNotes || {},\n            imageNotes: result.data.imageNotes || {},\n            statistics: result.data.statistics || {}\n          };\n          this.bulkDataTimestamp = Date.now();\n          \n          // 同时更新个别缓存以保持一致性\n          this.updateIndividualCacheFromBulk();\n          \n          const plantCount = Object.keys(this.bulkNoteData.plantNotes).length;\n          const imageCount = Object.keys(this.bulkNoteData.imageNotes).length;\n          console.log(`[NoteManager] 成功获取批量笔记数据: ${plantCount} 个植物, ${imageCount} 个图像`);\n          \n          return this.bulkNoteData;\n        }\n\n        throw new Error(result.error || '获取批量笔记数据失败');\n      } catch (fetchError) {\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n        \n        if (fetchError.name === 'TypeError' && fetchError.message.includes('fetch')) {\n          throw new Error(`网络连接失败: 无法连接到后端服务 (${url})`);\n        }\n        throw fetchError;\n      }\n    }, '批量获取笔记数据');\n  }\n\n  /**\n   * 检查批量数据是否过期\n   */\n  isBulkDataExpired() {\n    if (!this.bulkDataTimestamp) return true;\n    return Date.now() - this.bulkDataTimestamp > this.cacheExpiration;\n  }\n\n  /**\n   * 从批量数据更新个别缓存\n   */\n  updateIndividualCacheFromBulk() {\n    if (!this.bulkNoteData) return;\n    \n    // 更新植物笔记缓存\n    for (const [plantId, notes] of Object.entries(this.bulkNoteData.plantNotes)) {\n      const cacheKey = `plant_${plantId}`;\n      this.setCache(cacheKey, notes);\n    }\n    \n    // 更新图像笔记缓存\n    for (const [imageId, notes] of Object.entries(this.bulkNoteData.imageNotes)) {\n      // 从imageId推断plantId (格式: plantId_viewAngle_imageName)\n      const plantId = imageId.split('_')[0];\n      const cacheKey = `image_${plantId}_${imageId}`;\n      this.setCache(cacheKey, notes);\n    }\n  }\n\n  /**\n   * 获取快速笔记统计（用于Badge更新）\n   */\n  async getQuickNoteStats() {\n    console.log('[NoteManager] 获取快速笔记统计...');\n    \n    try {\n      const bulkData = await this.getAllNotesInBulk();\n      \n      if (!bulkData) {\n        console.warn('[NoteManager] 批量API不可用，回退到传统模式');\n        return null;\n      }\n      \n      const stats = {};\n      \n      // 计算每个植物的笔记总数\n      for (const [plantId, plantNotes] of Object.entries(bulkData.plantNotes)) {\n        const plantNotesCount = plantNotes.length;\n        let imageNotesCount = 0;\n        \n        // 统计该植物所有图像的笔记数\n        for (const [imageId, imageNotes] of Object.entries(bulkData.imageNotes)) {\n          if (imageId.startsWith(plantId + '_')) {\n            imageNotesCount += imageNotes.length;\n          }\n        }\n        \n        stats[plantId] = {\n          plantNotes: plantNotesCount,\n          imageNotes: imageNotesCount,\n          total: plantNotesCount + imageNotesCount\n        };\n      }\n      \n      console.log(`[NoteManager] 快速统计完成: ${Object.keys(stats).length} 个植物`);\n      return stats;\n    } catch (error) {\n      console.error('[NoteManager] 获取快速笔记统计失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 获取性能指标\n   */\n  getPerformanceMetrics() {\n    return {\n      ...this.performanceMetrics,\n      cacheSize: this.notes.size,\n      hasBulkData: !!this.bulkNoteData,\n      bulkDataAge: this.bulkDataTimestamp ? Date.now() - this.bulkDataTimestamp : null,\n      averageRequestTime: this.performanceMetrics.requestCount > 0 \n        ? this.performanceMetrics.networkTime / this.performanceMetrics.requestCount \n        : 0\n    };\n  }\n\n  /**\n   * 重置性能指标\n   */\n  resetPerformanceMetrics() {\n    this.performanceMetrics = {\n      requestCount: 0,\n      bulkRequestCount: 0,\n      cacheHits: 0,\n      networkTime: 0\n    };\n  }\n\n  /**\n   * 强制刷新批量数据\n   */\n  async refreshBulkData() {\n    console.log('[NoteManager] 强制刷新批量数据...');\n    this.bulkNoteData = null;\n    this.bulkDataTimestamp = 0;\n    return await this.getAllNotesInBulk();\n  }\n\n  /**\n   * 清理过期缓存\n   */\n  cleanupExpiredCache() {\n    const now = Date.now();\n    const expiredKeys = [];\n    \n    for (const [key, timestamp] of this.cacheTimestamps) {\n      if (now - timestamp > this.cacheExpiration) {\n        expiredKeys.push(key);\n      }\n    }\n    \n    expiredKeys.forEach(key => {\n      this.notes.delete(key);\n      this.cacheTimestamps.delete(key);\n    });\n    \n    // 清理过期的批量数据\n    if (this.isBulkDataExpired()) {\n      this.bulkNoteData = null;\n      this.bulkDataTimestamp = 0;\n    }\n    \n    if (expiredKeys.length > 0) {\n      console.log(`清理了 ${expiredKeys.length} 个过期缓存`);\n    }\n  }\n}","/**\n * Note System UI Component\n * \n * Features:\n * - Note modal dialogs\n * - Note list display\n * - Note editor\n * - Note search\n */\n\nexport class NoteUI {\n  constructor(noteManager) {\n    this.noteManager = noteManager;\n    this.currentPlantId = null;\n    this.currentImageId = null;\n    this.currentNote = null;\n    this.isEditMode = false;\n    \n    this.initializeUI();\n  }\n\n  /**\n   * Initialize UI components\n   */\n  initializeUI() {\n    // Delay initialization of all UI components to ensure DOM is fully loaded\n    setTimeout(() => {\n      this.createNoteModal();\n      this.createNoteListModal();\n      this.setupEventListeners();\n      this.createNoteButtons();\n      this.injectNoteStyles(); // 🔧 FIX: Add styles for separated note display\n      console.log('[NoteUI] UI initialization completed with note separation styles');\n      \n      // Initialize plant note badges after a short delay\n      setTimeout(() => {\n        this.updateAllPlantNoteBadges();\n      }, 500);\n      \n      // ADDITIONAL SAFETY: Update badges again after a longer delay to catch any timing issues\n      setTimeout(() => {\n        console.log('[NoteUI] Running additional badge update for safety');\n        this.updateAllPlantNoteBadges();\n      }, 2000);\n    }, 200);\n  }\n\n  /**\n   * Create note modal with improved styling\n   */\n  createNoteModal() {\n    console.log('[NoteUI] Creating note modal');\n    const modal = document.createElement('div');\n    modal.id = 'note-modal';\n    modal.className = 'modal';\n    modal.style.display = 'none'; // Ensure initial state is hidden\n    modal.innerHTML = `\n      <div class=\"modal-content note-modal-content\">\n        <div class=\"modal-header\">\n          <h2 id=\"note-modal-title\">Add Note</h2>\n          <button class=\"close-button\" id=\"note-modal-close\"></button>\n        </div>\n        <div class=\"modal-body\">\n          <div class=\"note-form\">\n            <div class=\"form-group\">\n              <label for=\"note-title\">Title <span class=\"required\">*</span></label>\n              <input type=\"text\" id=\"note-title\" maxlength=\"100\" required placeholder=\"Enter note title...\">\n              <div class=\"char-counter\">\n                <span id=\"note-title-count\">0</span>/100\n              </div>\n            </div>\n            \n            <div class=\"form-group\">\n              <label for=\"note-type\">Type</label>\n              <select id=\"note-type\">\n                <option value=\"general\">General Note</option>\n                <option value=\"observation\">Observation Record</option>\n                <option value=\"annotation\">Annotation Description</option>\n              </select>\n            </div>\n            \n            <div class=\"form-group\">\n              <label for=\"note-content\">Content <span class=\"required\">*</span></label>\n              <textarea id=\"note-content\" rows=\"6\" maxlength=\"5000\" required placeholder=\"Enter note content...\"></textarea>\n              <div class=\"char-counter\">\n                <span id=\"note-content-count\">0</span>/5000\n              </div>\n            </div>\n            \n            <div class=\"form-group\">\n              <label for=\"note-tags\">Tags</label>\n              <input type=\"text\" id=\"note-tags\" placeholder=\"Separate multiple tags with commas\">\n              <div class=\"form-help\">Example: observation, growth, issue</div>\n            </div>\n            \n            <div class=\"form-group\">\n              <label for=\"note-author\">Author</label>\n              <input type=\"text\" id=\"note-author\" value=\"User\" placeholder=\"Enter author name\">\n            </div>\n            \n            <!-- 🔧 NEW: Backward Propagation Option -->\n            <div class=\"form-group\" id=\"backward-propagation-group\" style=\"display: none;\">\n              <div class=\"checkbox-wrapper\">\n                <label class=\"checkbox-label\">\n                  <input type=\"checkbox\" id=\"note-backward-propagation\">\n                  <span class=\"checkbox-text\">Backward Propagation</span>\n                </label>\n                <div class=\"form-help\">Apply this note to all later-dated images of the current plant</div>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class=\"modal-footer\">\n          <button class=\"btn btn-secondary\" id=\"note-cancel-btn\">Cancel</button>\n          <button class=\"btn btn-primary\" id=\"note-save-btn\">Save</button>\n        </div>\n      </div>\n    `;\n    \n    document.body.appendChild(modal);\n    console.log('[NoteUI] Note modal created and set to hidden');\n  }\n\n  /**\n   * Create note list modal with improved styling\n   */\n  createNoteListModal() {\n    console.log('[NoteUI] Creating note list modal');\n    const modal = document.createElement('div');\n    modal.id = 'note-list-modal';\n    modal.className = 'modal';\n    modal.style.display = 'none'; // Ensure initial state is hidden\n    modal.innerHTML = `\n      <div class=\"modal-content note-list-modal-content\">\n        <div class=\"modal-header\">\n          <h2 id=\"note-list-modal-title\">Note List</h2>\n          <button class=\"close-button\" id=\"note-list-modal-close\"></button>\n        </div>\n        <div class=\"modal-body\">\n          <div class=\"note-list-controls\">\n            <div class=\"search-group\">\n              <input type=\"text\" id=\"note-search\" placeholder=\"Search notes...\">\n              <button class=\"btn btn-sm btn-secondary\" id=\"note-search-btn\">Search</button>\n            </div>\n            <div class=\"filter-group\">\n              <select id=\"note-type-filter\">\n                <option value=\"\">All Types</option>\n                <option value=\"general\">General Note</option>\n                <option value=\"observation\">Observation Record</option>\n                <option value=\"annotation\">Annotation Description</option>\n              </select>\n              <button class=\"btn btn-sm btn-primary\" id=\"add-note-btn\">Add Note</button>\n            </div>\n          </div>\n          <div class=\"note-list-container\">\n            <div id=\"note-list-content\">\n              <div class=\"loading-message\">Loading...</div>\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n    \n    document.body.appendChild(modal);\n    console.log('[NoteUI] Note list modal created and set to hidden');\n  }\n\n  /**\n   * Create note buttons\n   */\n  createNoteButtons() {\n    this.createPlantNoteButton();\n    this.createImageNoteButton();\n    // 🔧 REMOVED: Note display areas no longer needed - counts shown in buttons\n  }\n\n  /**\n   * Create plant notes button in toolbar\n   */\n  createPlantNoteButton() {\n    // Find toolbar section\n    const toolbarSection = document.querySelector('.toolbar-section');\n    if (!toolbarSection) {\n      console.warn('[NoteUI] Toolbar section not found, creating fallback container');\n      this.createFallbackPlantNoteContainer();\n      return;\n    }\n    \n    // Remove existing button\n    const existingBtn = document.getElementById('plant-note-btn');\n    if (existingBtn) {\n      existingBtn.remove();\n    }\n    \n    // Create button container within toolbar\n    let noteContainer = toolbarSection.querySelector('.plant-notes-section');\n    if (!noteContainer) {\n      noteContainer = document.createElement('div');\n      noteContainer.className = 'plant-notes-section';\n      noteContainer.style.cssText = `\n        margin-top: 10px;\n        padding-top: 10px;\n        border-top: 1px solid var(--border-color);\n      `;\n      toolbarSection.appendChild(noteContainer);\n    }\n    \n    // Create the button with note count display\n    const noteBtn = document.createElement('button');\n    noteBtn.id = 'plant-note-btn';\n    noteBtn.className = 'btn btn-small btn-secondary';\n    noteBtn.innerHTML = '📝 Plant Notes <span id=\"plant-note-count\" class=\"note-count-display\"></span>';\n    noteBtn.title = 'View or add plant notes';\n    noteBtn.style.cssText = `\n      display: none;\n      width: 100%;\n      margin-bottom: 5px;\n      position: relative;\n    `;\n    noteContainer.appendChild(noteBtn);\n    \n    console.log('[NoteUI] Plant notes button created in toolbar with count display');\n  }\n  \n  /**\n   * Create fallback container if toolbar not found\n   */\n  createFallbackPlantNoteContainer() {\n    const container = document.createElement('div');\n    container.className = 'plant-note-container';\n    container.style.cssText = `\n      position: fixed;\n      top: 80px;\n      right: 20px;\n      z-index: 1000;\n      background: rgba(255, 255, 255, 0.9);\n      padding: 10px;\n      border-radius: 8px;\n      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n      display: none;\n    `;\n    document.body.appendChild(container);\n    \n    const noteBtn = document.createElement('button');\n    noteBtn.id = 'plant-note-btn';\n    noteBtn.className = 'btn btn-info btn-sm note-btn';\n    noteBtn.innerHTML = '📝 Plant Notes';\n    noteBtn.title = 'View or add plant notes';\n    noteBtn.style.display = 'none';\n    container.appendChild(noteBtn);\n  }\n\n  /**\n   * Create image notes button in annotation controls\n   */\n  createImageNoteButton() {\n    console.log('[NoteUI] Creating image notes button');\n    \n    // Find annotation controls container\n    const annotationControls = document.querySelector('.annotation-controls');\n    if (!annotationControls) {\n      console.warn('[NoteUI] Annotation controls not found, creating fallback container');\n      this.createFallbackImageNoteContainer();\n      return;\n    }\n    \n    // Remove existing button\n    const existingBtn = document.getElementById('image-note-btn');\n    if (existingBtn) {\n      existingBtn.remove();\n    }\n    \n    // Create the icon button to match annotation controls style with count display\n    const noteBtn = document.createElement('button');\n    noteBtn.id = 'image-note-btn';\n    noteBtn.className = 'btn btn-icon';\n    noteBtn.innerHTML = '📝<span id=\"image-note-count\" class=\"note-count-overlay\"></span>';\n    noteBtn.title = 'View or add image notes';\n    noteBtn.style.cssText = `\n      display: none;\n      width: 32px;\n      height: 32px;\n      padding: 0;\n      font-size: 16px;\n      background-color: rgba(0, 0, 0, 0.7);\n      color: white;\n      border: none;\n      pointer-events: auto;\n      cursor: pointer;\n      border-radius: 0.375rem;\n      position: relative;\n    `;\n    \n    // Add to annotation controls\n    annotationControls.appendChild(noteBtn);\n    \n    console.log('[NoteUI] Image notes button created in annotation controls with count display');\n  }\n  \n  /**\n   * Create fallback container if annotation controls not found\n   */\n  createFallbackImageNoteContainer() {\n    const container = document.createElement('div');\n    container.className = 'image-note-container';\n    container.style.cssText = `\n      position: fixed;\n      top: 120px;\n      right: 20px;\n      z-index: 1000;\n      background: rgba(255, 255, 255, 0.9);\n      padding: 10px;\n      border-radius: 8px;\n      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n      display: none;\n    `;\n    document.body.appendChild(container);\n    \n    const noteBtn = document.createElement('button');\n    noteBtn.id = 'image-note-btn';\n    noteBtn.className = 'btn btn-info btn-sm note-btn';\n    noteBtn.innerHTML = '📝';\n    noteBtn.title = 'View or add image notes';\n    noteBtn.style.cssText = `\n      display: none;\n      pointer-events: auto;\n      cursor: pointer;\n    `;\n    container.appendChild(noteBtn);\n  }\n\n  /**\n   * Setup event listeners\n   */\n  setupEventListeners() {\n    // Delay event listener setup to ensure DOM elements are created\n    setTimeout(() => {\n      this.setupModalEventListeners();\n      this.setupButtonEventListeners();\n      this.setupInputEventListeners();\n      // 🔧 REMOVED: Note display event listeners no longer needed\n    }, 200);\n  }\n\n  /**\n   * Setup modal event listeners\n   */\n  setupModalEventListeners() {\n    // Note modal events\n    const noteModalClose = document.getElementById('note-modal-close');\n    if (noteModalClose) {\n      noteModalClose.addEventListener('click', () => {\n        this.closeNoteModal();\n      });\n    }\n\n    const noteCancelBtn = document.getElementById('note-cancel-btn');\n    if (noteCancelBtn) {\n      noteCancelBtn.addEventListener('click', () => {\n        this.closeNoteModal();\n      });\n    }\n\n    const noteSaveBtn = document.getElementById('note-save-btn');\n    if (noteSaveBtn) {\n      noteSaveBtn.addEventListener('click', () => {\n        this.saveNote();\n      });\n    }\n\n    // Note list modal events\n    const noteListModalClose = document.getElementById('note-list-modal-close');\n    if (noteListModalClose) {\n      noteListModalClose.addEventListener('click', () => {\n        this.closeNoteListModal();\n      });\n    }\n\n    const addNoteBtn = document.getElementById('add-note-btn');\n    if (addNoteBtn) {\n      addNoteBtn.addEventListener('click', () => {\n        this.closeNoteListModal();\n        this.showNoteModal();\n      });\n    }\n\n    const noteSearchBtn = document.getElementById('note-search-btn');\n    if (noteSearchBtn) {\n      noteSearchBtn.addEventListener('click', () => {\n        this.searchNotes();\n      });\n    }\n\n    const noteSearch = document.getElementById('note-search');\n    if (noteSearch) {\n      noteSearch.addEventListener('keypress', (e) => {\n        if (e.key === 'Enter') {\n          this.searchNotes();\n        }\n      });\n    }\n\n    // Close modal when clicking outside\n    document.addEventListener('click', (e) => {\n      if (e.target.id === 'note-modal') {\n        this.closeNoteModal();\n      }\n      if (e.target.id === 'note-list-modal') {\n        this.closeNoteListModal();\n      }\n    });\n  }\n\n  /**\n   * Setup button event listeners\n   */\n  setupButtonEventListeners() {\n    // Plant notes button\n    const plantNoteBtn = document.getElementById('plant-note-btn');\n    if (plantNoteBtn) {\n      console.log('[NoteUI] Plant notes button found, binding events');\n      plantNoteBtn.addEventListener('click', (event) => {\n        console.log('[NoteUI] Plant notes button clicked');\n        event.preventDefault();\n        this.showPlantNotes();\n      });\n    } else {\n      console.warn('[NoteUI] Plant notes button not found');\n    }\n\n    // Image notes button\n    const imageNoteBtn = document.getElementById('image-note-btn');\n    if (imageNoteBtn) {\n      console.log('[NoteUI] Image notes button found, binding events');\n      imageNoteBtn.addEventListener('click', (event) => {\n        console.log('[NoteUI] Image notes button clicked');\n        event.preventDefault();\n        this.showImageNotes();\n      });\n    } else {\n      console.warn('[NoteUI] Image notes button not found');\n    }\n  }\n\n  /**\n   * Setup input field event listeners\n   */\n  setupInputEventListeners() {\n    // Character counter\n    const noteTitle = document.getElementById('note-title');\n    if (noteTitle) {\n      noteTitle.addEventListener('input', () => {\n        this.updateCharCounter('note-title', 'note-title-count', 100);\n      });\n    }\n\n    const noteContent = document.getElementById('note-content');\n    if (noteContent) {\n      noteContent.addEventListener('input', () => {\n        this.updateCharCounter('note-content', 'note-content-count', 5000);\n      });\n    }\n  }\n\n  /**\n   * Show plant notes\n   */\n  async showPlantNotes() {\n    console.log('[NoteUI] showPlantNotes called');\n    if (!this.currentPlantId) {\n      console.warn('[NoteUI] No plant selected, cannot show plant notes');\n      this.showUserError('Please select a plant', 'You need to select a plant to view notes');\n      return;\n    }\n\n    // 🔧 FIX: 确保在显示植物笔记时清除图像ID，防止误创建图像笔记\n    this.currentImageId = null;\n    console.log('[NoteUI] Cleared currentImageId to ensure plant notes creation');\n    \n    document.getElementById('note-list-modal-title').textContent = `Plant Notes - ${this.currentPlantId}`;\n    \n    const modal = document.getElementById('note-list-modal');\n    if (modal) {\n      console.log('[NoteUI] Showing plant notes modal');\n      modal.style.display = 'flex';\n    }\n    \n    try {\n      await this.loadNoteList();\n    } catch (error) {\n      console.error('[NoteUI] Failed to load plant notes:', error);\n      this.showUserError('Failed to load notes', error.message);\n    }\n  }\n\n  /**\n   * Show image notes\n   */\n  async showImageNotes() {\n    console.log('[NoteUI] showImageNotes called');\n    console.log(`[NoteUI] Current state - plantId: ${this.currentPlantId}, imageId: ${this.currentImageId}`);\n    \n    // Also check the global app state as a fallback\n    const globalAppState = window.PlantAnnotationTool?.appState;\n    const fallbackPlantId = globalAppState?.currentPlant?.id;\n    const fallbackImageId = globalAppState?.currentImage?.id;\n    \n    console.log(`[NoteUI] Fallback state - plantId: ${fallbackPlantId}, imageId: ${fallbackImageId}`);\n    \n    const effectivePlantId = this.currentPlantId || fallbackPlantId;\n    const effectiveImageId = this.currentImageId || fallbackImageId;\n    \n    if (!effectivePlantId || !effectiveImageId) {\n      console.warn('[NoteUI] No plant or image selected, cannot show image notes');\n      this.showUserError('Please select plant and image', 'You need to select both plant and image to view image notes');\n      return;\n    }\n    \n    // Update current state if we used fallback values\n    if (!this.currentPlantId && fallbackPlantId) {\n      this.currentPlantId = fallbackPlantId;\n    }\n    if (!this.currentImageId && fallbackImageId) {\n      this.currentImageId = fallbackImageId;\n    }\n\n    document.getElementById('note-list-modal-title').textContent = `Image Notes - ${effectiveImageId}`;\n    \n    const modal = document.getElementById('note-list-modal');\n    if (modal) {\n      console.log('[NoteUI] Showing image notes modal');\n      modal.style.display = 'flex';\n    }\n    \n    try {\n      await this.loadNoteList();\n    } catch (error) {\n      console.error('[NoteUI] Failed to load image notes:', error);\n      this.showUserError('Failed to load notes', error.message);\n    }\n  }\n\n  /**\n   * Load note list (unified to show ALL notes for plant, consistent with search)\n   */\n  async loadNoteList() {\n    const listContainer = document.getElementById('note-list-content');\n    listContainer.innerHTML = '<div class=\"loading-message\">Loading...</div>';\n\n    try {\n      let notes;\n      if (this.currentImageId) {\n        // For image notes, get specific image notes\n        notes = await this.noteManager.getImageNotes(this.currentPlantId, this.currentImageId);\n        console.log(`[NoteUI] Loaded ${notes.length} image notes for ${this.currentImageId}`);\n      } else {\n        // 🔧 FIX: For plant modal initial load, show ONLY plant-level notes\n        // Search function will show all notes when user explicitly searches\n        console.log(`[NoteUI] Loading plant-level notes only for ${this.currentPlantId}`);\n        notes = await this.noteManager.getPlantNotes(this.currentPlantId);\n        console.log(`[NoteUI] Plant API loaded ${notes.length} plant-only notes for ${this.currentPlantId}`);\n      }\n\n      this.renderNoteList(notes);\n      console.log(`[NoteUI] Modal refreshed with ${notes.length} notes`);\n    } catch (error) {\n      console.error('Failed to load note list:', error);\n      listContainer.innerHTML = `<div class=\"error-message\">Loading failed: ${error.message}</div>`;\n    }\n  }\n\n  /**\n   * Render note list with proper plant/image note separation\n   */\n  renderNoteList(notes) {\n    const listContainer = document.getElementById('note-list-content');\n    \n    if (!notes || notes.length === 0) {\n      listContainer.innerHTML = '<div class=\"empty-message\">No notes available</div>';\n      return;\n    }\n\n    // 🔧 FIX: Separate plant-level notes from image-level notes\n    const plantNotes = notes.filter(note => !note.imageId);\n    const imageNotes = notes.filter(note => note.imageId);\n    \n    console.log(`[NoteUI] Rendering ${plantNotes.length} plant notes and ${imageNotes.length} image notes`);\n\n    let html = '';\n    \n    // Render plant-level notes section\n    if (plantNotes.length > 0) {\n      html += `\n        <div class=\"notes-section\">\n          <div class=\"section-header\">\n            <h3 class=\"section-title\">\n              <span class=\"section-icon\">📝</span>\n              Plant Notes (${plantNotes.length})\n            </h3>\n          </div>\n          <div class=\"notes-list\">\n            ${this.renderNoteItems(plantNotes, 'plant')}\n          </div>\n        </div>\n      `;\n    }\n    \n    // Render image-level notes section\n    if (imageNotes.length > 0) {\n      html += `\n        <div class=\"notes-section\">\n          <div class=\"section-header\">\n            <h3 class=\"section-title\">\n              <span class=\"section-icon\">🖼️</span>\n              Image Notes (${imageNotes.length})\n            </h3>\n          </div>\n          <div class=\"notes-list\">\n            ${this.renderNoteItems(imageNotes, 'image')}\n          </div>\n        </div>\n      `;\n    }\n\n    listContainer.innerHTML = html;\n\n    // Bind edit and delete events\n    this.bindNoteActionEvents(listContainer);\n  }\n\n  /**\n   * Helper method to render note items with proper type indicators\n   */\n  renderNoteItems(notes, noteScope) {\n    return notes.map(note => {\n      const formattedNote = this.noteManager.formatNoteForDisplay(note);\n      \n      // 🔧 FIX: Add visual indicators and image info for different note types\n      let scopeIndicator = '';\n      let imageInfo = '';\n      \n      if (noteScope === 'plant') {\n        scopeIndicator = '<span class=\"note-scope plant-scope\">📝 Plant</span>';\n      } else if (noteScope === 'image') {\n        scopeIndicator = '<span class=\"note-scope image-scope\">🖼️ Image</span>';\n        // Extract image name from imageId for display\n        const imageName = note.imageId ? note.imageId.split('_').slice(-1)[0] : 'Unknown';\n        imageInfo = `<div class=\"image-info\">📷 Image: ${this.escapeHtml(imageName)}</div>`;\n      }\n      \n      return `\n        <div class=\"note-item ${noteScope}-note\" data-note-id=\"${note.noteId}\">\n          <div class=\"note-item-header\">\n            <h4 class=\"note-title\">${this.escapeHtml(formattedNote.title)}</h4>\n            <div class=\"note-actions\">\n              <button class=\"btn btn-sm btn-secondary edit-note-btn\" data-note-id=\"${note.noteId}\">Edit</button>\n              <button class=\"btn btn-sm btn-danger delete-note-btn\" data-note-id=\"${note.noteId}\">Delete</button>\n            </div>\n          </div>\n          <div class=\"note-item-meta\">\n            ${scopeIndicator}\n            <span class=\"note-type note-type-${note.noteType}\">${this.getNoteTypeText(note.noteType)}</span>\n            <span class=\"note-timestamp\">${formattedNote.formattedTimestamp}</span>\n            <span class=\"note-author\">Author: ${this.escapeHtml(note.author)}</span>\n          </div>\n          ${imageInfo}\n          <div class=\"note-content\">\n            ${this.escapeHtml(formattedNote.shortContent)}\n          </div>\n          ${note.tags.length > 0 ? `\n            <div class=\"note-tags\">\n              ${note.tags.map(tag => `<span class=\"tag\">${this.escapeHtml(tag)}</span>`).join('')}\n            </div>\n          ` : ''}\n        </div>\n      `;\n    }).join('');\n  }\n\n  /**\n   * Helper method to bind note action events\n   */\n  bindNoteActionEvents(container) {\n    container.querySelectorAll('.edit-note-btn').forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        const noteId = e.target.dataset.noteId;\n        this.editNote(noteId);\n      });\n    });\n\n    container.querySelectorAll('.delete-note-btn').forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        const noteId = e.target.dataset.noteId;\n        this.deleteNote(noteId);\n      });\n    });\n  }\n\n  /**\n   * Inject CSS styles for separated note display\n   */\n  injectNoteStyles() {\n    const styleId = 'note-separation-styles';\n    if (document.getElementById(styleId)) return; // Already injected\n\n    const style = document.createElement('style');\n    style.id = styleId;\n    style.textContent = `\n      /* Note section separation styles */\n      .notes-section {\n        margin-bottom: 20px;\n        border: 1px solid #e5e7eb;\n        border-radius: 8px;\n        overflow: hidden;\n      }\n      \n      .section-header {\n        background: #f9fafb;\n        padding: 12px 16px;\n        border-bottom: 1px solid #e5e7eb;\n      }\n      \n      .section-title {\n        margin: 0;\n        font-size: 16px;\n        font-weight: 600;\n        color: #374151;\n        display: flex;\n        align-items: center;\n        gap: 8px;\n      }\n      \n      .section-icon {\n        font-size: 18px;\n      }\n      \n      .notes-list {\n        background: white;\n      }\n      \n      /* Note scope indicators */\n      .note-scope {\n        display: inline-flex;\n        align-items: center;\n        gap: 4px;\n        padding: 2px 8px;\n        border-radius: 12px;\n        font-size: 12px;\n        font-weight: 500;\n        margin-right: 8px;\n      }\n      \n      .plant-scope {\n        background: #dcfce7;\n        color: #166534;\n      }\n      \n      .image-scope {\n        background: #dbeafe;\n        color: #1d4ed8;\n      }\n      \n      /* Image info display */\n      .image-info {\n        background: #f0f9ff;\n        border: 1px solid #bae6fd;\n        border-radius: 4px;\n        padding: 6px 10px;\n        margin: 8px 0;\n        font-size: 13px;\n        color: #0c4a6e;\n      }\n      \n      /* Note item styling for different types */\n      .plant-note {\n        border-left: 4px solid #22c55e;\n      }\n      \n      .image-note {\n        border-left: 4px solid #3b82f6;\n      }\n      \n      /* Enhance existing note item spacing */\n      .note-item {\n        margin-bottom: 0;\n        border-bottom: 1px solid #f3f4f6;\n      }\n      \n      .note-item:last-child {\n        border-bottom: none;\n      }\n      \n      /* Backward propagation checkbox styling */\n      .checkbox-wrapper {\n        margin: 15px 0;\n      }\n      \n      .checkbox-label {\n        display: flex;\n        align-items: center;\n        gap: 8px;\n        cursor: pointer;\n        font-weight: 500;\n        color: #374151;\n      }\n      \n      .checkbox-label input[type=\"checkbox\"] {\n        margin: 0;\n        padding: 0;\n        transform: scale(1.1);\n        accent-color: #3b82f6;\n      }\n      \n      .checkbox-text {\n        user-select: none;\n      }\n      \n      #backward-propagation-group .form-help {\n        margin-top: 5px;\n        font-size: 12px;\n        color: #6b7280;\n        font-style: italic;\n      }\n    `;\n    \n    document.head.appendChild(style);\n    console.log('[NoteUI] Injected separation styles for plant/image notes');\n  }\n\n  /**\n   * Display note edit modal\n   */\n  showNoteModal(note = null) {\n    console.log('[NoteUI] showNoteModal called, note:', note);\n    this.currentNote = note;\n    this.isEditMode = !!note;\n\n    const modal = document.getElementById('note-modal');\n    const title = document.getElementById('note-modal-title');\n    const backwardPropagationGroup = document.getElementById('backward-propagation-group');\n    \n    if (!modal || !title) {\n      console.error('[NoteUI] Note modal elements not found');\n      return;\n    }\n    \n    title.textContent = this.isEditMode ? 'Edit Note' : 'Add Note';\n    \n    // 🔧 NEW: Show backward propagation option only for new image notes\n    const isNewImageNote = !this.isEditMode && this.currentImageId;\n    if (backwardPropagationGroup) {\n      backwardPropagationGroup.style.display = isNewImageNote ? 'block' : 'none';\n      // Reset checkbox when showing modal\n      const checkbox = document.getElementById('note-backward-propagation');\n      if (checkbox) {\n        checkbox.checked = false;\n      }\n    }\n    \n    if (note) {\n      document.getElementById('note-title').value = note.title;\n      document.getElementById('note-type').value = note.noteType;\n      document.getElementById('note-content').value = note.content;\n      document.getElementById('note-tags').value = note.tags.join(', ');\n      document.getElementById('note-author').value = note.author;\n    } else {\n      document.getElementById('note-title').value = '';\n      document.getElementById('note-type').value = 'general';\n      document.getElementById('note-content').value = '';\n      document.getElementById('note-tags').value = '';\n      document.getElementById('note-author').value = 'User';\n    }\n\n    this.updateCharCounter('note-title', 'note-title-count', 100);\n    this.updateCharCounter('note-content', 'note-content-count', 5000);\n\n    console.log('[NoteUI] Showing note edit modal');\n    modal.style.display = 'flex';\n    \n    const titleInput = document.getElementById('note-title');\n    if (titleInput) {\n      titleInput.focus();\n    }\n  }\n\n  /**\n   * Close note modal\n   */\n  closeNoteModal() {\n    document.getElementById('note-modal').style.display = 'none';\n    this.currentNote = null;\n    this.isEditMode = false;\n  }\n\n  /**\n   * Close note list modal\n   */\n  closeNoteListModal() {\n    document.getElementById('note-list-modal').style.display = 'none';\n  }\n\n  /**\n   * Get later-dated images for backward propagation\n   */\n  async getLaterDatedImages(plantId, currentImageId) {\n    try {\n      console.log(`[NoteUI] Finding later-dated images for ${plantId}, current: ${currentImageId}`);\n      \n      // Get all images for the current plant and view angle\n      const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n      if (!plantDataManager) {\n        throw new Error('PlantDataManager not available');\n      }\n      \n      // Get current plant information\n      const currentPlant = plantDataManager.plants?.get(plantId);\n      if (!currentPlant || !currentPlant.selectedViewAngle) {\n        throw new Error('Current plant or view angle not found');\n      }\n      \n      // Get all images for the current view angle\n      const images = await plantDataManager.getPlantImages(plantId, currentPlant.selectedViewAngle);\n      if (!images || images.length === 0) {\n        return [];\n      }\n      \n      // Find the current image index\n      const currentImageIndex = images.findIndex(img => img.id === currentImageId);\n      if (currentImageIndex === -1) {\n        throw new Error('Current image not found in plant images');\n      }\n      \n      // Get all images after the current one (later in time)\n      const laterImages = images.slice(currentImageIndex + 1);\n      \n      console.log(`[NoteUI] Found ${laterImages.length} later-dated images for backward propagation`);\n      return laterImages;\n      \n    } catch (error) {\n      console.error('[NoteUI] Error finding later-dated images:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Apply note to multiple images (backward propagation)\n   */\n  async applyNoteToMultipleImages(plantId, noteData, targetImages) {\n    const results = {\n      success: [],\n      failed: []\n    };\n    \n    console.log(`[NoteUI] Applying note to ${targetImages.length} images via backward propagation`);\n    \n    for (const image of targetImages) {\n      try {\n        await this.noteManager.addImageNote(plantId, image.id, noteData);\n        results.success.push(image.id);\n        console.log(`[NoteUI] Note successfully applied to ${image.id}`);\n      } catch (error) {\n        console.error(`[NoteUI] Failed to apply note to ${image.id}:`, error);\n        results.failed.push({ imageId: image.id, error: error.message });\n      }\n    }\n    \n    console.log(`[NoteUI] Backward propagation completed: ${results.success.length} success, ${results.failed.length} failed`);\n    return results;\n  }\n\n  /**\n   * Save note\n   */\n  async saveNote() {\n    const title = document.getElementById('note-title').value.trim();\n    const content = document.getElementById('note-content').value.trim();\n    const noteType = document.getElementById('note-type').value;\n    const tags = document.getElementById('note-tags').value.split(',').map(tag => tag.trim()).filter(tag => tag);\n    const author = document.getElementById('note-author').value.trim();\n    \n    // 🔧 NEW: Check backward propagation setting\n    const backwardPropagationCheckbox = document.getElementById('note-backward-propagation');\n    const enableBackwardPropagation = backwardPropagationCheckbox && backwardPropagationCheckbox.checked;\n\n    const noteData = {\n      title,\n      content,\n      noteType,\n      tags,\n      author\n    };\n\n    const validation = this.noteManager.validateNoteData(noteData);\n    if (!validation.isValid) {\n      alert('Input error:\\\\n' + validation.errors.join('\\\\n'));\n      return;\n    }\n\n    try {\n      if (this.isEditMode && this.currentNote) {\n        console.log(`[NoteUI] Updating note: ${this.currentNote.noteId}`);\n        await this.noteManager.updateNote(this.currentNote.noteId, noteData);\n        console.log('[NoteUI] Note updated successfully');\n      } else {\n        console.log('[NoteUI] Creating new note...');\n        if (this.currentImageId) {\n          console.log(`[NoteUI] Creating image note for ${this.currentPlantId}/${this.currentImageId}`);\n          \n          // Add note to current image\n          await this.noteManager.addImageNote(this.currentPlantId, this.currentImageId, noteData);\n          \n          // 🔧 NEW: Handle backward propagation\n          if (enableBackwardPropagation) {\n            console.log('[NoteUI] Backward propagation enabled, finding later-dated images...');\n            \n            const laterImages = await this.getLaterDatedImages(this.currentPlantId, this.currentImageId);\n            if (laterImages.length > 0) {\n              console.log(`[NoteUI] Applying note to ${laterImages.length} later-dated images`);\n              const propagationResults = await this.applyNoteToMultipleImages(this.currentPlantId, noteData, laterImages);\n              \n              // Show propagation results\n              if (propagationResults.success.length > 0) {\n                console.log(`[NoteUI] Backward propagation successful: ${propagationResults.success.length} images updated`);\n              }\n              if (propagationResults.failed.length > 0) {\n                console.warn(`[NoteUI] Backward propagation partial failure: ${propagationResults.failed.length} images failed`);\n              }\n            } else {\n              console.log('[NoteUI] No later-dated images found for backward propagation');\n            }\n          }\n          \n        } else {\n          console.log(`[NoteUI] Creating plant note for ${this.currentPlantId}`);\n          await this.noteManager.addPlantNote(this.currentPlantId, noteData);\n        }\n        console.log('[NoteUI] Note created successfully');\n      }\n\n      this.closeNoteModal();\n      \n      // 🔧 FIX: Add small delay to ensure backend processing completes\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      // 🔧 FIX: Force immediate cache clear to ensure fresh data\n      console.log('[NoteUI] Note saved, forcing complete cache clear for fresh data...');\n      if (this.noteManager.clearCache) {\n        this.noteManager.clearCache();\n        console.log('[NoteUI] Note manager cache completely cleared');\n      }\n      \n      // 🔧 FIX: Force refresh bulk data to ensure real-time accuracy\n      if (this.noteManager.refreshBulkData) {\n        try {\n          await this.noteManager.refreshBulkData();\n          console.log('[NoteUI] Bulk data forcefully refreshed for immediate sync');\n        } catch (refreshError) {\n          console.warn('[NoteUI] Bulk data refresh failed, cache cleared anyway:', refreshError);\n        }\n      }\n      \n      // 🔧 FIX: Always refresh the note list modal regardless of visibility to show new note\n      const listModal = document.getElementById('note-list-modal');\n      if (listModal && listModal.style.display !== 'none') {\n        console.log('[NoteUI] Refreshing note list to show new/updated note');\n        await this.loadNoteList();\n        console.log('[NoteUI] Note list refreshed with fresh data');\n      }\n\n      // 🔧 FIX: 立即刷新植物笔记徽章和图像笔记徽章，以及按钮计数\n      if (this.currentPlantId) {\n        console.log('[NoteUI] 笔记保存完成，立即刷新徽章和按钮...');\n        \n        // 🔧 FIX: Force real-time badge updates with fresh data (bypassing stale cache)\n        console.log('[NoteUI] Forcing immediate badge refresh with fresh data...');\n        \n        // Wait a bit longer for backend sync\n        await new Promise(resolve => setTimeout(resolve, 200));\n        \n        // 立即刷新植物笔记徽章和按钮\n        await this.updatePlantNoteBadge(this.currentPlantId);\n        await this.updatePlantNoteButton(this.currentPlantId);\n        \n        // 如果是图像笔记，使用直接API调用刷新徽章避免缓存冲突\n        if (this.currentImageId) {\n          // ✅ CONSISTENCY: Use direct API call for save operations too\n          await this.directUpdateThumbnailBadge(this.currentPlantId, this.currentImageId);\n          // 🔧 FIX: Also update the image note button count overlay\n          await this.updateImageNoteButton(this.currentPlantId, this.currentImageId);\n          console.log('[NoteUI] ✅ 图像笔记徽章和按钮计数通过直接API刷新完成');\n          \n          // 🔧 NEW: Update badges for all affected images if backward propagation was used\n          if (enableBackwardPropagation) {\n            console.log('[NoteUI] Refreshing badges for all images affected by backward propagation...');\n            const laterImages = await this.getLaterDatedImages(this.currentPlantId, this.currentImageId);\n            for (const image of laterImages) {\n              await this.directUpdateThumbnailBadge(this.currentPlantId, image.id);\n            }\n            console.log(`[NoteUI] Updated badges for ${laterImages.length} propagated images`);\n          }\n        }\n        \n        console.log('[NoteUI] 笔记徽章和按钮刷新完成');\n      }\n\n    } catch (error) {\n      console.error('Save note failed:', error);\n      alert('Save failed: ' + error.message);\n    }\n  }\n\n  /**\n   * Edit note\n   */\n  async editNote(noteId) {\n    try {\n      const note = await this.noteManager.getNote(noteId);\n      if (note) {\n        this.closeNoteListModal();\n        this.showNoteModal(note);\n      }\n    } catch (error) {\n      console.error('Failed to get note:', error);\n      alert('Failed to get note: ' + error.message);\n    }\n  }\n\n  /**\n   * Delete note\n   */\n  async deleteNote(noteId) {\n    if (!confirm('Are you sure you want to delete this note?')) {\n      return;\n    }\n\n    try {\n      console.log(`[NoteUI] Attempting to delete note: ${noteId}`);\n      await this.noteManager.deleteNote(noteId);\n      console.log('[NoteUI] Note deletion successful');\n      \n      // 🔧 FIX: Add small delay to ensure cache clearing completes\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      // 🔧 FIX: Force immediate cache clear and refresh for deletion\n      console.log('[NoteUI] Note deleted, forcing complete cache clear and refresh...');\n      \n      // Double-ensure cache is cleared\n      if (this.noteManager.clearCache) {\n        this.noteManager.clearCache();\n        console.log('[NoteUI] Note manager cache cleared after deletion');\n      }\n      \n      // 🔧 FIX: Force refresh bulk data to ensure deletion is reflected immediately\n      if (this.noteManager.refreshBulkData) {\n        try {\n          await this.noteManager.refreshBulkData();\n          console.log('[NoteUI] Bulk data forcefully refreshed after deletion');\n        } catch (refreshError) {\n          console.warn('[NoteUI] Bulk data refresh failed after deletion, cache cleared anyway:', refreshError);\n        }\n      }\n      \n      // Immediately refresh note list in modal with fresh data\n      await this.loadNoteList();\n      console.log('[NoteUI] Note list refreshed after deletion');\n      \n      // 🔧 FIX: Streamlined badge refresh after deletion - direct API only\n      if (this.currentPlantId) {\n        console.log('[NoteUI] Refreshing badges after note deletion using direct API calls...');\n        \n        // Force refresh plant note badge and button with bypassed cache\n        await this.updatePlantNoteBadge(this.currentPlantId);\n        await this.updatePlantNoteButton(this.currentPlantId);\n        \n        // If there's a current image, use ONLY direct API call to avoid cache conflicts\n        if (this.currentImageId) {\n          // ✅ SOLUTION: Skip cache-dependent methods, use direct API call exclusively\n          await this.directUpdateThumbnailBadge(this.currentPlantId, this.currentImageId);\n          // 🔧 FIX: Also update the image note button count overlay\n          await this.updateImageNoteButton(this.currentPlantId, this.currentImageId);\n          console.log('[NoteUI] ✅ Image note badge and button updated via direct API after deletion');\n        }\n        \n        console.log('[NoteUI] All badges refreshed after deletion');\n      }\n    } catch (error) {\n      console.error('Delete note failed:', error);\n      \n      // 🔧 FIX: Improved error handling for different error types\n      let errorMessage = 'Delete failed: ';\n      if (error.message.includes('404') || error.message.includes('不存在')) {\n        errorMessage += 'Note was already deleted or does not exist.';\n        // Still refresh the modal to show current state\n        console.log('[NoteUI] Note already deleted, refreshing modal to show current state...');\n        if (this.noteManager.clearCache) {\n          this.noteManager.clearCache();\n        }\n        await this.loadNoteList();\n        if (this.currentPlantId) {\n          await this.updatePlantNoteBadge(this.currentPlantId);\n          // 🔧 FIX: Also use direct API for error recovery to maintain consistency\n          if (this.currentImageId) {\n            await this.directUpdateThumbnailBadge(this.currentPlantId, this.currentImageId);\n            // 🔧 FIX: Also update the image note button count overlay in error recovery\n            await this.updateImageNoteButton(this.currentPlantId, this.currentImageId);\n          }\n        }\n      } else {\n        errorMessage += error.message;\n      }\n      \n      alert(errorMessage);\n    }\n  }\n\n  /**\n   * Search notes with proper scope based on current modal context\n   */\n  async searchNotes() {\n    const query = document.getElementById('note-search').value.trim();\n    const typeFilter = document.getElementById('note-type-filter').value;\n    \n    try {\n      let notes;\n      \n      if (this.currentImageId) {\n        // 🔧 FIX: In Image Notes modal - search only image notes for this specific image\n        console.log(`[NoteUI] Searching image notes for ${this.currentImageId} with query:`, query);\n        const allImageNotes = await this.noteManager.getImageNotes(this.currentPlantId, this.currentImageId);\n        \n        // Filter by query and type if provided\n        notes = allImageNotes.filter(note => {\n          const matchesQuery = !query || \n            note.title.toLowerCase().includes(query.toLowerCase()) ||\n            note.content.toLowerCase().includes(query.toLowerCase()) ||\n            note.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()));\n          \n          const matchesType = !typeFilter || note.noteType === typeFilter;\n          \n          return matchesQuery && matchesType;\n        });\n        \n        console.log(`[NoteUI] Image note search completed: found ${notes.length} notes`);\n        \n      } else {\n        // 🔧 FIX: In Plant Notes modal - search ONLY plant-level notes for consistency\n        console.log(`[NoteUI] Searching plant-level notes only for ${this.currentPlantId} with query:`, query);\n        const allPlantNotes = await this.noteManager.getPlantNotes(this.currentPlantId);\n        \n        // Filter by query and type if provided  \n        notes = allPlantNotes.filter(note => {\n          const matchesQuery = !query || \n            note.title.toLowerCase().includes(query.toLowerCase()) ||\n            note.content.toLowerCase().includes(query.toLowerCase()) ||\n            note.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()));\n          \n          const matchesType = !typeFilter || note.noteType === typeFilter;\n          \n          return matchesQuery && matchesType;\n        });\n        \n        console.log(`[NoteUI] Plant note search completed: found ${notes.length} plant-level notes (image notes excluded for consistency)`);\n      }\n      \n      this.renderNoteList(notes);\n      \n    } catch (error) {\n      console.error('Search notes failed:', error);\n      \n      let errorMessage = 'Search failed: ';\n      if (error.message.includes('404')) {\n        errorMessage += 'Notes not found or backend server unavailable.';\n      } else if (error.message.includes('500')) {\n        errorMessage += 'Server error occurred during search. Please try again.';\n      } else {\n        errorMessage += error.message;\n      }\n      \n      document.getElementById('note-list-content').innerHTML = `<div class=\"error-message\">${errorMessage}</div>`;\n    }\n  }\n\n  /**\n   * Update character counter\n   */\n  updateCharCounter(inputId, counterId, maxLength) {\n    const input = document.getElementById(inputId);\n    const counter = document.getElementById(counterId);\n    const currentLength = input.value.length;\n    \n    counter.textContent = currentLength;\n    \n    if (currentLength > maxLength * 0.9) {\n      counter.style.color = '#ff6b6b';\n    } else if (currentLength > maxLength * 0.8) {\n      counter.style.color = '#feca57';\n    } else {\n      counter.style.color = '#666';\n    }\n  }\n\n  /**\n   * Set current plant ID\n   */\n  setCurrentPlant(plantId) {\n    this.currentPlantId = plantId;\n    \n    // Show plant notes button and container\n    const plantNoteBtn = document.getElementById('plant-note-btn');\n    const plantNoteContainer = document.querySelector('.plant-notes-section, .plant-note-container');\n    \n    if (plantNoteBtn) {\n      plantNoteBtn.style.display = plantId ? 'block' : 'none';\n    }\n    \n    if (plantNoteContainer) {\n      plantNoteContainer.style.display = plantId ? 'block' : 'none';\n    }\n    \n    // Update plant note button count and badge\n    if (plantId) {\n      this.updatePlantNoteButton(plantId);\n      this.updatePlantNoteBadge(plantId);\n    } else {\n      this.updatePlantNoteButton(null);\n    }\n  }\n\n  /**\n   * Set current image ID\n   */\n  setCurrentImage(imageId) {\n    console.log(`[NoteUI] Setting current image ID: ${imageId}, current plant ID: ${this.currentPlantId}`);\n    this.currentImageId = imageId;\n    \n    // 🔧 FIX: Always update image note button regardless of state\n    if (imageId && this.currentPlantId) {\n      // Ensure we have the current plant ID as well\n      if (!this.currentPlantId && window.PlantAnnotationTool?.appState?.currentPlant?.id) {\n        this.currentPlantId = window.PlantAnnotationTool.appState.currentPlant.id;\n        console.log(`[NoteUI] Auto-updated plant ID from global state: ${this.currentPlantId}`);\n      }\n      \n      // Update image note button and thumbnail badge\n      this.updateImageNoteButton(this.currentPlantId, imageId);\n      this.refreshThumbnailNoteBadge(this.currentPlantId, imageId);\n    } else {\n      // 🔧 FIX: Clear image note button when no image is selected\n      this.updateImageNoteButton(null, null);\n      console.log('[NoteUI] Image note button cleared - no image selected');\n    }\n    \n    // Show image notes button and container\n    const imageNoteBtn = document.getElementById('image-note-btn');\n    const imageNoteContainer = document.querySelector('.annotation-controls, .image-note-container');\n    \n    console.log(`[NoteUI] Image note button exists: ${!!imageNoteBtn}, container exists: ${!!imageNoteContainer}`);\n    \n    if (imageNoteBtn) {\n      const shouldShow = this.currentPlantId && imageId;\n      console.log(`[NoteUI] Image note button should show: ${shouldShow}`);\n      imageNoteBtn.style.display = shouldShow ? 'block' : 'none';\n    }\n    \n    if (imageNoteContainer && imageNoteContainer.classList.contains('image-note-container')) {\n      const shouldShow = this.currentPlantId && imageId;\n      console.log(`[NoteUI] Image note container should show: ${shouldShow}`);\n      imageNoteContainer.style.display = shouldShow ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Update plant note button count display (ALL notes for this plant)\n   */\n  async updatePlantNoteButton(plantId) {\n    const plantNoteCountElement = document.getElementById('plant-note-count');\n    if (!plantNoteCountElement) return;\n    \n    if (!plantId) {\n      plantNoteCountElement.textContent = '';\n      return;\n    }\n    \n    try {\n      // 🔧 FIX: Use bulk stats first for performance, then fallback to search API for accuracy\n      let totalCount = 0;\n      \n      // Try bulk stats first (fast)\n      const bulkStats = await this.noteManager.getQuickNoteStats();\n      if (bulkStats && bulkStats[plantId]) {\n        // 🔧 FIX: Plant Notes button should ONLY show plant-level notes, not image notes\n        totalCount = bulkStats[plantId].plantNotes; // Only plant notes, not .total\n        console.log(`[NoteUI] Plant note button using bulk data: ${totalCount} plant-only notes`);\n        \n        // 🔧 FIX: Validate plant-only count with plant API (not search API)\n        if (Math.random() < 0.1) { // 10% spot-check for validation\n          try {\n            const plantNotes = await this.noteManager.getPlantNotes(plantId);\n            const actualCount = plantNotes ? plantNotes.length : 0;\n            if (actualCount !== totalCount) {\n              console.warn(`[NoteUI] Plant button bulk data inconsistency! Bulk: ${totalCount}, Actual: ${actualCount}. Using actual...`);\n              totalCount = actualCount;\n            }\n          } catch (validationError) {\n            console.debug('[NoteUI] Plant button validation failed, continuing with bulk data:', validationError);\n          }\n        }\n      } else {\n        // Fallback to plant API (only plant-level notes, consistent with button purpose)\n        console.log(`[NoteUI] Plant note button fallback to plant API for ${plantId}`);\n        try {\n          const plantNotes = await this.noteManager.getPlantNotes(plantId);\n          totalCount = plantNotes ? plantNotes.length : 0;\n          console.log(`[NoteUI] Plant note button plant API found: ${totalCount} plant-only notes`);\n        } catch (plantError) {\n          console.warn(`[NoteUI] Plant API failed, final fallback to 0:`, plantError);\n          totalCount = 0;\n        }\n      }\n      \n      if (totalCount > 0) {\n        plantNoteCountElement.textContent = `(${totalCount})`;\n        plantNoteCountElement.style.cssText = `\n          color: #059669;\n          font-weight: bold;\n          margin-left: 5px;\n        `;\n      } else {\n        plantNoteCountElement.textContent = '';\n      }\n      \n      console.log(`[NoteUI] Plant note button updated: ${totalCount} total notes (plant + image)`);\n    } catch (error) {\n      console.error('Failed to update plant note button:', error);\n      plantNoteCountElement.textContent = '';\n    }\n  }\n\n  /**\n   * Update image note button count display\n   */\n  async updateImageNoteButton(plantId, imageId) {\n    const imageNoteCountElement = document.getElementById('image-note-count');\n    if (!imageNoteCountElement) return;\n    \n    if (!plantId || !imageId) {\n      imageNoteCountElement.textContent = '';\n      imageNoteCountElement.style.display = 'none';\n      return;\n    }\n    \n    try {\n      const notes = await this.noteManager.getImageNotes(plantId, imageId);\n      const count = notes ? notes.length : 0;\n      \n      if (count > 0) {\n        imageNoteCountElement.textContent = count;\n        imageNoteCountElement.style.cssText = `\n          position: absolute;\n          top: -5px;\n          right: -5px;\n          background: #dc2626;\n          color: white;\n          border-radius: 50%;\n          width: 16px;\n          height: 16px;\n          font-size: 10px;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          font-weight: bold;\n        `;\n      } else {\n        imageNoteCountElement.textContent = '';\n        imageNoteCountElement.style.display = 'none';\n      }\n      \n      console.log(`[NoteUI] Image note button updated: ${count} notes`);\n    } catch (error) {\n      console.error('Failed to update image note button:', error);\n      imageNoteCountElement.textContent = '';\n      imageNoteCountElement.style.display = 'none';\n    }\n  }\n\n  /**\n   * Refresh thumbnail note badge for specific image\n   */\n  async refreshThumbnailNoteBadge(plantId, imageId) {\n    try {\n      // 🔧 FIX: Force cache invalidation for this specific image before refresh\n      const cacheKey = `image_${plantId}_${imageId}`;\n      if (this.noteManager.notes && this.noteManager.notes.has(cacheKey)) {\n        this.noteManager.notes.delete(cacheKey);\n        console.log(`[NoteUI] Force cleared cache for ${cacheKey}`);\n      }\n      \n      // 🔧 FIX: Also clear bulk data to ensure fresh load\n      if (this.noteManager.bulkNoteData) {\n        this.noteManager.bulkNoteData = null;\n        this.noteManager.bulkDataTimestamp = 0;\n        console.log(`[NoteUI] Force cleared bulk cache for thumbnail refresh`);\n      }\n      \n      // Call the global function to refresh thumbnail badge\n      if (typeof loadImageNoteCount === 'function') {\n        await loadImageNoteCount(plantId, imageId);\n        console.log(`[NoteUI] Thumbnail note badge refreshed for ${imageId}`);\n      } else {\n        console.warn('[NoteUI] loadImageNoteCount function not available');\n      }\n    } catch (error) {\n      console.error('Failed to refresh thumbnail note badge:', error);\n    }\n  }\n  async updatePlantNoteBadge(plantId) {\n    if (!plantId) return;\n    \n    console.log(`[NoteUI] updatePlantNoteBadge called for plant: ${plantId}`);\n    \n    try {\n      // Use bulk note stats for better performance\n      const bulkStats = await this.noteManager.getQuickNoteStats();\n      \n      if (bulkStats && bulkStats[plantId]) {\n        const stats = bulkStats[plantId];\n        const totalNotes = stats.total;\n        \n        console.log(`[NoteUI] Plant ${plantId} bulk stats: ${stats.plantNotes} plant + ${stats.imageNotes} image = ${totalNotes} total`);\n        \n        // 🔧 FIX: Occasional validation to detect stale bulk data\n        if (Math.random() < 0.15) { // 15% validation rate for badges\n          try {\n            const validationResults = await this.noteManager.searchNotes('', { plantId: plantId });\n            const actualTotal = validationResults ? validationResults.length : 0;\n            if (actualTotal !== totalNotes) {\n              console.warn(`[NoteUI] Badge bulk data stale! Bulk: ${totalNotes}, Actual: ${actualTotal}. Using accurate data...`);\n              // Force refresh and use accurate data\n              if (this.noteManager.refreshBulkData) {\n                await this.noteManager.refreshBulkData();\n              }\n              // Fall through to individual method below\n            } else {\n              // Bulk data is accurate, proceed with badge update\n              this.updateBadgeWithStats(plantId, stats);\n              return;\n            }\n          } catch (validationError) {\n            console.debug('[NoteUI] Badge validation failed, using bulk data:', validationError);\n            // Continue with bulk data despite validation failure\n            this.updateBadgeWithStats(plantId, stats);\n            return;\n          }\n        } else {\n          // No validation this time, trust bulk data\n          this.updateBadgeWithStats(plantId, stats);\n          return;\n        }\n      }\n      \n      console.log(`[NoteUI] Bulk stats not available for ${plantId}, falling back to individual requests`);\n      \n      // Fallback to individual requests if bulk API is not available\n      const plantNotes = await this.noteManager.getPlantNotes(plantId);\n      console.log(`[NoteUI] Plant ${plantId} has ${plantNotes?.length || 0} plant notes`);\n      \n      let totalImageNotes = 0;\n      \n      // Get plant images using the correct API\n      let plantImages = null;\n      if (window.PlantAnnotationTool?.plantDataManager) {\n        try {\n          plantImages = await window.PlantAnnotationTool.plantDataManager.getPlantImages(plantId);\n        } catch (error) {\n          console.debug(`Could not load plant images for ${plantId}:`, error.message);\n          // Fallback: try to get images by view angles if available\n          const plant = window.PlantAnnotationTool.plantDataManager.plants?.find(p => p.id === plantId);\n          if (plant?.viewAngles) {\n            const imagesByView = {};\n            for (const viewAngle of plant.viewAngles) {\n              try {\n                const images = await window.PlantAnnotationTool.plantDataManager.getPlantImages(plantId, viewAngle);\n                if (images && images.length > 0) {\n                  imagesByView[viewAngle] = images;\n                }\n              } catch (viewError) {\n                console.debug(`Could not load images for ${plantId}/${viewAngle}:`, viewError.message);\n              }\n            }\n            plantImages = imagesByView;\n          }\n        }\n      }\n      \n      // Count notes for all images of this plant\n      if (plantImages) {\n        const imagePromises = [];\n        \n        if (Array.isArray(plantImages)) {\n          // Single view angle array\n          for (const image of plantImages) {\n            imagePromises.push(this.noteManager.getImageNotes(plantId, image.id));\n          }\n        } else {\n          // Multi-view angle object\n          for (const viewAngle in plantImages) {\n            for (const image of plantImages[viewAngle]) {\n              imagePromises.push(this.noteManager.getImageNotes(plantId, image.id));\n            }\n          }\n        }\n        \n        // Get all image notes in parallel with proper error handling\n        const imageNotesResults = await Promise.allSettled(imagePromises);\n        totalImageNotes = imageNotesResults.reduce((total, result) => {\n          if (result.status === 'fulfilled' && result.value && result.value.length > 0) {\n            return total + result.value.length;\n          }\n          return total;\n        }, 0);\n      }\n      \n      const totalNotes = (plantNotes?.length || 0) + totalImageNotes;\n      console.log(`[NoteUI] Plant ${plantId} total notes: ${totalNotes} (${plantNotes?.length || 0} plant + ${totalImageNotes} image)`);\n      \n      const badge = document.getElementById(`note-badge-${plantId}`);\n      console.log(`[NoteUI] Badge element found for ${plantId}:`, !!badge);\n      \n      if (badge) {\n        if (totalNotes > 0) {\n          // 🔧 FIX: 分离显示植株笔记和图片笔记（降级处理）\n          const plantNotesCount = plantNotes?.length || 0;\n          let badgeText = '';\n          let title = '';\n          \n          if (plantNotesCount > 0 && totalImageNotes > 0) {\n            // 两种笔记都有\n            badgeText = `📝 ${plantNotesCount} | 🖼️ ${totalImageNotes}`;\n            title = `${plantNotesCount} plant notes, ${totalImageNotes} image notes`;\n          } else if (plantNotesCount > 0) {\n            // 只有植株笔记\n            badgeText = `📝 ${plantNotesCount}`;\n            title = `${plantNotesCount} plant notes`;\n          } else if (totalImageNotes > 0) {\n            // 只有图片笔记\n            badgeText = `🖼️ ${totalImageNotes}`;\n            title = `${totalImageNotes} image notes`;\n          }\n          \n          badge.innerHTML = `<span class=\"note-count\">${badgeText}</span>`;\n          badge.style.display = 'inline-flex';\n          badge.style.visibility = 'visible';\n          badge.style.opacity = '1';\n          badge.title = title;\n          console.log(`[NoteUI] Badge updated for ${plantId}: ${badgeText} (INDIVIDUAL)`);\n        } else {\n          badge.style.display = 'none';\n          badge.style.visibility = 'hidden';\n          badge.style.opacity = '0';\n          console.log(`[NoteUI] Badge hidden for ${plantId}: no notes found`);\n        }\n      } else {\n        console.error(`[NoteUI] Badge element not found for plant ${plantId}`);\n      }\n    } catch (error) {\n      console.error(`Failed to update note badge for plant ${plantId}:`, error);\n    }\n  }\n\n  /**\n   * Helper method to update badge with provided stats\n   */\n  updateBadgeWithStats(plantId, stats) {\n    const badge = document.getElementById(`note-badge-${plantId}`);\n    console.log(`[NoteUI] Badge element found for ${plantId}:`, !!badge);\n    \n    if (badge) {\n      const totalNotes = stats.total;\n      if (totalNotes > 0) {\n        // 🔧 FIX: 分离显示植株笔记和图片笔记\n        let badgeText = '';\n        let title = '';\n        \n        if (stats.plantNotes > 0 && stats.imageNotes > 0) {\n          // 两种笔记都有\n          badgeText = `📝 ${stats.plantNotes} | 🖼️ ${stats.imageNotes}`;\n          title = `${stats.plantNotes} plant notes, ${stats.imageNotes} image notes`;\n        } else if (stats.plantNotes > 0) {\n          // 只有植株笔记\n          badgeText = `📝 ${stats.plantNotes}`;\n          title = `${stats.plantNotes} plant notes`;\n        } else if (stats.imageNotes > 0) {\n          // 只有图片笔记\n          badgeText = `🖼️ ${stats.imageNotes}`;\n          title = `${stats.imageNotes} image notes`;\n        }\n        \n        badge.innerHTML = `<span class=\"note-count\">${badgeText}</span>`;\n        badge.style.display = 'inline-flex';\n        badge.style.visibility = 'visible';\n        badge.style.opacity = '1';\n        badge.title = title;\n        console.log(`[NoteUI] Badge updated for ${plantId}: ${badgeText} (VALIDATED)`);\n      } else {\n        badge.style.display = 'none';\n        badge.style.visibility = 'hidden';\n        badge.style.opacity = '0';\n        console.log(`[NoteUI] Badge hidden for ${plantId}: no notes found (VALIDATED)`);\n      }\n    } else {\n      console.error(`[NoteUI] Badge element not found for plant ${plantId}`);\n    }\n  }\n\n  /**\n   * Update all plant note badges using bulk data (INSTANT - no individual requests)\n   */\n  async updateAllPlantNoteBadgesFromBulk(bulkData) {\n    console.log('[NoteUI] updateAllPlantNoteBadgesFromBulk() called with bulk data');\n    const plantItems = document.querySelectorAll('.plant-item');\n    console.log(`[NoteUI] Found ${plantItems.length} plant items to update`);\n    \n    if (!bulkData || !bulkData.plantNotes || !bulkData.imageNotes) {\n      console.error('[NoteUI] Invalid bulk data provided');\n      return;\n    }\n    \n    const startTime = performance.now();\n    \n    // Create quick stats lookup from bulk data\n    const quickStats = {};\n    \n    // Process plant notes\n    for (const [plantId, notes] of Object.entries(bulkData.plantNotes)) {\n      if (!quickStats[plantId]) {\n        quickStats[plantId] = { plantNotes: 0, imageNotes: 0, total: 0 };\n      }\n      quickStats[plantId].plantNotes = notes.length;\n      quickStats[plantId].total += notes.length;\n    }\n    \n    // Process image notes (group by plant)\n    for (const [imageId, notes] of Object.entries(bulkData.imageNotes)) {\n      // Extract plant ID from image ID (format: BR017-028111_sv-000_...)\n      const plantId = imageId.split('_')[0];\n      if (plantId) {\n        if (!quickStats[plantId]) {\n          quickStats[plantId] = { plantNotes: 0, imageNotes: 0, total: 0 };\n        }\n        quickStats[plantId].imageNotes += notes.length;\n        quickStats[plantId].total += notes.length;\n      }\n    }\n    \n    console.log(`[NoteUI] Generated quick stats for ${Object.keys(quickStats).length} plants`);\n    \n    // Update all badges instantly using pre-calculated stats\n    for (const item of plantItems) {\n      const plantId = item.dataset.plantId;\n      if (plantId && quickStats[plantId]) {\n        const stats = quickStats[plantId];\n        const totalNotes = stats.total;\n        \n        const badge = document.getElementById(`note-badge-${plantId}`);\n        if (badge) {\n          if (totalNotes > 0) {\n            // 🔧 FIX: Use consistent separated display format for instant bulk updates\n            let badgeText = '';\n            let title = '';\n            \n            if (stats.plantNotes > 0 && stats.imageNotes > 0) {\n              // 两种笔记都有\n              badgeText = `📝 ${stats.plantNotes} | 🖼️ ${stats.imageNotes}`;\n              title = `${stats.plantNotes} plant notes, ${stats.imageNotes} image notes`;\n            } else if (stats.plantNotes > 0) {\n              // 只有植株笔记\n              badgeText = `📝 ${stats.plantNotes}`;\n              title = `${stats.plantNotes} plant notes`;\n            } else if (stats.imageNotes > 0) {\n              // 只有图片笔记\n              badgeText = `🖼️ ${stats.imageNotes}`;\n              title = `${stats.imageNotes} image notes`;\n            }\n            \n            badge.innerHTML = `<span class=\"note-count\">${badgeText}</span>`;\n            badge.style.display = 'inline-flex';\n            badge.style.visibility = 'visible';\n            badge.style.opacity = '1';\n            badge.title = title;\n          } else {\n            badge.style.display = 'none';\n            badge.style.visibility = 'hidden';\n            badge.style.opacity = '0';\n          }\n        }\n      }\n    }\n    \n    const endTime = performance.now();\n    console.log(`[NoteUI] BULK UPDATE COMPLETE: ${plantItems.length} badges updated in ${(endTime - startTime).toFixed(2)}ms using bulk data`);\n    console.log(`[NoteUI] Performance: INSTANT UPDATE - no individual HTTP requests`);\n  }\n\n  /**\n   * Update all plant note badges (OPTIMIZED with bulk API)\n   */\n  async updateAllPlantNoteBadges() {\n    console.log('[NoteUI] updateAllPlantNoteBadges() called');\n    const plantItems = document.querySelectorAll('.plant-item');\n    console.log(`[NoteUI] Found ${plantItems.length} plant items to update`);\n    \n    const startTime = performance.now();\n    \n    try {\n      // Try bulk API first for maximum performance\n      const bulkStats = await this.noteManager.getQuickNoteStats();\n      \n      if (bulkStats) {\n        console.log('[NoteUI] Using bulk note stats for optimal performance');\n        \n        // Update all badges using bulk data in a single pass\n        for (const item of plantItems) {\n          const plantId = item.dataset.plantId;\n          if (plantId && bulkStats[plantId]) {\n            const stats = bulkStats[plantId];\n            const totalNotes = stats.total;\n            \n            const badge = document.getElementById(`note-badge-${plantId}`);\n            if (badge) {\n              if (totalNotes > 0) {\n                // 🔧 FIX: Use consistent separated display format like updatePlantNoteBadge()\n                let badgeText = '';\n                let title = '';\n                \n                if (stats.plantNotes > 0 && stats.imageNotes > 0) {\n                  // 两种笔记都有\n                  badgeText = `📝 ${stats.plantNotes} | 🖼️ ${stats.imageNotes}`;\n                  title = `${stats.plantNotes} plant notes, ${stats.imageNotes} image notes`;\n                } else if (stats.plantNotes > 0) {\n                  // 只有植株笔记\n                  badgeText = `📝 ${stats.plantNotes}`;\n                  title = `${stats.plantNotes} plant notes`;\n                } else if (stats.imageNotes > 0) {\n                  // 只有图片笔记\n                  badgeText = `🖼️ ${stats.imageNotes}`;\n                  title = `${stats.imageNotes} image notes`;\n                }\n                \n                badge.innerHTML = `<span class=\"note-count\">${badgeText}</span>`;\n                badge.style.display = 'inline-flex';\n                badge.style.visibility = 'visible';\n                badge.style.opacity = '1';\n                badge.title = title;\n              } else {\n                badge.style.display = 'none';\n                badge.style.visibility = 'hidden';\n                badge.style.opacity = '0';\n              }\n            }\n          }\n        }\n        \n        const endTime = performance.now();\n        const metrics = this.noteManager.getPerformanceMetrics();\n        console.log(`[NoteUI] BULK UPDATE COMPLETE: ${plantItems.length} badges updated in ${(endTime - startTime).toFixed(2)}ms`);\n        console.log(`[NoteUI] Performance: ${metrics.bulkRequestCount} bulk requests, ${metrics.cacheHits} cache hits`);\n        \n        return; // Exit early with optimal performance\n      }\n      \n      console.log('[NoteUI] Bulk API not available, falling back to individual requests');\n    } catch (error) {\n      console.error('[NoteUI] Bulk badge update failed, falling back to individual requests:', error);\n    }\n    \n    // Fallback to individual updates if bulk API fails\n    console.log('[NoteUI] Using individual badge updates (slower)');\n    for (const item of plantItems) {\n      const plantId = item.dataset.plantId;\n      if (plantId) {\n        console.log(`[NoteUI] Updating badge for plant: ${plantId}`);\n        await this.updatePlantNoteBadge(plantId);\n      } else {\n        console.warn('[NoteUI] Plant item found without plantId dataset');\n      }\n    }\n    \n    const endTime = performance.now();\n    const metrics = this.noteManager.getPerformanceMetrics();\n    console.log(`[NoteUI] INDIVIDUAL UPDATE COMPLETE: ${plantItems.length} badges updated in ${(endTime - startTime).toFixed(2)}ms`);\n    console.log(`[NoteUI] Performance: ${metrics.requestCount} individual requests, ${metrics.cacheHits} cache hits`);\n  }\n\n  /**\n   * Get note type text in English\n   */\n  getNoteTypeText(noteType) {\n    const typeMap = {\n      'general': 'General Note',\n      'observation': 'Observation Record',\n      'annotation': 'Annotation Description'\n    };\n    return typeMap[noteType] || noteType;\n  }\n\n  /**\n   * HTML escape\n   */\n  escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  /**\n   * Show user-friendly error message\n   */\n  showUserError(title, message) {\n    // Try to use global error display function\n    if (window.PlantAnnotationTool && window.PlantAnnotationTool.showError) {\n      window.PlantAnnotationTool.showError(title, message);\n    } else {\n      // Fall back to alert\n      alert(`${title}: ${message}`);\n    }\n  }\n\n  /**\n   * Direct thumbnail badge update (bypass all cache issues) - OPTIMIZED\n   */\n  async directUpdateThumbnailBadge(plantId, imageId) {\n    try {\n      console.log(`[NoteUI] 🔄 Direct thumbnail badge update for ${imageId}`);\n      \n      // 🔧 INCREASED DELAY: Allow backend processing to complete fully\n      await new Promise(resolve => setTimeout(resolve, 150));\n      \n      // Force fresh data by making direct API call\n      const response = await fetch(`${this.noteManager.baseUrl}/notes/image/${plantId}/${imageId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      const noteCount = result.success ? (result.data?.length || 0) : 0;\n      \n      // Update badge directly\n      const badge = document.getElementById(`image-note-badge-${imageId}`);\n      if (badge) {\n        if (noteCount > 0) {\n          badge.innerHTML = `<span class=\"image-note-count\">📝 ${noteCount}</span>`;\n          badge.style.display = 'inline-block';\n          badge.className = 'image-note-badge';\n          console.log(`[NoteUI] ✅ Badge updated: ${noteCount} notes for ${imageId} (DIRECT API)`);\n        } else {\n          badge.innerHTML = '';\n          badge.style.display = 'none';\n          console.log(`[NoteUI] ✅ Badge cleared for ${imageId} - no notes (DIRECT API)`);\n        }\n      } else {\n        console.error(`[NoteUI] Badge element not found for ${imageId}`);\n      }\n    } catch (error) {\n      console.error(`[NoteUI] ❌ Direct thumbnail badge update failed for ${imageId}:`, error);\n      \n      // 🔧 FALLBACK: Try global function as last resort\n      try {\n        console.log(`[NoteUI] 🔄 Attempting fallback via global loadImageNoteCount for ${imageId}`);\n        if (typeof loadImageNoteCount === 'function') {\n          await loadImageNoteCount(plantId, imageId);\n          console.log(`[NoteUI] ✅ Fallback badge update successful for ${imageId}`);\n        } else {\n          console.warn(`[NoteUI] ⚠️ Global loadImageNoteCount not available for fallback`);\n        }\n      } catch (fallbackError) {\n        console.error(`[NoteUI] ❌ Fallback badge update also failed for ${imageId}:`, fallbackError);\n      }\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    // Remove event listeners and DOM elements\n    const elementsToRemove = [\n      'note-modal',\n      'note-list-modal',\n      'plant-note-btn',\n      'image-note-btn'\n      // 🔧 REMOVED: Note display elements no longer exist\n    ];\n\n    elementsToRemove.forEach(id => {\n      const element = document.getElementById(id);\n      if (element) {\n        element.remove();\n      }\n    });\n\n    // Remove created containers\n    const containers = document.querySelectorAll('.plant-note-container, .image-note-container');\n    containers.forEach(container => container.remove());\n\n    console.log('NoteUI cleanup completed');\n  }\n}","/**\n * 标注管理器 - 批量加载优化版本\n * \n * 功能：\n * - 批量获取所有植物和图像的标注数据\n * - 智能缓存和性能优化\n * - 与现有系统集成\n * - 避免单独的网络请求\n */\n\nexport class AnnotationManager {\n  constructor(httpFileSystemManager) {\n    this.httpManager = httpFileSystemManager;\n    this.annotations = new Map(); // 标注缓存\n    this.cacheTimestamps = new Map(); // 缓存时间戳\n    this.isInitialized = false;\n    this.cacheExpiration = 10 * 60 * 1000; // 10分钟缓存过期\n    \n    // 批量数据缓存\n    this.bulkAnnotationData = null;\n    this.bulkDataTimestamp = 0;\n    \n    // 性能指标\n    this.performanceMetrics = {\n      requestCount: 0,\n      bulkRequestCount: 0,\n      cacheHits: 0,\n      networkTime: 0,\n      totalAnnotations: 0\n    };\n  }\n\n  /**\n   * 初始化标注管理器\n   */\n  async initialize() {\n    try {\n      await this.httpManager.ensureConnection();\n      this.isInitialized = true;\n      console.log('[AnnotationManager] 初始化成功');\n      return true;\n    } catch (error) {\n      console.error('[AnnotationManager] 初始化失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 确保连接可用\n   */\n  async ensureConnection() {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n    await this.httpManager.ensureConnection();\n  }\n\n  /**\n   * 批量获取所有标注数据 (核心性能优化方法)\n   */\n  async getAllAnnotationsInBulk() {\n    console.log('[AnnotationManager] 开始批量获取所有标注数据...');\n    \n    await this.ensureConnection();\n    \n    // 检查批量数据缓存\n    if (this.bulkAnnotationData && !this.isBulkDataExpired()) {\n      console.log('[AnnotationManager] 使用缓存的批量标注数据');\n      this.performanceMetrics.cacheHits++;\n      return this.bulkAnnotationData;\n    }\n\n    return this.httpManager.withRetry(async () => {\n      const startTime = performance.now();\n      // 🔧 FIX: Correct URL construction to avoid double /api/\n      const baseUrl = this.httpManager.baseUrl.replace(/\\/api$/, ''); // Remove trailing /api if present\n      const url = `${baseUrl}/api/annotations/bulk`;\n      console.log(`[AnnotationManager] 请求批量标注数据 URL: ${url}`);\n      \n      try {\n        const response = await fetch(url, {\n          headers: {\n            'Cache-Control': 'no-cache'\n          }\n        });\n        this.performanceMetrics.bulkRequestCount++;\n\n        if (!response.ok) {\n          if (response.status === 404) {\n            console.warn('[AnnotationManager] 批量标注端点不存在，将回退到传统模式');\n            return null; // 表示不支持批量API\n          }\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const result = await response.json();\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n\n        if (result.success) {\n          // 缓存批量数据\n          this.bulkAnnotationData = {\n            plantAnnotations: result.data.plantAnnotations || {},\n            imageAnnotations: result.data.imageAnnotations || {},\n            statistics: result.data.statistics || {}\n          };\n          this.bulkDataTimestamp = Date.now();\n          \n          // 更新个别缓存以保持一致性\n          this.updateIndividualCacheFromBulk();\n          \n          // 统计数据\n          const plantCount = Object.keys(this.bulkAnnotationData.plantAnnotations).length;\n          const imageCount = Object.keys(this.bulkAnnotationData.imageAnnotations).length;\n          this.performanceMetrics.totalAnnotations = this.calculateTotalAnnotations();\n          \n          console.log(`[AnnotationManager] 成功获取批量标注数据: ${plantCount} 个植物, ${imageCount} 个图像, ${this.performanceMetrics.totalAnnotations} 个标注点`);\n          \n          return this.bulkAnnotationData;\n        }\n\n        throw new Error(result.error || '获取批量标注数据失败');\n      } catch (fetchError) {\n        this.performanceMetrics.networkTime += performance.now() - startTime;\n        \n        if (fetchError.name === 'TypeError' && fetchError.message.includes('fetch')) {\n          throw new Error(`网络连接失败: 无法连接到后端服务 (${url})`);\n        }\n        throw fetchError;\n      }\n    }, '批量获取标注数据');\n  }\n\n  /**\n   * 获取植物标注数据 (优化版本，优先使用批量数据)\n   */\n  async getPlantAnnotations(plantId) {\n    if (!plantId) {\n      throw new Error('植物ID不能为空');\n    }\n\n    await this.ensureConnection();\n    \n    const cacheKey = `plant_${plantId}`;\n    \n    // 首先检查是否有批量数据缓存\n    if (this.bulkAnnotationData && !this.isBulkDataExpired()) {\n      const plantAnnotations = this.bulkAnnotationData.plantAnnotations[plantId] || [];\n      this.annotations.set(cacheKey, plantAnnotations);\n      this.performanceMetrics.cacheHits++;\n      return plantAnnotations;\n    }\n    \n    // 检查独立缓存\n    if (this.annotations.has(cacheKey) && !this.isCacheExpired(cacheKey)) {\n      this.performanceMetrics.cacheHits++;\n      return this.annotations.get(cacheKey);\n    }\n\n    // 回退到单独请求\n    return this.getSinglePlantAnnotations(plantId);\n  }\n\n  /**\n   * 获取图像标注数据 (优化版本，优先使用批量数据)\n   */\n  async getImageAnnotations(imageId) {\n    if (!imageId) {\n      throw new Error('图像ID不能为空');\n    }\n\n    await this.ensureConnection();\n    \n    const cacheKey = `image_${imageId}`;\n    \n    // 首先检查是否有批量数据缓存\n    if (this.bulkAnnotationData && !this.isBulkDataExpired()) {\n      const imageAnnotations = this.bulkAnnotationData.imageAnnotations[imageId] || [];\n      this.annotations.set(cacheKey, imageAnnotations);\n      this.performanceMetrics.cacheHits++;\n      return imageAnnotations;\n    }\n    \n    // 检查独立缓存\n    if (this.annotations.has(cacheKey) && !this.isCacheExpired(cacheKey)) {\n      this.performanceMetrics.cacheHits++;\n      return this.annotations.get(cacheKey);\n    }\n\n    // 回退到单独请求\n    return this.getSingleImageAnnotations(imageId);\n  }\n\n  /**\n   * 获取快速标注统计（用于Badge更新）\n   */\n  async getQuickAnnotationStats() {\n    console.log('[AnnotationManager] 获取快速标注统计...');\n    \n    try {\n      const bulkData = await this.getAllAnnotationsInBulk();\n      \n      if (!bulkData) {\n        console.warn('[AnnotationManager] 批量API不可用，回退到传统模式');\n        return null;\n      }\n      \n      const stats = {};\n      \n      // 计算每个植物的标注统计\n      for (const [plantId, plantAnnotations] of Object.entries(bulkData.plantAnnotations)) {\n        let imageAnnotationCount = 0;\n        \n        // 统计该植物所有图像的标注数\n        for (const [imageId, imageAnnotations] of Object.entries(bulkData.imageAnnotations)) {\n          if (imageId.startsWith(plantId + '_')) {\n            imageAnnotationCount += imageAnnotations.length;\n          }\n        }\n        \n        stats[plantId] = {\n          plantAnnotations: plantAnnotations.length,\n          imageAnnotations: imageAnnotationCount,\n          total: plantAnnotations.length + imageAnnotationCount\n        };\n      }\n      \n      console.log(`[AnnotationManager] 快速统计完成: ${Object.keys(stats).length} 个植物`);\n      return stats;\n    } catch (error) {\n      console.error('[AnnotationManager] 获取快速标注统计失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 单独获取植物标注（回退方案）\n   */\n  async getSinglePlantAnnotations(plantId) {\n    const startTime = performance.now();\n    \n    try {\n      // 🔧 FIX: Consistent URL construction to avoid double /api/\n      const baseUrl = this.httpManager.baseUrl.replace(/\\/api$/, '');\n      const url = `${baseUrl}/api/plant-annotations/${encodeURIComponent(plantId)}`;\n      \n      const response = await fetch(url);\n      this.performanceMetrics.requestCount++;\n\n      if (!response.ok) {\n        if (response.status === 404) {\n          const emptyResult = [];\n          this.setCache(`plant_${plantId}`, emptyResult);\n          return emptyResult;\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      this.performanceMetrics.networkTime += performance.now() - startTime;\n\n      if (result.success) {\n        this.setCache(`plant_${plantId}`, result.data);\n        return result.data;\n      }\n\n      throw new Error(result.error || '获取植物标注失败');\n    } catch (fetchError) {\n      this.performanceMetrics.networkTime += performance.now() - startTime;\n      throw fetchError;\n    }\n  }\n\n  /**\n   * 单独获取图像标注（回退方案）\n   */\n  async getSingleImageAnnotations(imageId) {\n    const startTime = performance.now();\n    \n    try {\n      // 🔧 FIX: Consistent URL construction to avoid double /api/\n      const baseUrl = this.httpManager.baseUrl.replace(/\\/api$/, '');\n      const url = `${baseUrl}/api/image-annotations/${encodeURIComponent(imageId)}`;\n      \n      const response = await fetch(url);\n      this.performanceMetrics.requestCount++;\n\n      if (!response.ok) {\n        if (response.status === 404) {\n          const emptyResult = [];\n          this.setCache(`image_${imageId}`, emptyResult);\n          return emptyResult;\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      this.performanceMetrics.networkTime += performance.now() - startTime;\n\n      if (result.success) {\n        this.setCache(`image_${imageId}`, result.data);\n        return result.data;\n      }\n\n      throw new Error(result.error || '获取图像标注失败');\n    } catch (fetchError) {\n      this.performanceMetrics.networkTime += performance.now() - startTime;\n      throw fetchError;\n    }\n  }\n\n  /**\n   * 检查批量数据是否过期\n   */\n  isBulkDataExpired() {\n    if (!this.bulkDataTimestamp) return true;\n    return Date.now() - this.bulkDataTimestamp > this.cacheExpiration;\n  }\n\n  /**\n   * 从批量数据更新个别缓存\n   */\n  updateIndividualCacheFromBulk() {\n    if (!this.bulkAnnotationData) return;\n    \n    // 更新植物标注缓存\n    for (const [plantId, annotations] of Object.entries(this.bulkAnnotationData.plantAnnotations)) {\n      const cacheKey = `plant_${plantId}`;\n      this.setCache(cacheKey, annotations);\n    }\n    \n    // 更新图像标注缓存\n    for (const [imageId, annotations] of Object.entries(this.bulkAnnotationData.imageAnnotations)) {\n      const cacheKey = `image_${imageId}`;\n      this.setCache(cacheKey, annotations);\n    }\n  }\n\n  /**\n   * 计算总标注数量\n   */\n  calculateTotalAnnotations() {\n    if (!this.bulkAnnotationData) return 0;\n    \n    let total = 0;\n    \n    // 植物标注\n    for (const annotations of Object.values(this.bulkAnnotationData.plantAnnotations)) {\n      total += annotations.length;\n    }\n    \n    // 图像标注\n    for (const annotations of Object.values(this.bulkAnnotationData.imageAnnotations)) {\n      total += annotations.length;\n    }\n    \n    return total;\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache() {\n    this.annotations.clear();\n    this.cacheTimestamps.clear();\n    this.bulkAnnotationData = null;\n    this.bulkDataTimestamp = 0;\n    console.log('[AnnotationManager] 标注缓存已完全清除');\n  }\n\n  /**\n   * 设置缓存\n   */\n  setCache(key, data) {\n    this.annotations.set(key, data);\n    this.cacheTimestamps.set(key, Date.now());\n  }\n\n  /**\n   * 检查缓存是否过期\n   */\n  isCacheExpired(key) {\n    const timestamp = this.cacheTimestamps.get(key);\n    if (!timestamp) return true;\n    return Date.now() - timestamp > this.cacheExpiration;\n  }\n\n  /**\n   * 获取性能指标\n   */\n  getPerformanceMetrics() {\n    return {\n      ...this.performanceMetrics,\n      cacheSize: this.annotations.size,\n      hasBulkData: !!this.bulkAnnotationData,\n      bulkDataAge: this.bulkDataTimestamp ? Date.now() - this.bulkDataTimestamp : null,\n      averageRequestTime: this.performanceMetrics.requestCount > 0 \n        ? this.performanceMetrics.networkTime / this.performanceMetrics.requestCount \n        : 0\n    };\n  }\n\n  /**\n   * 强制刷新批量数据\n   */\n  async refreshBulkData() {\n    console.log('[AnnotationManager] 强制刷新批量标注数据...');\n    this.bulkAnnotationData = null;\n    this.bulkDataTimestamp = 0;\n    return await this.getAllAnnotationsInBulk();\n  }\n\n  /**\n   * 清理资源\n   */\n  cleanup() {\n    this.clearCache();\n    this.isInitialized = false;\n    console.log('[AnnotationManager] 清理完成');\n  }\n}","/**\n * Bulk Loading Performance Monitor\n * \n * 功能：\n * - 监控批量加载性能\n * - 跟踪缓存效果\n * - 性能指标收集和报告\n * - 自动优化建议\n */\n\nexport class BulkLoadingPerformanceMonitor {\n  constructor() {\n    this.metrics = {\n      // 加载性能\n      loadingStartTime: null,\n      loadingEndTime: null,\n      totalLoadingTime: 0,\n      \n      // 数据统计\n      plantsLoaded: 0,\n      annotationsLoaded: 0,\n      notesLoaded: 0,\n      \n      // 网络性能\n      networkRequests: 0,\n      bulkRequests: 0,\n      individualRequests: 0,\n      totalDataTransferred: 0,\n      \n      // 缓存性能\n      cacheHits: 0,\n      cacheMisses: 0,\n      cacheSize: 0,\n      \n      // 错误统计\n      errors: [],\n      fallbacksUsed: 0,\n      \n      // 用户体验\n      timeToFirstInteraction: 0,\n      timeToFullyLoaded: 0\n    };\n    \n    this.isMonitoring = false;\n    this.startTime = null;\n    this.checkpoints = [];\n  }\n\n  /**\n   * 开始监控加载过程\n   */\n  startMonitoring() {\n    this.isMonitoring = true;\n    this.startTime = performance.now();\n    this.metrics.loadingStartTime = Date.now();\n    this.checkpoints = [];\n    \n    console.log('[性能监控] 开始监控批量加载过程');\n  }\n\n  /**\n   * 添加检查点\n   */\n  addCheckpoint(name, details = {}) {\n    if (!this.isMonitoring) return;\n    \n    const checkpoint = {\n      name,\n      timestamp: performance.now(),\n      relativeTime: performance.now() - this.startTime,\n      details\n    };\n    \n    this.checkpoints.push(checkpoint);\n    console.log(`[性能监控] ${name}: ${checkpoint.relativeTime.toFixed(2)}ms`, details);\n  }\n\n  /**\n   * 记录数据加载完成\n   */\n  recordDataLoaded(type, count, dataSize = 0) {\n    switch (type) {\n      case 'plants':\n        this.metrics.plantsLoaded = count;\n        break;\n      case 'annotations':\n        this.metrics.annotationsLoaded = count;\n        break;\n      case 'notes':\n        this.metrics.notesLoaded = count;\n        break;\n    }\n    \n    this.metrics.totalDataTransferred += dataSize;\n    this.addCheckpoint(`${type} 数据加载完成`, { count, dataSize: `${(dataSize / 1024).toFixed(2)}KB` });\n  }\n\n  /**\n   * 记录网络请求\n   */\n  recordNetworkRequest(type, isBulk = false) {\n    this.metrics.networkRequests++;\n    \n    if (isBulk) {\n      this.metrics.bulkRequests++;\n    } else {\n      this.metrics.individualRequests++;\n    }\n    \n    this.addCheckpoint(`网络请求: ${type}`, { isBulk, total: this.metrics.networkRequests });\n  }\n\n  /**\n   * 记录缓存命中\n   */\n  recordCacheHit(type, cacheSize = 0) {\n    this.metrics.cacheHits++;\n    this.metrics.cacheSize = cacheSize;\n    \n    console.log(`[缓存命中] ${type} - 总命中: ${this.metrics.cacheHits}`);\n  }\n\n  /**\n   * 记录缓存未命中\n   */\n  recordCacheMiss(type) {\n    this.metrics.cacheMisses++;\n    \n    console.log(`[缓存未命中] ${type} - 总未命中: ${this.metrics.cacheMisses}`);\n  }\n\n  /**\n   * 记录错误\n   */\n  recordError(error, context = '') {\n    this.metrics.errors.push({\n      error: error.message,\n      context,\n      timestamp: Date.now()\n    });\n    \n    console.error(`[性能监控] 错误记录: ${context}`, error);\n  }\n\n  /**\n   * 记录回退使用\n   */\n  recordFallback(reason) {\n    this.metrics.fallbacksUsed++;\n    \n    this.addCheckpoint('使用回退方案', { reason, totalFallbacks: this.metrics.fallbacksUsed });\n  }\n\n  /**\n   * 结束监控并生成报告\n   */\n  endMonitoring() {\n    if (!this.isMonitoring) return null;\n    \n    this.isMonitoring = false;\n    this.metrics.loadingEndTime = Date.now();\n    this.metrics.totalLoadingTime = performance.now() - this.startTime;\n    \n    const report = this.generatePerformanceReport();\n    console.log('[性能监控] 加载完成，生成性能报告:', report);\n    \n    return report;\n  }\n\n  /**\n   * 生成性能报告\n   */\n  generatePerformanceReport() {\n    const cacheHitRate = this.metrics.cacheHits + this.metrics.cacheMisses > 0 \n      ? (this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) * 100).toFixed(1)\n      : 0;\n\n    const bulkRequestRatio = this.metrics.networkRequests > 0\n      ? (this.metrics.bulkRequests / this.metrics.networkRequests * 100).toFixed(1)\n      : 0;\n\n    const report = {\n      // 总体性能\n      summary: {\n        totalLoadingTime: `${this.metrics.totalLoadingTime.toFixed(2)}ms`,\n        dataLoaded: {\n          plants: this.metrics.plantsLoaded,\n          annotations: this.metrics.annotationsLoaded,\n          notes: this.metrics.notesLoaded\n        },\n        networkRequests: this.metrics.networkRequests,\n        dataTransferred: `${(this.metrics.totalDataTransferred / 1024).toFixed(2)}KB`\n      },\n      \n      // 网络性能\n      networkPerformance: {\n        totalRequests: this.metrics.networkRequests,\n        bulkRequests: this.metrics.bulkRequests,\n        individualRequests: this.metrics.individualRequests,\n        bulkRequestRatio: `${bulkRequestRatio}%`,\n        averageRequestSize: this.metrics.networkRequests > 0 \n          ? `${(this.metrics.totalDataTransferred / this.metrics.networkRequests / 1024).toFixed(2)}KB`\n          : '0KB'\n      },\n      \n      // 缓存性能\n      cachePerformance: {\n        hits: this.metrics.cacheHits,\n        misses: this.metrics.cacheMisses,\n        hitRate: `${cacheHitRate}%`,\n        cacheSize: `${(this.metrics.cacheSize / 1024).toFixed(2)}KB`\n      },\n      \n      // 错误和回退\n      reliability: {\n        errors: this.metrics.errors.length,\n        fallbacksUsed: this.metrics.fallbacksUsed,\n        errorDetails: this.metrics.errors\n      },\n      \n      // 检查点时间线\n      timeline: this.checkpoints,\n      \n      // 性能评级\n      performanceGrade: this.calculatePerformanceGrade(),\n      \n      // 优化建议\n      optimizationSuggestions: this.generateOptimizationSuggestions()\n    };\n\n    return report;\n  }\n\n  /**\n   * 计算性能评级\n   */\n  calculatePerformanceGrade() {\n    let score = 100;\n    \n    // 加载时间评分\n    if (this.metrics.totalLoadingTime > 5000) {\n      score -= 30; // 超过5秒扣30分\n    } else if (this.metrics.totalLoadingTime > 2000) {\n      score -= 15; // 超过2秒扣15分\n    } else if (this.metrics.totalLoadingTime > 1000) {\n      score -= 5; // 超过1秒扣5分\n    }\n    \n    // 网络请求评分\n    const requestEfficiency = this.metrics.bulkRequests / (this.metrics.networkRequests || 1);\n    if (requestEfficiency < 0.5) {\n      score -= 20; // 批量请求比例低于50%扣20分\n    } else if (requestEfficiency < 0.8) {\n      score -= 10; // 批量请求比例低于80%扣10分\n    }\n    \n    // 缓存效率评分\n    const cacheHitRate = this.metrics.cacheHits / ((this.metrics.cacheHits + this.metrics.cacheMisses) || 1);\n    if (cacheHitRate < 0.6) {\n      score -= 15; // 缓存命中率低于60%扣15分\n    } else if (cacheHitRate < 0.8) {\n      score -= 8; // 缓存命中率低于80%扣8分\n    }\n    \n    // 错误和回退评分\n    score -= this.metrics.errors.length * 5; // 每个错误扣5分\n    score -= this.metrics.fallbacksUsed * 3; // 每次回退扣3分\n    \n    // 确保分数在0-100之间\n    score = Math.max(0, Math.min(100, score));\n    \n    if (score >= 90) return 'A+';\n    if (score >= 80) return 'A';\n    if (score >= 70) return 'B';\n    if (score >= 60) return 'C';\n    if (score >= 50) return 'D';\n    return 'F';\n  }\n\n  /**\n   * 生成优化建议\n   */\n  generateOptimizationSuggestions() {\n    const suggestions = [];\n    \n    // 加载时间建议\n    if (this.metrics.totalLoadingTime > 2000) {\n      suggestions.push({\n        category: '加载性能',\n        suggestion: '考虑实现数据分页或增量加载',\n        priority: 'high',\n        impact: '减少初始加载时间50%+'\n      });\n    }\n    \n    // 网络请求建议\n    const bulkRatio = this.metrics.bulkRequests / (this.metrics.networkRequests || 1);\n    if (bulkRatio < 0.8) {\n      suggestions.push({\n        category: '网络优化',\n        suggestion: '增加批量API的使用，减少单独请求',\n        priority: 'high',\n        impact: '减少网络请求80%+'\n      });\n    }\n    \n    // 缓存建议\n    const cacheHitRate = this.metrics.cacheHits / ((this.metrics.cacheHits + this.metrics.cacheMisses) || 1);\n    if (cacheHitRate < 0.7) {\n      suggestions.push({\n        category: '缓存优化',\n        suggestion: '优化缓存策略，增加缓存时间或改进缓存键设计',\n        priority: 'medium',\n        impact: '提高响应速度30%+'\n      });\n    }\n    \n    // 错误处理建议\n    if (this.metrics.errors.length > 0) {\n      suggestions.push({\n        category: '错误处理',\n        suggestion: '改进错误处理和重试机制',\n        priority: 'medium',\n        impact: '提高系统稳定性'\n      });\n    }\n    \n    // 回退建议\n    if (this.metrics.fallbacksUsed > 0) {\n      suggestions.push({\n        category: '兼容性',\n        suggestion: '确保批量API的可用性，减少回退方案的使用',\n        priority: 'low',\n        impact: '提高性能一致性'\n      });\n    }\n    \n    return suggestions;\n  }\n\n  /**\n   * 导出性能数据\n   */\n  exportMetrics() {\n    return {\n      metrics: this.metrics,\n      report: this.generatePerformanceReport(),\n      exportTime: new Date().toISOString()\n    };\n  }\n\n  /**\n   * 重置所有指标\n   */\n  reset() {\n    this.metrics = {\n      loadingStartTime: null,\n      loadingEndTime: null,\n      totalLoadingTime: 0,\n      plantsLoaded: 0,\n      annotationsLoaded: 0,\n      notesLoaded: 0,\n      networkRequests: 0,\n      bulkRequests: 0,\n      individualRequests: 0,\n      totalDataTransferred: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      cacheSize: 0,\n      errors: [],\n      fallbacksUsed: 0,\n      timeToFirstInteraction: 0,\n      timeToFullyLoaded: 0\n    };\n    \n    this.isMonitoring = false;\n    this.startTime = null;\n    this.checkpoints = [];\n    \n    console.log('[性能监控] 指标已重置');\n  }\n}","/**\n * RealTimeSyncManager - Manages real-time synchronization of annotation operations\n * across future images within the same plant and view angle.\n * \n * Features:\n * - Toggle-able real-time synchronization\n * - Sync keypoint operations (add, move, delete) to future images\n * - Compatible with existing save logic\n * - Sequential processing to avoid race conditions\n */\nclass RealTimeSyncManager {\n  constructor(plantDataManager, annotationStorageManager) {\n    this.plantDataManager = plantDataManager;\n    this.annotationStorageManager = annotationStorageManager;\n    \n    // Sync state\n    this.isEnabled = false;\n    this.isSyncing = false;\n    this.syncQueue = [];\n    \n    // Operation types\n    this.OPERATION_TYPES = {\n      ADD_KEYPOINT: 'ADD_KEYPOINT',\n      MOVE_KEYPOINT: 'MOVE_KEYPOINT',\n      DELETE_KEYPOINT: 'DELETE_KEYPOINT',\n      EDIT_DIRECTION: 'EDIT_DIRECTION', // 🔧 NEW: Direction-specific operation\n      CUSTOM_ANNOTATION_CREATE: 'CUSTOM_ANNOTATION_CREATE',\n      CUSTOM_ANNOTATION_UPDATE: 'CUSTOM_ANNOTATION_UPDATE',\n      CUSTOM_ANNOTATION_DELETE: 'CUSTOM_ANNOTATION_DELETE',\n      CUSTOM_TYPE_CREATE: 'CUSTOM_TYPE_CREATE'\n    };\n    \n    // Event listeners for UI feedback\n    this.eventListeners = new Map();\n    \n    console.log('🔄 RealTimeSyncManager initialized');\n  }\n\n  /**\n   * Enable or disable real-time synchronization\n   * @param {boolean} enabled - Whether to enable sync\n   */\n  setEnabled(enabled) {\n    this.isEnabled = Boolean(enabled);\n    console.log(`🔄 Real-time sync ${this.isEnabled ? 'enabled' : 'disabled'}`);\n    \n    // Emit event for UI updates\n    this.emit('syncToggled', { enabled: this.isEnabled });\n  }\n\n  /**\n   * Check if real-time sync is currently enabled\n   * @returns {boolean} True if sync is enabled\n   */\n  isRealTimeSyncEnabled() {\n    return this.isEnabled;\n  }\n\n  /**\n   * Check if sync operation is currently in progress\n   * @returns {boolean} True if syncing\n   */\n  isSyncInProgress() {\n    return this.isSyncing;\n  }\n\n  /**\n   * Add event listener for sync events\n   * @param {string} event - Event name\n   * @param {Function} listener - Event listener function\n   */\n  on(event, listener) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event).push(listener);\n  }\n\n  /**\n   * Remove event listener\n   * @param {string} event - Event name\n   * @param {Function} listener - Event listener function\n   */\n  off(event, listener) {\n    if (this.eventListeners.has(event)) {\n      const listeners = this.eventListeners.get(event);\n      const index = listeners.indexOf(listener);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Emit event to listeners\n   * @param {string} event - Event name\n   * @param {any} data - Event data\n   */\n  emit(event, data) {\n    if (this.eventListeners.has(event)) {\n      this.eventListeners.get(event).forEach(listener => {\n        try {\n          listener(data);\n        } catch (error) {\n          console.error(`Error in sync event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Get future images for the current plant and view angle\n   * @param {object} currentImage - Current image object\n   * @param {object} currentPlant - Current plant object\n   * @returns {Promise<Array>} Array of future images\n   */\n  async getFutureImages(currentImage, currentPlant) {\n    if (!currentImage || !currentPlant) {\n      console.warn('🔄 Cannot get future images: missing current image or plant');\n      return [];\n    }\n\n    try {\n      // Get all images for current plant and view angle\n      const allImages = await this.plantDataManager.getPlantImages(\n        currentPlant.id,\n        currentPlant.selectedViewAngle\n      );\n\n      if (!allImages || allImages.length === 0) {\n        return [];\n      }\n\n      // Get current image date for comparison\n      const currentDate = new Date(currentImage.dateTime);\n      const currentImageIndex = allImages.findIndex(img => img.id === currentImage.id);\n\n      // 🔧 FIX: Context-aware sync logic to prevent wrong annotations\n      // Instead of syncing to all later dates, only sync to images that come \n      // after the current image in sequence AND have later dates\n      \n      const futureImages = [];\n      \n      // Only consider images after current image in the sequence\n      for (let i = currentImageIndex + 1; i < allImages.length; i++) {\n        const image = allImages[i];\n        const imgDate = new Date(image.dateTime);\n        \n        // Only include if it's actually a later date (maintain chronological requirement)\n        if (imgDate > currentDate) {\n          futureImages.push(image);\n        }\n      }\n\n      // Sort by date to ensure chronological order\n      futureImages.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n\n      console.log(`🔄 Found ${futureImages.length} future images for sync (from index ${currentImageIndex + 1})`);\n      return futureImages;\n\n    } catch (error) {\n      console.error('🔄 Error getting future images:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Sync keypoint addition to future images\n   * @param {object} keypoint - The keypoint that was added\n   * @param {object} currentImage - Current image context\n   * @param {object} currentPlant - Current plant context\n   * @returns {Promise<object>} Sync result\n   */\n  async syncKeypointAddition(keypoint, currentImage, currentPlant) {\n    if (!this.isEnabled) {\n      return { success: true, message: 'Sync disabled', synced: 0 };\n    }\n\n    console.log(`🔄 Starting keypoint addition sync for keypoint ${keypoint.id}`);\n    console.log(`🔄 Current image: ${currentImage.id}, Plant: ${currentPlant.id}, View: ${currentPlant.selectedViewAngle}`);\n\n    try {\n      const futureImages = await this.getFutureImages(currentImage, currentPlant);\n      \n      if (futureImages.length === 0) {\n        console.log(`🔄 No future images found for sync`);\n        return { success: true, message: 'No future images to sync', synced: 0 };\n      }\n\n      console.log(`🔄 Found ${futureImages.length} future images:`, futureImages.map(img => img.id));\n\n      let syncedCount = 0;\n      const errors = [];\n\n      // Process each future image sequentially to avoid conflicts\n      for (const image of futureImages) {\n        try {\n          console.log(`🔄 Syncing keypoint ${keypoint.id} to image ${image.id}...`);\n          await this.addKeypointToImage(keypoint, image);\n          syncedCount++;\n          console.log(`🔄 Successfully synced to image ${image.id}`);\n        } catch (error) {\n          console.error(`🔄 Error syncing to image ${image.id}:`, error);\n          errors.push({ imageId: image.id, error: error.message });\n        }\n      }\n\n      const result = {\n        success: errors.length === 0,\n        message: `Synced to ${syncedCount} future images`,\n        synced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined\n      };\n\n      console.log(`🔄 Keypoint addition sync completed:`, result);\n      return result;\n\n    } catch (error) {\n      console.error('🔄 Error in keypoint addition sync:', error);\n      return { success: false, message: error.message, synced: 0 };\n    }\n  }\n\n  /**\n   * Sync keypoint movement to future images\n   * @param {object} keypoint - The keypoint that was moved\n   * @param {object} previousPosition - Previous position {x, y}\n   * @param {object} currentImage - Current image context\n   * @param {object} currentPlant - Current plant context\n   * @returns {Promise<object>} Sync result\n   */\n  async syncKeypointMovement(keypoint, previousPosition, currentImage, currentPlant) {\n    if (!this.isEnabled) {\n      return { success: true, message: 'Sync disabled', synced: 0 };\n    }\n\n    console.log(`🔄 Starting keypoint movement sync for keypoint ${keypoint.id}`);\n\n    try {\n      const futureImages = await this.getFutureImages(currentImage, currentPlant);\n      \n      if (futureImages.length === 0) {\n        return { success: true, message: 'No future images to sync', synced: 0 };\n      }\n\n      let syncedCount = 0;\n      const errors = [];\n\n      // Process each future image sequentially\n      for (const image of futureImages) {\n        try {\n          await this.moveKeypointInImage(keypoint, image);\n          syncedCount++;\n        } catch (error) {\n          console.error(`🔄 Error syncing movement to image ${image.id}:`, error);\n          errors.push({ imageId: image.id, error: error.message });\n        }\n      }\n\n      const result = {\n        success: errors.length === 0,\n        message: `Synced movement to ${syncedCount} future images`,\n        synced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined\n      };\n\n      console.log(`🔄 Keypoint movement sync completed:`, result);\n      return result;\n\n    } catch (error) {\n      console.error('🔄 Error in keypoint movement sync:', error);\n      return { success: false, message: error.message, synced: 0 };\n    }\n  }\n\n  /**\n   * Sync keypoint deletion to future images\n   * @param {object} payload - Deletion payload containing keypoint and context\n   * @returns {Promise<object>} Sync result\n   */\n  async syncKeypointDeletion(payload) {\n    if (!this.isEnabled) {\n      return { success: true, message: 'Sync disabled', synced: 0 };\n    }\n\n    const { keypoint, currentImage, currentPlant } = payload;\n\n    console.log(`🔄 Starting keypoint deletion sync for keypoint ${keypoint.id}`);\n    console.log(`🔄 Current image: ${currentImage.id}, Plant: ${currentPlant.id}, View: ${currentPlant.selectedViewAngle}`);\n\n    try {\n      const futureImages = await this.getFutureImages(currentImage, currentPlant);\n      \n      if (futureImages.length === 0) {\n        console.log(`🔄 No future images found for deletion sync`);\n        return { success: true, message: 'No future images to sync', synced: 0 };\n      }\n\n      console.log(`🔄 Found ${futureImages.length} future images:`, futureImages.map(img => img.id));\n\n      let syncedCount = 0;\n      const errors = [];\n\n      // Process each future image sequentially to avoid conflicts\n      for (const image of futureImages) {\n        try {\n          console.log(`🔄 Syncing keypoint deletion to image ${image.id}...`);\n          await this.deleteKeypointFromImage(keypoint, image);\n          syncedCount++;\n          console.log(`🔄 Successfully synced deletion to image ${image.id}`);\n        } catch (error) {\n          console.error(`🔄 Error syncing deletion to image ${image.id}:`, error);\n          errors.push({ imageId: image.id, error: error.message });\n        }\n      }\n\n      const result = {\n        success: errors.length === 0,\n        message: `Synced deletion to ${syncedCount} future images`,\n        synced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined\n      };\n\n      console.log(`🔄 Keypoint deletion sync completed:`, result);\n      return result;\n\n    } catch (error) {\n      console.error('🔄 Error in keypoint deletion sync:', error);\n      return { success: false, message: error.message, synced: 0 };\n    }\n  }\n\n  /**\n   * Add keypoint to a specific image\n   * @param {object} keypoint - Keypoint to add\n   * @param {object} targetImage - Target image\n   * @returns {Promise<void>}\n   */\n  async addKeypointToImage(keypoint, targetImage) {\n    // Get existing annotations for the target image\n    const existingData = await this.annotationStorageManager.getImageAnnotation(targetImage.id);\n    const existingAnnotations = existingData ? existingData.annotations : [];\n    \n    // 🔧 FIX: Use order-based matching for consistent sync behavior\n    // This is crucial for real-time sync: sync by order + type, not by ID\n    const existingKeypoint = existingAnnotations.find(ann => {\n      const orderMatch = ann.order === keypoint.order;\n      const typeMatch = ann.annotationType === keypoint.annotationType;\n      \n      // For custom annotations, customTypeId must also match\n      const customTypeMatch = keypoint.annotationType === 'custom' \n        ? ann.customTypeId === keypoint.customTypeId\n        : true;\n      \n      return orderMatch && typeMatch && customTypeMatch;\n    });\n    \n    if (existingKeypoint) {\n      // Update existing keypoint position and all properties\n      existingKeypoint.x = keypoint.x;\n      existingKeypoint.y = keypoint.y;\n      existingKeypoint.direction = keypoint.direction;\n      existingKeypoint.directionType = keypoint.directionType;\n      existingKeypoint.directions = keypoint.directions; // 🔧 NEW: Support multi-direction\n      existingKeypoint.maxDirections = keypoint.maxDirections; // 🔧 NEW: Support multi-direction\n      existingKeypoint.timestamp = new Date().toISOString();\n      \n      // 🔧 Enhanced Debug: Log annotation details\n      const typeDesc = keypoint.annotationType === 'custom' ? \n        `custom(${keypoint.customTypeId})` : 'regular';\n      console.log(`🔄 Updated existing ${typeDesc} keypoint order ${keypoint.order} in image ${targetImage.id}`);\n    } else {\n      // Add new keypoint\n      const newKeypoint = {\n        ...keypoint,\n        timestamp: new Date().toISOString() // Update timestamp for sync\n      };\n      existingAnnotations.push(newKeypoint);\n      \n      // 🔧 Enhanced Debug: Log annotation details\n      const typeDesc = keypoint.annotationType === 'custom' ? \n        `custom(${keypoint.customTypeId})` : 'regular';\n      console.log(`🔄 Added new ${typeDesc} keypoint order ${keypoint.order} to image ${targetImage.id}`);\n    }\n\n    // Prepare complete annotation data object\n    const annotationData = {\n      imageId: targetImage.id,\n      annotations: existingAnnotations,\n      lastModified: new Date().toISOString()\n    };\n\n    // Save updated annotations\n    await this.annotationStorageManager.saveImageAnnotation(targetImage.id, annotationData);\n  }\n\n  /**\n   * Move keypoint in a specific image\n   * @param {object} keypoint - Keypoint with new position\n   * @param {object} targetImage - Target image\n   * @returns {Promise<void>}\n   */\n  async moveKeypointInImage(keypoint, targetImage) {\n    // Get existing annotations for the target image\n    const existingData = await this.annotationStorageManager.getImageAnnotation(targetImage.id);\n    const existingAnnotations = existingData ? existingData.annotations : [];\n    \n    // 🔧 FIX: Use order-based matching for consistent sync behavior\n    // This is crucial for real-time sync: sync by order + type, not by ID\n    const existingKeypoint = existingAnnotations.find(ann => {\n      const orderMatch = ann.order === keypoint.order;\n      const typeMatch = ann.annotationType === keypoint.annotationType;\n      \n      // For custom annotations, customTypeId must also match\n      const customTypeMatch = keypoint.annotationType === 'custom' \n        ? ann.customTypeId === keypoint.customTypeId\n        : true;\n      \n      return orderMatch && typeMatch && customTypeMatch;\n    });\n    \n    if (existingKeypoint) {\n      // Update position and all properties\n      existingKeypoint.x = keypoint.x;\n      existingKeypoint.y = keypoint.y;\n      existingKeypoint.direction = keypoint.direction;\n      existingKeypoint.directionType = keypoint.directionType;\n      existingKeypoint.directions = keypoint.directions; // 🔧 NEW: Support multi-direction\n      existingKeypoint.maxDirections = keypoint.maxDirections; // 🔧 NEW: Support multi-direction\n      existingKeypoint.timestamp = new Date().toISOString();\n      \n      // 🔧 Enhanced Debug: Log annotation details\n      const typeDesc = keypoint.annotationType === 'custom' ? \n        `custom(${keypoint.customTypeId})` : 'regular';\n      console.log(`🔄 Moved ${typeDesc} keypoint order ${keypoint.order} in image ${targetImage.id}`);\n    } else {\n      // Add new keypoint if it doesn't exist (order-based sync)\n      const newKeypoint = {\n        ...keypoint,\n        timestamp: new Date().toISOString()\n      };\n      existingAnnotations.push(newKeypoint);\n      \n      // 🔧 Enhanced Debug: Log annotation details\n      const typeDesc = keypoint.annotationType === 'custom' ? \n        `custom(${keypoint.customTypeId})` : 'regular';\n      console.log(`🔄 Added new ${typeDesc} keypoint order ${keypoint.order} to image ${targetImage.id} (move operation)`);\n    }\n\n    // Prepare complete annotation data object\n    const annotationData = {\n      imageId: targetImage.id,\n      annotations: existingAnnotations,\n      lastModified: new Date().toISOString()\n    };\n\n    // Save updated annotations\n    await this.annotationStorageManager.saveImageAnnotation(targetImage.id, annotationData);\n  }\n\n  /**\n   * Delete keypoint from a specific image with strict matching criteria\n   * @param {object} keypoint - Keypoint to delete\n   * @param {object} targetImage - Target image\n   * @returns {Promise<void>}\n   */\n  async deleteKeypointFromImage(keypoint, targetImage) {\n    // Get existing annotations for the target image\n    const existingData = await this.annotationStorageManager.getImageAnnotation(targetImage.id);\n    const existingAnnotations = existingData ? existingData.annotations : [];\n    \n    if (existingAnnotations.length === 0) {\n      console.log(`🔄 No annotations found in image ${targetImage.id} - skipping deletion`);\n      return;\n    }\n\n    // Find matching keypoint using strict criteria:\n    // 1. order must match\n    // 2. annotationType must match\n    // 3. customTypeId must match (for custom annotations)\n    const matchingIndex = existingAnnotations.findIndex(ann => {\n      const orderMatch = ann.order === keypoint.order;\n      const typeMatch = ann.annotationType === keypoint.annotationType;\n      \n      // For custom annotations, customTypeId must also match\n      const customTypeMatch = keypoint.annotationType === 'custom' \n        ? ann.customTypeId === keypoint.customTypeId\n        : true;\n      \n      return orderMatch && typeMatch && customTypeMatch;\n    });\n    \n    if (matchingIndex !== -1) {\n      const removedKeypoint = existingAnnotations[matchingIndex];\n      existingAnnotations.splice(matchingIndex, 1);\n      \n      console.log(`🔄 Deleted keypoint from image ${targetImage.id}:`);\n      console.log(`  - Order: ${removedKeypoint.order}`);\n      console.log(`  - Type: ${removedKeypoint.annotationType}`);\n      console.log(`  - Custom Type ID: ${removedKeypoint.customTypeId || 'N/A'}`);\n      console.log(`  - ID: ${removedKeypoint.id}`);\n    } else {\n      console.log(`🔄 No matching keypoint found in image ${targetImage.id} for deletion:`);\n      console.log(`  - Looking for order: ${keypoint.order}`);\n      console.log(`  - Looking for type: ${keypoint.annotationType}`);\n      console.log(`  - Looking for custom type ID: ${keypoint.customTypeId || 'N/A'}`);\n      console.log(`  - Available annotations:`, existingAnnotations.map(ann => ({\n        order: ann.order,\n        type: ann.annotationType,\n        customTypeId: ann.customTypeId,\n        id: ann.id\n      })));\n      return;\n    }\n\n    // Prepare complete annotation data object\n    const annotationData = {\n      imageId: targetImage.id,\n      annotations: existingAnnotations,\n      lastModified: new Date().toISOString()\n    };\n\n    // Save updated annotations\n    await this.annotationStorageManager.saveImageAnnotation(targetImage.id, annotationData);\n  }\n\n  /**\n   * Queue a sync operation for processing\n   * @param {object} operation - Sync operation details\n   * @returns {Promise<void>}\n   */\n  async queueSyncOperation(operation) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    this.syncQueue.push(operation);\n    \n    // Process queue if not already processing\n    if (!this.isSyncing) {\n      await this.processSyncQueue();\n    }\n  }\n\n  /**\n   * Process queued sync operations sequentially\n   * @returns {Promise<void>}\n   */\n  async processSyncQueue() {\n    if (this.isSyncing || this.syncQueue.length === 0) {\n      return;\n    }\n\n    this.isSyncing = true;\n    this.emit('syncStarted', { queueLength: this.syncQueue.length });\n\n    try {\n      while (this.syncQueue.length > 0) {\n        const operation = this.syncQueue.shift();\n        \n        try {\n          await this.executeOperation(operation);\n        } catch (error) {\n          console.error('🔄 Error executing sync operation:', error);\n          this.emit('syncError', { operation, error });\n        }\n      }\n    } finally {\n      this.isSyncing = false;\n      this.emit('syncCompleted', {});\n    }\n  }\n\n  /**\n   * Execute a specific sync operation\n   * @param {object} operation - Operation to execute\n   * @returns {Promise<void>}\n   */\n  async executeOperation(operation) {\n    const { type, keypoint, currentImage, currentPlant, previousPosition, syncData } = operation;\n\n    switch (type) {\n      case this.OPERATION_TYPES.ADD_KEYPOINT:\n        return await this.syncKeypointAddition(keypoint, currentImage, currentPlant);\n      \n      case this.OPERATION_TYPES.MOVE_KEYPOINT:\n        return await this.syncKeypointMovement(keypoint, previousPosition, currentImage, currentPlant);\n      \n      case this.OPERATION_TYPES.DELETE_KEYPOINT:\n        // 🔧 FIX: Properly handle keypoint deletion sync\n        return await this.syncKeypointDeletion(operation);\n      \n      case this.OPERATION_TYPES.EDIT_DIRECTION:\n        // 🔧 NEW: Direction-specific sync operation\n        return await this.syncDirectionEdit(operation);\n      \n      case this.OPERATION_TYPES.CUSTOM_ANNOTATION_CREATE:\n        return await this.syncCustomAnnotationCreate(syncData);\n      \n      case this.OPERATION_TYPES.CUSTOM_ANNOTATION_UPDATE:\n        return await this.syncCustomAnnotationUpdate(syncData);\n      \n      case this.OPERATION_TYPES.CUSTOM_ANNOTATION_DELETE:\n        return await this.syncCustomAnnotationDelete(syncData);\n      \n      case this.OPERATION_TYPES.CUSTOM_TYPE_CREATE:\n        return await this.syncCustomTypeCreate(syncData);\n      \n      default:\n        console.warn(`🔄 Unknown sync operation type: ${type}`);\n    }\n  }\n\n  /**\n   * Sync direction edit to future images\n   * @param {object} operation - Direction edit operation\n   * @returns {Promise<object>} Sync result\n   */\n  async syncDirectionEdit(operation) {\n    if (!this.isEnabled) {\n      return { success: true, message: 'Sync disabled', synced: 0 };\n    }\n\n    const { keypoint, currentImage, currentPlant } = operation;\n\n    console.log(`🔄 Starting direction edit sync for keypoint order ${keypoint.order}`);\n    console.log(`🔄 Current image: ${currentImage.id}, Plant: ${currentPlant.id}, View: ${currentPlant.selectedViewAngle}`);\n\n    try {\n      const futureImages = await this.getFutureImages(currentImage, currentPlant);\n      \n      if (futureImages.length === 0) {\n        console.log(`🔄 No future images found for direction edit sync`);\n        return { success: true, message: 'No future images to sync', synced: 0 };\n      }\n\n      console.log(`🔄 Found ${futureImages.length} future images:`, futureImages.map(img => img.id));\n\n      let syncedCount = 0;\n      const errors = [];\n\n      // Process each future image sequentially to avoid conflicts\n      for (const image of futureImages) {\n        try {\n          console.log(`🔄 Syncing direction edit to image ${image.id}...`);\n          await this.editDirectionInImage(keypoint, image);\n          syncedCount++;\n          console.log(`🔄 Successfully synced direction edit to image ${image.id}`);\n        } catch (error) {\n          console.error(`🔄 Error syncing direction edit to image ${image.id}:`, error);\n          errors.push({ imageId: image.id, error: error.message });\n        }\n      }\n\n      const result = {\n        success: errors.length === 0,\n        message: `Synced direction edit to ${syncedCount} future images`,\n        synced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined\n      };\n\n      console.log(`🔄 Direction edit sync completed:`, result);\n      return result;\n\n    } catch (error) {\n      console.error('🔄 Error in direction edit sync:', error);\n      return { success: false, message: error.message, synced: 0 };\n    }\n  }\n\n  /**\n   * Edit direction in a specific image\n   * @param {object} keypoint - Keypoint with updated direction\n   * @param {object} targetImage - Target image\n   * @returns {Promise<void>}\n   */\n  async editDirectionInImage(keypoint, targetImage) {\n    // Get existing annotations for the target image\n    const existingData = await this.annotationStorageManager.getImageAnnotation(targetImage.id);\n    const existingAnnotations = existingData ? existingData.annotations : [];\n    \n    // 🔧 FIX: Use order-based matching for direction edits\n    const existingKeypoint = existingAnnotations.find(ann => {\n      const orderMatch = ann.order === keypoint.order;\n      const typeMatch = ann.annotationType === keypoint.annotationType;\n      \n      // For custom annotations, customTypeId must also match\n      const customTypeMatch = keypoint.annotationType === 'custom' \n        ? ann.customTypeId === keypoint.customTypeId\n        : true;\n      \n      return orderMatch && typeMatch && customTypeMatch;\n    });\n    \n    if (existingKeypoint) {\n      // Update only direction-related properties\n      existingKeypoint.direction = keypoint.direction;\n      existingKeypoint.directionType = keypoint.directionType;\n      existingKeypoint.directions = keypoint.directions; // 🔧 NEW: Support multi-direction\n      existingKeypoint.maxDirections = keypoint.maxDirections; // 🔧 NEW: Support multi-direction\n      existingKeypoint.timestamp = new Date().toISOString();\n      \n      // 🔧 Enhanced Debug: Log direction edit details\n      const typeDesc = keypoint.annotationType === 'custom' ? \n        `custom(${keypoint.customTypeId})` : 'regular';\n      console.log(`🔄 Updated direction for ${typeDesc} keypoint order ${keypoint.order} in image ${targetImage.id}`);\n    } else {\n      // Add new keypoint if it doesn't exist (order-based sync)\n      const newKeypoint = {\n        ...keypoint,\n        timestamp: new Date().toISOString()\n      };\n      existingAnnotations.push(newKeypoint);\n      \n      // 🔧 Enhanced Debug: Log annotation details\n      const typeDesc = keypoint.annotationType === 'custom' ? \n        `custom(${keypoint.customTypeId})` : 'regular';\n      console.log(`🔄 Added new ${typeDesc} keypoint order ${keypoint.order} to image ${targetImage.id} (direction edit operation)`);\n    }\n\n    // Prepare complete annotation data object\n    const annotationData = {\n      imageId: targetImage.id,\n      annotations: existingAnnotations,\n      lastModified: new Date().toISOString()\n    };\n\n    // Save updated annotations\n    await this.annotationStorageManager.saveImageAnnotation(targetImage.id, annotationData);\n  }\n  /**\n   * Sync custom annotation creation to future images\n   * @param {object} syncData - Custom annotation sync data\n   * @returns {Promise<object>} Sync result\n   */\n  async syncCustomAnnotationCreate(syncData) {\n    console.log('🔄 Starting custom annotation creation sync:', syncData);\n    \n    try {\n      // Extract context information\n      const { annotation, context } = syncData;\n      const { appState } = context;\n      \n      if (!appState?.currentImage || !appState?.currentPlant) {\n        console.warn('🔄 Missing app state for custom annotation sync');\n        return { success: false, message: 'Missing app state', synced: 0 };\n      }\n      \n      const futureImages = await this.getFutureImages(appState.currentImage, appState.currentPlant);\n      \n      if (futureImages.length === 0) {\n        console.log('🔄 No future images found for custom annotation sync');\n        return { success: true, message: 'No future images to sync', synced: 0 };\n      }\n      \n      let syncedCount = 0;\n      const errors = [];\n      \n      // Process each future image sequentially\n      for (const image of futureImages) {\n        try {\n          console.log(`🔄 Syncing custom annotation to image ${image.id}...`);\n          await this.addCustomAnnotationToImage(annotation, image);\n          syncedCount++;\n          console.log(`🔄 Successfully synced custom annotation to image ${image.id}`);\n        } catch (error) {\n          console.error(`🔄 Error syncing custom annotation to image ${image.id}:`, error);\n          errors.push({ imageId: image.id, error: error.message });\n        }\n      }\n      \n      const result = {\n        success: errors.length === 0,\n        message: `Synced custom annotation to ${syncedCount} future images`,\n        synced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined\n      };\n      \n      console.log('🔄 Custom annotation creation sync completed:', result);\n      return result;\n      \n    } catch (error) {\n      console.error('🔄 Error in custom annotation creation sync:', error);\n      return { success: false, message: error.message, synced: 0 };\n    }\n  }\n\n  /**\n   * Sync custom annotation update to future images\n   * @param {object} syncData - Custom annotation sync data\n   * @returns {Promise<object>} Sync result\n   */\n  async syncCustomAnnotationUpdate(syncData) {\n    console.log('🔄 Starting custom annotation update sync:', syncData);\n    \n    try {\n      // Extract context information\n      const { annotation, context } = syncData;\n      const { appState } = context;\n      \n      if (!appState?.currentImage || !appState?.currentPlant) {\n        console.warn('🔄 Missing app state for custom annotation update sync');\n        return { success: false, message: 'Missing app state', synced: 0 };\n      }\n      \n      const futureImages = await this.getFutureImages(appState.currentImage, appState.currentPlant);\n      \n      if (futureImages.length === 0) {\n        return { success: true, message: 'No future images to sync', synced: 0 };\n      }\n      \n      let syncedCount = 0;\n      const errors = [];\n      \n      // Process each future image sequentially\n      for (const image of futureImages) {\n        try {\n          await this.updateCustomAnnotationInImage(annotation, image);\n          syncedCount++;\n        } catch (error) {\n          console.error(`🔄 Error updating custom annotation in image ${image.id}:`, error);\n          errors.push({ imageId: image.id, error: error.message });\n        }\n      }\n      \n      const result = {\n        success: errors.length === 0,\n        message: `Updated custom annotation in ${syncedCount} future images`,\n        synced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined\n      };\n      \n      console.log('🔄 Custom annotation update sync completed:', result);\n      return result;\n      \n    } catch (error) {\n      console.error('🔄 Error in custom annotation update sync:', error);\n      return { success: false, message: error.message, synced: 0 };\n    }\n  }\n\n  /**\n   * Sync custom annotation deletion to future images\n   * @param {object} syncData - Custom annotation sync data\n   * @returns {Promise<object>} Sync result\n   */\n  async syncCustomAnnotationDelete(syncData) {\n    console.log('🔄 Starting custom annotation deletion sync:', syncData);\n    \n    try {\n      // Extract context information\n      const { annotation, context } = syncData;\n      const { appState } = context;\n      \n      if (!appState?.currentImage || !appState?.currentPlant) {\n        console.warn('🔄 Missing app state for custom annotation deletion sync');\n        return { success: false, message: 'Missing app state', synced: 0 };\n      }\n      \n      const futureImages = await this.getFutureImages(appState.currentImage, appState.currentPlant);\n      \n      if (futureImages.length === 0) {\n        return { success: true, message: 'No future images to sync', synced: 0 };\n      }\n      \n      let syncedCount = 0;\n      const errors = [];\n      \n      // Process each future image sequentially\n      for (const image of futureImages) {\n        try {\n          await this.deleteCustomAnnotationFromImage(annotation, image);\n          syncedCount++;\n        } catch (error) {\n          console.error(`🔄 Error deleting custom annotation from image ${image.id}:`, error);\n          errors.push({ imageId: image.id, error: error.message });\n        }\n      }\n      \n      const result = {\n        success: errors.length === 0,\n        message: `Deleted custom annotation from ${syncedCount} future images`,\n        synced: syncedCount,\n        errors: errors.length > 0 ? errors : undefined\n      };\n      \n      console.log('🔄 Custom annotation deletion sync completed:', result);\n      return result;\n      \n    } catch (error) {\n      console.error('🔄 Error in custom annotation deletion sync:', error);\n      return { success: false, message: error.message, synced: 0 };\n    }\n  }\n\n  /**\n   * Sync custom type creation to future images\n   * @param {object} syncData - Custom type sync data\n   * @returns {Promise<object>} Sync result\n   */\n  async syncCustomTypeCreate(syncData) {\n    console.log('🔄 Starting custom type creation sync:', syncData);\n    \n    // For custom type creation, we typically don't need to sync to future images\n    // since types are global and don't belong to specific images\n    // This is more of a metadata sync that could be handled separately\n    \n    console.log('🔄 Custom type creation sync - no image sync needed');\n    return { success: true, message: 'Custom type created (no image sync required)', synced: 0 };\n  }\n\n  /**\n   * Add custom annotation to a specific image\n   * @param {object} annotation - Custom annotation to add\n   * @param {object} targetImage - Target image\n   * @returns {Promise<void>}\n   */\n  async addCustomAnnotationToImage(annotation, targetImage) {\n    // Get existing annotations for the target image\n    const existingData = await this.annotationStorageManager.getImageAnnotation(targetImage.id);\n    const existingAnnotations = existingData ? existingData.annotations : [];\n    \n    // 🔧 FIX: Use order-based matching for custom annotations (not ID-based)\n    // This is the core of real-time sync: sync by order + custom type, not by ID\n    const existingCustomAnnotation = existingAnnotations.find(ann => \n      ann.annotationType === 'custom' && \n      ann.customTypeId === annotation.customTypeId &&\n      ann.order === annotation.order\n    );\n    \n    if (existingCustomAnnotation) {\n      // Update existing custom annotation with same order and type\n      Object.assign(existingCustomAnnotation, annotation);\n      existingCustomAnnotation.timestamp = new Date().toISOString();\n      \n      console.log(`🔄 Updated existing custom annotation order ${annotation.order} type ${annotation.customTypeId} in image ${targetImage.id}`);\n    } else {\n      // 🔧 FIX: Remove conflict detection - order-based sync is the intended behavior\n      // The previous conflict detection was preventing legitimate sync operations\n      // Real-time sync SHOULD create annotations with same order on future frames\n      \n      // Add new custom annotation\n      const newAnnotation = {\n        ...annotation,\n        timestamp: new Date().toISOString()\n      };\n      existingAnnotations.push(newAnnotation);\n      \n      console.log(`🔄 Added new custom annotation order ${annotation.order} type ${annotation.customTypeId} to image ${targetImage.id}`);\n    }\n\n    // Prepare complete annotation data object\n    const annotationData = {\n      imageId: targetImage.id,\n      annotations: existingAnnotations,\n      lastModified: new Date().toISOString()\n    };\n\n    // Save updated annotations\n    await this.annotationStorageManager.saveImageAnnotation(targetImage.id, annotationData);\n  }\n\n  /**\n   * Update custom annotation in a specific image\n   * @param {object} annotation - Custom annotation with updates\n   * @param {object} targetImage - Target image\n   * @returns {Promise<void>}\n   */\n  async updateCustomAnnotationInImage(annotation, targetImage) {\n    // Get existing annotations for the target image\n    const existingData = await this.annotationStorageManager.getImageAnnotation(targetImage.id);\n    const existingAnnotations = existingData ? existingData.annotations : [];\n    \n    // 🔧 FIX: Use order-based matching for custom annotations (not ID-based)\n    // This is crucial for move operations - we need to match by order + type, not ID\n    const existingCustomAnnotation = existingAnnotations.find(ann => \n      ann.annotationType === 'custom' && \n      ann.customTypeId === annotation.customTypeId &&\n      ann.order === annotation.order\n    );\n    \n    if (existingCustomAnnotation) {\n      // Update existing custom annotation with same order and type\n      Object.assign(existingCustomAnnotation, annotation);\n      existingCustomAnnotation.timestamp = new Date().toISOString();\n      \n      console.log(`🔄 Updated custom annotation order ${annotation.order} type ${annotation.customTypeId} in image ${targetImage.id}`);\n    } else {\n      // Add new custom annotation if it doesn't exist (order-based sync)\n      const newAnnotation = {\n        ...annotation,\n        timestamp: new Date().toISOString()\n      };\n      existingAnnotations.push(newAnnotation);\n      \n      console.log(`🔄 Added new custom annotation order ${annotation.order} type ${annotation.customTypeId} to image ${targetImage.id} (update operation)`);\n    }\n\n    // Prepare complete annotation data object\n    const annotationData = {\n      imageId: targetImage.id,\n      annotations: existingAnnotations,\n      lastModified: new Date().toISOString()\n    };\n\n    // Save updated annotations\n    await this.annotationStorageManager.saveImageAnnotation(targetImage.id, annotationData);\n  }\n\n  /**\n   * Delete custom annotation from a specific image\n   * @param {object} annotation - Custom annotation to delete\n   * @param {object} targetImage - Target image\n   * @returns {Promise<void>}\n   */\n  async deleteCustomAnnotationFromImage(annotation, targetImage) {\n    // Get existing annotations for the target image\n    const existingData = await this.annotationStorageManager.getImageAnnotation(targetImage.id);\n    const existingAnnotations = existingData ? existingData.annotations : [];\n    \n    if (existingAnnotations.length === 0) {\n      console.log(`🔄 No annotations found in image ${targetImage.id} - skipping custom annotation deletion`);\n      return;\n    }\n\n    // 🔧 FIX: Use order-based matching for custom annotations (not ID-based)\n    // This is crucial for delete operations - we need to match by order + type, not ID\n    const matchingIndex = existingAnnotations.findIndex(ann => \n      ann.annotationType === 'custom' && \n      ann.customTypeId === annotation.customTypeId &&\n      ann.order === annotation.order\n    );\n    \n    if (matchingIndex !== -1) {\n      const removedAnnotation = existingAnnotations[matchingIndex];\n      existingAnnotations.splice(matchingIndex, 1);\n      \n      console.log(`🔄 Deleted custom annotation order ${removedAnnotation.order} type ${removedAnnotation.customTypeId} from image ${targetImage.id}`);\n    } else {\n      console.log(`🔄 No matching custom annotation order ${annotation.order} type ${annotation.customTypeId} found in image ${targetImage.id} for deletion`);\n      return;\n    }\n\n    // Prepare complete annotation data object\n    const annotationData = {\n      imageId: targetImage.id,\n      annotations: existingAnnotations,\n      lastModified: new Date().toISOString()\n    };\n\n    // Save updated annotations\n    await this.annotationStorageManager.saveImageAnnotation(targetImage.id, annotationData);\n  }\n\n  /**\n   * Trigger sync for keypoint addition\n   * @param {object} keypoint - Added keypoint\n   * @param {object} currentImage - Current image context\n   * @param {object} currentPlant - Current plant context\n   * @returns {Promise<void>}\n   */\n  async triggerKeypointAddSync(keypoint, currentImage, currentPlant) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    const operation = {\n      type: this.OPERATION_TYPES.ADD_KEYPOINT,\n      keypoint,\n      currentImage,\n      currentPlant,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.queueSyncOperation(operation);\n  }\n\n  /**\n   * Trigger sync for keypoint movement\n   * @param {object} keypoint - Moved keypoint\n   * @param {object} previousPosition - Previous position\n   * @param {object} currentImage - Current image context\n   * @param {object} currentPlant - Current plant context\n   * @returns {Promise<void>}\n   */\n  async triggerKeypointMoveSync(keypoint, previousPosition, currentImage, currentPlant) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    const operation = {\n      type: this.OPERATION_TYPES.MOVE_KEYPOINT,\n      keypoint,\n      previousPosition,\n      currentImage,\n      currentPlant,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.queueSyncOperation(operation);\n  }\n\n  /**\n   * Trigger sync for keypoint deletion\n   * @param {object} keypoint - Deleted keypoint\n   * @param {object} currentImage - Current image context\n   * @param {object} currentPlant - Current plant context\n   * @returns {Promise<void>}\n   */\n  async triggerKeypointDeleteSync(keypoint, currentImage, currentPlant) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    const operation = {\n      type: this.OPERATION_TYPES.DELETE_KEYPOINT,\n      keypoint,\n      currentImage,\n      currentPlant,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.queueSyncOperation(operation);\n  }\n\n  /**\n   * Trigger sync for direction edit\n   * @param {object} keypoint - Keypoint with updated direction\n   * @param {object} currentImage - Current image context\n   * @param {object} currentPlant - Current plant context\n   * @returns {Promise<void>}\n   */\n  async triggerDirectionEditSync(keypoint, currentImage, currentPlant) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    const operation = {\n      type: this.OPERATION_TYPES.EDIT_DIRECTION,\n      keypoint,\n      currentImage,\n      currentPlant,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.queueSyncOperation(operation);\n  }\n\n  /**\n   * Trigger sync for custom annotation operations\n   * @param {object} syncData - Custom annotation sync data\n   * @returns {Promise<void>}\n   */\n  async triggerCustomAnnotationSync(syncData) {\n    if (!this.isEnabled) {\n      console.log('🔄 Custom annotation sync disabled, skipping');\n      return;\n    }\n\n    console.log('🔄 Processing custom annotation sync:', syncData);\n\n    const operation = {\n      type: syncData.type,\n      syncData,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.queueSyncOperation(operation);\n  }\n\n  /**\n   * Get sync statistics\n   * @returns {object} Sync statistics\n   */\n  getSyncStats() {\n    return {\n      isEnabled: this.isEnabled,\n      isSyncing: this.isSyncing,\n      queueLength: this.syncQueue.length\n    };\n  }\n\n  /**\n   * Clear sync queue\n   */\n  clearSyncQueue() {\n    this.syncQueue = [];\n    console.log('🔄 Sync queue cleared');\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy() {\n    this.clearSyncQueue();\n    this.eventListeners.clear();\n    this.isEnabled = false;\n    this.isSyncing = false;\n    console.log('🔄 RealTimeSyncManager destroyed');\n  }\n}\n\nexport default RealTimeSyncManager;","/**\n * 自定义标注工具栏控制器\n * \n * 功能：\n * - 管理工具栏中的自定义标注控件\n * - 提供快速模式切换功能\n * - 显示当前模式和类型状态\n * - 与CustomAnnotationManager集成\n */\n\nexport class CustomAnnotationToolbarController {\n  constructor(customAnnotationManager, settingsController) {\n    this.customAnnotationManager = customAnnotationManager;\n    this.settingsController = settingsController;\n    \n    this.initializeElements();\n    this.bindEvents();\n    this.updateDisplay();\n    \n    console.log('CustomAnnotationToolbarController initialized');\n  }\n\n  /**\n   * 初始化DOM元素引用\n   */\n  initializeElements() {\n    // Mode status indicators\n    this.customModeIndicator = document.getElementById('custom-mode-indicator');\n    this.customTypeIndicator = document.getElementById('custom-type-indicator');\n    \n    // Controls\n    this.toolbarCustomTypeSelect = document.getElementById('toolbar-custom-type-select');\n    // Removed mode buttons (selection-driven)\n    this.switchCustomModeBtn = null;\n    this.normalModeBtn = null;\n    this.customSettingsBtn = document.getElementById('custom-settings-btn');\n  }\n\n  /**\n   * 绑定事件监听器\n   */\n  bindEvents() {\n    // Custom type selector\n    this.toolbarCustomTypeSelect.addEventListener('change', () => {\n      this.onCustomTypeSelected();\n      const selectedTypeId = this.toolbarCustomTypeSelect.value;\n      if (selectedTypeId) {\n        try {\n          this.customAnnotationManager.setCustomAnnotationMode(selectedTypeId);\n          this.showModeChangeNotification('custom', selectedTypeId);\n        } catch (error) {\n          alert(`Error switching type: ${error.message}`);\n        }\n      } else {\n        this.customAnnotationManager.setNormalMode();\n        this.showModeChangeNotification('normal');\n      }\n    });\n    \n    // Selection-driven: selecting a type immediately activates it\n    \n    // Settings button\n    this.customSettingsBtn.addEventListener('click', () => {\n      this.openSettings();\n    });\n    \n    // Listen to CustomAnnotationManager events\n    this.customAnnotationManager.addEventListener('onModeChange', () => {\n      this.updateDisplay();\n    });\n    \n    // Listen to type creation/deletion events\n    this.customAnnotationManager.addEventListener('onTypeCreate', (data) => {\n      console.log('Toolbar controller received onTypeCreate event:', data);\n      this.refreshCustomTypeSelector();\n    });\n    \n    this.customAnnotationManager.addEventListener('onTypeUpdate', (data) => {\n      console.log('Toolbar controller received onTypeUpdate event:', data);\n      this.refreshCustomTypeSelector();\n    });\n    \n    this.customAnnotationManager.addEventListener('onTypeDelete', (data) => {\n      console.log('Toolbar controller received onTypeDelete event:', data);\n      this.refreshCustomTypeSelector();\n    });\n  }\n\n  /**\n   * 刷新自定义类型选择器\n   */\n  refreshCustomTypeSelector() {\n    console.log('Refreshing custom type selector...');\n    \n    const customTypes = this.customAnnotationManager.getAllCustomTypes();\n    console.log('Retrieved custom types:', customTypes);\n    \n    const currentSelection = this.toolbarCustomTypeSelect.value;\n    \n    // Clear existing options\n    this.toolbarCustomTypeSelect.innerHTML = '<option value=\"\">Select custom type...</option>';\n    \n    // Add custom types\n    customTypes.forEach(type => {\n      console.log('Adding type to selector:', type);\n      const option = document.createElement('option');\n      option.value = type.id;\n      option.textContent = `${type.name} (${type.type})`;\n      option.style.color = type.color;\n      this.toolbarCustomTypeSelect.appendChild(option);\n    });\n    \n    // Restore selection if still valid\n    if (currentSelection && customTypes.find(t => t.id === currentSelection)) {\n      this.toolbarCustomTypeSelect.value = currentSelection;\n    }\n    \n    console.log('Custom type selector updated. Total options:', this.toolbarCustomTypeSelect.options.length);\n    \n    this.updateButtonStates();\n  }\n\n  /**\n   * 处理自定义类型选择\n   */\n  onCustomTypeSelected() {\n    this.updateButtonStates();\n  }\n\n  /**\n   * 切换到自定义模式\n   */\n  switchToCustomMode() {\n    const selectedTypeId = this.toolbarCustomTypeSelect.value;\n    if (!selectedTypeId) {\n      alert('Please select an annotation type first.');\n      return;\n    }\n    \n    try {\n      this.customAnnotationManager.setCustomAnnotationMode(selectedTypeId);\n      this.updateDisplay();\n      this.showModeChangeNotification('custom', selectedTypeId);\n    } catch (error) {\n      alert(`Error switching to custom mode: ${error.message}`);\n    }\n  }\n\n  /**\n   * 切换到正常模式\n   */\n  switchToNormalMode() {\n    this.customAnnotationManager.setNormalMode();\n    this.updateDisplay();\n    this.showModeChangeNotification('normal');\n  }\n\n  /**\n   * 打开设置窗口\n   */\n  openSettings() {\n    this.settingsController.show();\n  }\n\n  /**\n   * 更新显示状态\n   */\n  updateDisplay() {\n    this.updateModeIndicators();\n    this.updateButtonStates();\n  }\n\n  /**\n   * 更新模式指示器\n   */\n  updateModeIndicators() {\n    const currentMode = this.customAnnotationManager.currentMode;\n    const selectedType = this.customAnnotationManager.getCurrentCustomType();\n    \n    // Update mode indicator\n    if (currentMode === 'custom') {\n      this.customModeIndicator.textContent = 'Type';\n      this.customModeIndicator.style.color = '#059669';\n      this.customModeIndicator.style.fontWeight = '600';\n    } else {\n      this.customModeIndicator.textContent = 'Off';\n      this.customModeIndicator.style.color = 'var(--text-primary)';\n      this.customModeIndicator.style.fontWeight = '500';\n    }\n    \n    // Update type indicator\n    if (selectedType) {\n      this.customTypeIndicator.textContent = selectedType.name;\n      this.customTypeIndicator.style.color = selectedType.color;\n      this.customTypeIndicator.style.fontWeight = '600';\n      \n      // Add type badge\n      const typeBadge = selectedType.type === 'point' ? '●' : '▭';\n      this.customTypeIndicator.textContent = `${typeBadge} ${selectedType.name}`;\n    } else {\n      this.customTypeIndicator.textContent = 'None';\n      this.customTypeIndicator.style.color = 'var(--text-secondary)';\n      this.customTypeIndicator.style.fontWeight = '500';\n    }\n  }\n\n  /**\n   * 更新按钮状态\n   */\n  updateButtonStates() {\n    const currentMode = this.customAnnotationManager.currentMode;\n    const selectedTypeId = this.toolbarCustomTypeSelect.value;\n    const hasCustomTypes = this.customAnnotationManager.getAllCustomTypes().length > 0;\n    \n    // Always enable selector; selection applies immediately\n    this.toolbarCustomTypeSelect.disabled = false;\n\n    // Show/hide message based on availability\n    if (!hasCustomTypes) {\n      this.toolbarCustomTypeSelect.style.display = 'none';\n      // buttons removed\n      \n      // Show message to create types\n      this.showNoTypesMessage();\n    } else {\n      this.toolbarCustomTypeSelect.style.display = 'block';\n      this.hideNoTypesMessage();\n    }\n  }\n\n  /**\n   * 显示无类型消息\n   */\n  showNoTypesMessage() {\n    let message = document.getElementById('no-custom-types-message');\n    if (!message) {\n      message = document.createElement('div');\n      message.id = 'no-custom-types-message';\n      message.style.cssText = `\n        padding: 8px;\n        background: var(--bg-secondary);\n        border: 1px dashed var(--border-color);\n        border-radius: 4px;\n        text-align: center;\n        font-size: 0.75rem;\n        color: var(--text-secondary);\n        margin-bottom: 10px;\n      `;\n      message.innerHTML = `\n        <div style=\"margin-bottom: 4px;\">No annotation types created</div>\n        <div style=\"font-size: 0.7rem;\">Click Annotation Type Setting to create types</div>\n      `;\n      \n      this.toolbarCustomTypeSelect.parentNode.appendChild(message);\n    }\n    message.style.display = 'block';\n  }\n\n  /**\n   * 隐藏无类型消息\n   */\n  hideNoTypesMessage() {\n    const message = document.getElementById('no-custom-types-message');\n    if (message) {\n      message.style.display = 'none';\n    }\n  }\n\n  /**\n   * 显示模式切换通知\n   */\n  showModeChangeNotification(mode, typeId = null) {\n    const notification = document.createElement('div');\n    notification.style.cssText = `\n      position: fixed;\n      top: 80px;\n      right: 20px;\n      background: var(--bg-primary);\n      border: 1px solid var(--border-color);\n      border-radius: 6px;\n      padding: 12px 16px;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n      z-index: 1000;\n      font-size: 0.875rem;\n      max-width: 300px;\n      animation: slideInRight 0.3s ease-out;\n    `;\n    \n    if (mode === 'custom') {\n      const customType = this.customAnnotationManager.getCustomType(typeId);\n      const typeIcon = customType.type === 'point' ? '●' : '▭';\n      notification.innerHTML = `\n        <div style=\"display: flex; align-items: center; gap: 8px; margin-bottom: 4px;\">\n          <span style=\"color: #059669; font-size: 1.2em;\">🎯</span>\n          <strong style=\"color: #059669;\">Custom Mode Active</strong>\n        </div>\n        <div style=\"color: var(--text-secondary); font-size: 0.8rem;\">\n          Type: <span style=\"color: ${customType.color}; font-weight: 600;\">${typeIcon} ${customType.name}</span>\n        </div>\n        <div style=\"color: var(--text-secondary); font-size: 0.75rem; margin-top: 4px;\">\n          ${customType.type === 'point' ? 'Click to place points' : 'Drag to draw regions'}\n        </div>\n      `;\n    } else {\n      notification.innerHTML = `\n        <div style=\"display: flex; align-items: center; gap: 8px;\">\n          <span style=\"color: var(--text-primary); font-size: 1.2em;\">⚪</span>\n          <strong style=\"color: var(--text-primary);\">Normal Mode</strong>\n        </div>\n        <div style=\"color: var(--text-secondary); font-size: 0.8rem;\">\n          Standard keypoint annotation\n        </div>\n      `;\n    }\n    \n    // Add animation styles if not already present\n    if (!document.getElementById('notification-animation-style')) {\n      const style = document.createElement('style');\n      style.id = 'notification-animation-style';\n      style.textContent = `\n        @keyframes slideInRight {\n          from {\n            transform: translateX(100%);\n            opacity: 0;\n          }\n          to {\n            transform: translateX(0);\n            opacity: 1;\n          }\n        }\n        @keyframes slideOutRight {\n          from {\n            transform: translateX(0);\n            opacity: 1;\n          }\n          to {\n            transform: translateX(100%);\n            opacity: 0;\n          }\n        }\n      `;\n      document.head.appendChild(style);\n    }\n    \n    document.body.appendChild(notification);\n    \n    // Auto-remove after 3 seconds\n    setTimeout(() => {\n      notification.style.animation = 'slideOutRight 0.3s ease-in';\n      setTimeout(() => {\n        if (notification.parentElement) {\n          notification.remove();\n        }\n      }, 300);\n    }, 3000);\n  }\n\n  /**\n   * 初始化工具栏（在应用启动时调用）\n   */\n  initialize() {\n    console.log('Initializing custom annotation toolbar controller...');\n    this.refreshCustomTypeSelector();\n    this.updateDisplay();\n  }\n\n  /**\n   * 强制刷新工具栏状态（用于调试或手动同步）\n   */\n  forceRefresh() {\n    console.log('Force refreshing toolbar controller...');\n    this.refreshCustomTypeSelector();\n    this.updateDisplay();\n  }\n\n  /**\n   * 获取当前选中的自定义类型ID\n   */\n  getSelectedCustomTypeId() {\n    return this.toolbarCustomTypeSelect.value;\n  }\n\n  /**\n   * 设置选中的自定义类型\n   */\n  setSelectedCustomType(typeId) {\n    this.toolbarCustomTypeSelect.value = typeId;\n    this.updateButtonStates();\n  }\n\n  /**\n   * 检查是否有可用的自定义类型\n   */\n  hasCustomTypes() {\n    return this.customAnnotationManager.getAllCustomTypes().length > 0;\n  }\n\n  /**\n   * 获取工具栏状态摘要\n   */\n  getStatusSummary() {\n    const currentMode = this.customAnnotationManager.currentMode;\n    const selectedType = this.customAnnotationManager.getCurrentCustomType();\n    const totalTypes = this.customAnnotationManager.getAllCustomTypes().length;\n    \n    return {\n      mode: currentMode,\n      selectedType: selectedType ? {\n        id: selectedType.id,\n        name: selectedType.name,\n        type: selectedType.type,\n        color: selectedType.color\n      } : null,\n      totalCustomTypes: totalTypes,\n      hasCustomTypes: totalTypes > 0\n    };\n  }\n}","/**\n * 自定义标注设置窗口控制器\n * \n * 功能：\n * - 管理自定义标注类型的创建、编辑、删除\n * - 提供模式切换界面\n * - 处理导入导出功能\n * - 与CustomAnnotationManager集成\n */\n\nexport class CustomAnnotationSettingsController {\n  constructor(customAnnotationManager) {\n    this.customAnnotationManager = customAnnotationManager;\n    this.modal = null;\n    this.currentEditingTypeId = null;\n    this.currentTab = 'manage-types';\n    \n    this.initializeElements();\n    this.bindEvents();\n    \n    console.log('CustomAnnotationSettingsController initialized');\n  }\n\n  /**\n   * 初始化DOM元素引用\n   */\n  initializeElements() {\n    this.modal = document.getElementById('custom-annotation-settings-modal');\n    this.closeBtn = document.getElementById('custom-annotation-settings-close');\n    \n    // Tab elements\n    this.tabButtons = document.querySelectorAll('.tab-button');\n    this.tabContents = document.querySelectorAll('.tab-content');\n    \n    // Manage Types tab elements\n    this.customTypesList = document.getElementById('custom-types-list');\n    this.noCustomTypesMessage = document.getElementById('no-custom-types');\n    this.addTypeBtn = document.getElementById('add-custom-type-btn');\n    this.typeFormSection = document.getElementById('type-form-section');\n    this.typeForm = document.getElementById('custom-type-form');\n    this.formTitle = document.getElementById('form-title');\n    this.formSubmitText = document.getElementById('form-submit-text');\n    this.cancelFormBtn = document.getElementById('cancel-form-btn');\n    \n    // Form inputs\n    this.typeNameInput = document.getElementById('type-name');\n    this.typeIdInput = document.getElementById('type-id');\n    this.typeTypeSelect = document.getElementById('type-type');\n    this.typeColorInput = document.getElementById('type-color');\n    this.typeColorTextInput = document.getElementById('type-color-text');\n    this.typeDescriptionInput = document.getElementById('type-description');\n    this.typeCategoryInput = document.getElementById('type-category');\n    // Default angle for keypoint types\n    this.typeDefaultAngleGroup = document.getElementById('type-default-angle-group');\n    this.typeDefaultAngleInput = document.getElementById('type-default-angle');\n    this.typeIsDirectionalInput = document.getElementById('type-is-directional');\n    \n    // Current Mode tab elements\n    this.currentModeValue = document.getElementById('current-mode-value');\n    this.currentTypeValue = document.getElementById('current-type-value');\n    this.switchToNormalBtn = document.getElementById('switch-to-normal-btn');\n    this.selectCustomTypeSelect = document.getElementById('select-custom-type');\n    this.switchToCustomBtn = document.getElementById('switch-to-custom-btn');\n    \n    // Export/Import tab elements\n    this.exportTypesCount = document.getElementById('export-types-count');\n    this.exportAnnotationsCount = document.getElementById('export-annotations-count');\n    this.exportCustomDataBtn = document.getElementById('export-custom-data-btn');\n    this.selectImportFileBtn = document.getElementById('select-import-file-btn');\n    this.importFileInput = document.getElementById('import-file-input');\n    this.importFileInfo = document.getElementById('import-file-info');\n    this.importFileName = document.getElementById('import-file-name');\n    this.importExecuteBtn = document.getElementById('import-execute-btn');\n    this.importResults = document.getElementById('import-results');\n    this.importResultsContent = document.getElementById('import-results-content');\n  }\n\n  /**\n   * 绑定事件监听器\n   */\n  bindEvents() {\n    // Modal close\n    this.closeBtn.addEventListener('click', () => this.hide());\n    this.modal.addEventListener('click', (e) => {\n      if (e.target === this.modal) this.hide();\n    });\n    \n    // Tab switching\n    this.tabButtons.forEach(button => {\n      button.addEventListener('click', () => {\n        const tabName = button.dataset.tab;\n        this.switchTab(tabName);\n      });\n    });\n    \n    // Manage Types tab events\n    this.addTypeBtn.addEventListener('click', () => this.showAddTypeForm());\n    this.cancelFormBtn.addEventListener('click', () => this.hideTypeForm());\n    this.typeForm.addEventListener('submit', (e) => this.handleFormSubmit(e));\n    \n    // Color input synchronization\n    this.typeColorInput.addEventListener('input', () => {\n      this.typeColorTextInput.value = this.typeColorInput.value;\n    });\n    this.typeColorTextInput.addEventListener('input', () => {\n      if (/^#[0-9A-Fa-f]{6}$/.test(this.typeColorTextInput.value)) {\n        this.typeColorInput.value = this.typeColorTextInput.value;\n      }\n    });\n    \n    // Type name to ID auto-generation\n    this.typeNameInput.addEventListener('input', () => {\n      if (!this.currentEditingTypeId) {\n        const id = this.generateIdFromName(this.typeNameInput.value);\n        this.typeIdInput.value = id;\n      }\n    });\n\n    // Show/hide default angle field when type changes\n    this.typeTypeSelect.addEventListener('change', () => this.updateAngleVisibility());\n    \n    // Current Type events: selection-driven, no buttons\n    if (this.switchToNormalBtn) {\n      this.switchToNormalBtn.style.display = 'none';\n    }\n    if (this.switchToCustomBtn) {\n      this.switchToCustomBtn.style.display = 'none';\n    }\n    this.selectCustomTypeSelect.addEventListener('change', () => {\n      const typeId = this.selectCustomTypeSelect.value;\n      if (typeId) {\n        this.customAnnotationManager.setCustomAnnotationMode(typeId);\n      } else {\n        this.customAnnotationManager.setNormalMode();\n      }\n      this.updateModeDisplay();\n    });\n    \n    // Export/Import tab events\n    this.exportCustomDataBtn.addEventListener('click', () => this.exportCustomData());\n    this.selectImportFileBtn.addEventListener('click', () => this.importFileInput.click());\n    this.importFileInput.addEventListener('change', () => this.handleFileSelection());\n    this.importExecuteBtn.addEventListener('click', () => this.executeImport());\n    \n    // Listen to CustomAnnotationManager events\n    this.customAnnotationManager.addEventListener('onModeChange', (data) => {\n      this.updateModeDisplay();\n    });\n  }\n\n  /**\n   * 显示设置窗口\n   */\n  show() {\n    this.refreshAllData();\n    this.modal.style.display = 'flex';\n  }\n\n  /**\n   * 隐藏设置窗口\n   */\n  hide() {\n    this.modal.style.display = 'none';\n    this.hideTypeForm();\n  }\n\n  /**\n   * 切换选项卡\n   */\n  switchTab(tabName) {\n    this.currentTab = tabName;\n    \n    // Update tab buttons\n    this.tabButtons.forEach(button => {\n      if (button.dataset.tab === tabName) {\n        button.classList.add('active');\n      } else {\n        button.classList.remove('active');\n      }\n    });\n    \n    // Update tab contents\n    this.tabContents.forEach(content => {\n      if (content.id === `${tabName}-tab`) {\n        content.classList.add('active');\n      } else {\n        content.classList.remove('active');\n      }\n    });\n    \n    // Refresh data for the active tab\n    this.refreshTabData(tabName);\n  }\n\n  /**\n   * 刷新指定选项卡的数据\n   */\n  refreshTabData(tabName) {\n    switch (tabName) {\n      case 'manage-types':\n        this.refreshCustomTypesList();\n        break;\n      case 'current-mode':\n        this.updateModeDisplay();\n        this.refreshCustomTypeSelector();\n        break;\n      case 'export-import':\n        this.updateExportStats();\n        break;\n    }\n  }\n\n  /**\n   * 刷新所有数据\n   */\n  refreshAllData() {\n    this.refreshCustomTypesList();\n    this.updateModeDisplay();\n    this.refreshCustomTypeSelector();\n    this.updateExportStats();\n  }\n\n  /**\n   * 刷新自定义类型列表\n   */\n  refreshCustomTypesList() {\n    const customTypes = this.customAnnotationManager.getAllCustomTypes();\n    \n    if (customTypes.length === 0) {\n      this.customTypesList.innerHTML = `\n        <div id=\"no-custom-types\" class=\"placeholder-message\" style=\"text-align: center; color: #6b7280; padding: 40px;\">\n          <div style=\"font-size: 48px; margin-bottom: 16px;\">🎯</div>\n          <h4 style=\"margin: 0 0 8px 0;\">No Custom Types Created</h4>\n          <p style=\"margin: 0;\">Create custom annotation types for special keypoints and regions</p>\n        </div>\n      `;\n    } else {\n      const typesList = customTypes.map(type => this.createTypeItemHTML(type)).join('');\n      this.customTypesList.innerHTML = typesList;\n      \n      // Bind action buttons\n      this.bindTypeActionButtons();\n    }\n  }\n\n  /**\n   * 创建类型项HTML\n   */\n  createTypeItemHTML(type) {\n    const typeLabel = type.type === 'point' ? 'keypoint' : (type.type === 'region' ? 'rectangle' : type.type);\n    return `\n      <div class=\"custom-type-item\" data-type-id=\"${type.id}\">\n        <div class=\"custom-type-info\">\n          <div class=\"type-color-preview\" style=\"background-color: ${type.color};\"></div>\n          <div class=\"type-details\">\n            <div class=\"type-name\">${type.name}</div>\n            <div class=\"type-meta\">\n              <span class=\"type-badge ${type.type}\">${typeLabel}</span>\n              <span>ID: ${type.id}</span>\n              ${type.metadata?.category ? `<span>Category: ${type.metadata.category}</span>` : ''}\n            </div>\n          </div>\n        </div>\n        <div class=\"type-actions\">\n          <button class=\"type-action-btn edit\" data-action=\"edit\" data-type-id=\"${type.id}\">Edit</button>\n          <button class=\"type-action-btn delete\" data-action=\"delete\" data-type-id=\"${type.id}\">Delete</button>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * 绑定类型操作按钮事件\n   */\n  bindTypeActionButtons() {\n    const actionButtons = this.customTypesList.querySelectorAll('.type-action-btn');\n    actionButtons.forEach(button => {\n      button.addEventListener('click', () => {\n        const action = button.dataset.action;\n        const typeId = button.dataset.typeId;\n        \n        if (action === 'edit') {\n          this.editCustomType(typeId);\n        } else if (action === 'delete') {\n          this.deleteCustomType(typeId);\n        }\n      });\n    });\n  }\n\n  /**\n   * 显示添加类型表单\n   */\n  showAddTypeForm() {\n    this.currentEditingTypeId = null;\n    this.formTitle.textContent = 'Add New Type';\n    this.formSubmitText.textContent = 'Create Type';\n    this.typeForm.reset();\n    this.typeColorInput.value = '#ff6b35';\n    this.typeColorTextInput.value = '#ff6b35';\n    if (this.typeDefaultAngleInput) {\n      this.typeDefaultAngleInput.value = '';\n    }\n    this.typeFormSection.style.display = 'block';\n    this.updateAngleVisibility();\n  }\n\n  /**\n   * 编辑自定义类型\n   */\n  editCustomType(typeId) {\n    const type = this.customAnnotationManager.getCustomType(typeId);\n    if (!type) return;\n    \n    this.currentEditingTypeId = typeId;\n    this.formTitle.textContent = 'Edit Type';\n    this.formSubmitText.textContent = 'Update Type';\n    \n    // Fill form with existing data\n    this.typeNameInput.value = type.name;\n    this.typeIdInput.value = type.id;\n    this.typeTypeSelect.value = type.type;\n    this.typeColorInput.value = type.color;\n    this.typeColorTextInput.value = type.color;\n    this.typeDescriptionInput.value = type.description || '';\n    this.typeCategoryInput.value = type.metadata?.category || '';\n    if (this.typeDefaultAngleInput) {\n      const angle = type.metadata?.defaultAngle;\n      this.typeDefaultAngleInput.value = (angle ?? '').toString();\n    }\n    if (this.typeIsDirectionalInput) {\n      this.typeIsDirectionalInput.checked = !!type.metadata?.isDirectional;\n    }\n    \n    // Disable ID field for editing\n    this.typeIdInput.disabled = true;\n    \n    this.typeFormSection.style.display = 'block';\n    this.updateAngleVisibility();\n  }\n\n  /**\n   * 删除自定义类型\n   */\n  deleteCustomType(typeId) {\n    const type = this.customAnnotationManager.getCustomType(typeId);\n    if (!type) return;\n    \n    if (confirm(`Are you sure you want to delete the custom type \"${type.name}\"? This will also delete all annotations of this type.`)) {\n      this.customAnnotationManager.deleteCustomType(typeId);\n      this.refreshCustomTypesList();\n      this.refreshCustomTypeSelector();\n    }\n  }\n\n  /**\n   * 隐藏类型表单\n   */\n  hideTypeForm() {\n    this.typeFormSection.style.display = 'none';\n    this.currentEditingTypeId = null;\n    this.typeIdInput.disabled = false;\n  }\n\n  /**\n   * 处理表单提交\n   */\n  handleFormSubmit(e) {\n    e.preventDefault();\n    \n    const formData = new FormData(this.typeForm);\n    const typeData = {\n      id: formData.get('id'),\n      name: formData.get('name'),\n      type: formData.get('type'),\n      color: formData.get('color'),\n      description: formData.get('description'),\n      metadata: {\n        category: formData.get('category')\n      }\n    };\n\n    // Directional toggle\n    if (this.typeIsDirectionalInput && this.typeIsDirectionalInput.checked) {\n      typeData.metadata.isDirectional = true;\n    } else {\n      typeData.metadata.isDirectional = false;\n    }\n\n    // Attach default angle for keypoint types\n    if (typeData.type === 'point') {\n      const rawAngle = (this.typeDefaultAngleInput?.value || '').trim();\n      if (rawAngle !== '') {\n        const parsed = parseFloat(rawAngle);\n        if (!Number.isNaN(parsed)) {\n          typeData.metadata.defaultAngle = parsed;\n        }\n      }\n    }\n    \n    try {\n      if (this.currentEditingTypeId) {\n        // Update existing type\n        this.customAnnotationManager.updateCustomType(this.currentEditingTypeId, typeData);\n      } else {\n        // Create new type\n        this.customAnnotationManager.createCustomType(typeData);\n      }\n      \n      this.hideTypeForm();\n      this.refreshCustomTypesList();\n      this.refreshCustomTypeSelector();\n      \n    } catch (error) {\n      alert(`Error: ${error.message}`);\n    }\n  }\n\n  /**\n   * 从名称生成ID\n   */\n  generateIdFromName(name) {\n    return name\n      .toLowerCase()\n      .replace(/[^a-z0-9\\u4e00-\\u9fff]/g, '-')\n      .replace(/-+/g, '-')\n      .replace(/^-|-$/g, '')\n      .substring(0, 50);\n  }\n\n  /**\n   * 更新模式显示\n   */\n  updateModeDisplay() {\n    const currentMode = this.customAnnotationManager.currentMode;\n    const selectedType = this.customAnnotationManager.getCurrentCustomType();\n    \n    this.currentModeValue.textContent = currentMode === 'custom' ? 'Type' : 'Off';\n    this.currentTypeValue.textContent = selectedType ? selectedType.name : 'None';\n    \n    // Update button states\n    if (this.switchToNormalBtn) {\n      this.switchToNormalBtn.disabled = currentMode === 'normal';\n    }\n  }\n\n  /**\n   * 刷新自定义类型选择器\n   */\n  refreshCustomTypeSelector() {\n    const customTypes = this.customAnnotationManager.getAllCustomTypes();\n    \n    this.selectCustomTypeSelect.innerHTML = '<option value=\"\">Choose a type...</option>';\n    \n    customTypes.forEach(type => {\n      // 将内置类型放到列表顶部\n      const option = document.createElement('option');\n      option.value = type.id;\n      const typeLabel = type.type === 'point' ? 'keypoint' : (type.type === 'region' ? 'rectangle' : type.type);\n      const prefix = type.metadata?.builtin ? '★ ' : '';\n      option.textContent = `${prefix}${type.name} (${typeLabel})`;\n      this.selectCustomTypeSelect.appendChild(option);\n    });\n\n    // 如果列表存在内置类型，将其移到第一项之后\n    const options = Array.from(this.selectCustomTypeSelect.options);\n    const builtinIdx = options.findIndex(opt => opt.value === 'builtin-regular-keypoint');\n    if (builtinIdx > 1) {\n      const opt = options[builtinIdx];\n      this.selectCustomTypeSelect.remove(builtinIdx);\n      this.selectCustomTypeSelect.add(opt, 1);\n    }\n    \n    if (this.switchToCustomBtn) {\n      this.switchToCustomBtn.disabled = true;\n    }\n  }\n\n  /**\n   * 切换到正常模式\n   */\n  switchToNormalMode() {\n    this.customAnnotationManager.setNormalMode();\n    this.updateModeDisplay();\n  }\n\n  /**\n   * 切换到自定义模式\n   */\n  switchToCustomMode() {\n    const selectedTypeId = this.selectCustomTypeSelect.value;\n    if (!selectedTypeId) return;\n    \n    try {\n      this.customAnnotationManager.setCustomAnnotationMode(selectedTypeId);\n      this.updateModeDisplay();\n    } catch (error) {\n      alert(`Error: ${error.message}`);\n    }\n  }\n\n  /**\n   * 根据选择的类型显示/隐藏默认角度字段\n   */\n  updateAngleVisibility() {\n    if (!this.typeDefaultAngleGroup) return;\n    const isPoint = this.typeTypeSelect.value === 'point';\n    this.typeDefaultAngleGroup.style.display = isPoint ? 'flex' : 'none';\n  }\n\n  /**\n   * 更新导出统计\n   */\n  updateExportStats() {\n    const customTypes = this.customAnnotationManager.getAllCustomTypes();\n    const stats = this.customAnnotationManager.getStats();\n    \n    this.exportTypesCount.textContent = customTypes.length;\n    this.exportAnnotationsCount.textContent = stats.totalAnnotations;\n    \n    // 🔧 NEW: 添加当前图像的标注统计\n    const appState = window.PlantAnnotationTool?.appState;\n    const currentImageId = appState?.currentImage?.id;\n    \n    if (currentImageId) {\n      const imageStats = this.customAnnotationManager.getAnnotationStats(currentImageId);\n      this.updateCurrentImageStats(imageStats);\n    }\n  }\n\n  /**\n   * 更新当前图像的标注统计显示\n   * @param {Object} imageStats - 图像统计信息\n   */\n  updateCurrentImageStats(imageStats) {\n    // 检查是否存在当前图像统计显示区域\n    let currentImageStatsDiv = document.getElementById('current-image-stats');\n    if (!currentImageStatsDiv) {\n      // 创建统计显示区域\n      currentImageStatsDiv = document.createElement('div');\n      currentImageStatsDiv.id = 'current-image-stats';\n      currentImageStatsDiv.style.cssText = `\n        margin-top: 16px;\n        padding: 12px;\n        background: #f8f9fa;\n        border-radius: 6px;\n        border: 1px solid #e5e7eb;\n      `;\n      \n      // 将其添加到导出统计后面\n      const exportSection = document.querySelector('.export-stats');\n      if (exportSection) {\n        exportSection.appendChild(currentImageStatsDiv);\n      }\n    }\n    \n    // 更新统计内容\n    let statsHtml = `\n      <div style=\"font-weight: 600; margin-bottom: 8px; color: #374151;\">\n        📊 Current Image Statistics\n      </div>\n      <div style=\"margin-bottom: 8px;\">\n        Total Annotations: <span style=\"font-weight: 600;\">${imageStats.total}</span>\n      </div>\n    `;\n    \n    if (imageStats.total > 0) {\n      statsHtml += `\n        <div style=\"margin-bottom: 8px;\">\n          Order Range: #${imageStats.orderRange.min} - #${imageStats.orderRange.max}\n        </div>\n      `;\n      \n      if (imageStats.gaps.length > 0) {\n        statsHtml += `\n          <div style=\"margin-bottom: 8px; color: #f59e0b;\">\n            ⚠️ Missing Numbers: ${imageStats.gaps.join(', ')}\n          </div>\n        `;\n      }\n      \n      // 按类型统计\n      const typeStats = Object.entries(imageStats.byType).map(([typeId, info]) => {\n        return `\n          <div style=\"display: flex; align-items: center; gap: 8px; margin-bottom: 4px;\">\n            <div style=\"width: 12px; height: 12px; background: ${info.typeColor}; border-radius: 50%;\"></div>\n            <span>${info.typeName}: ${info.count}</span>\n          </div>\n        `;\n      }).join('');\n      \n      if (typeStats) {\n        statsHtml += `\n          <div style=\"margin-top: 12px;\">\n            <div style=\"font-weight: 600; margin-bottom: 6px; color: #374151;\">By Type:</div>\n            ${typeStats}\n          </div>\n        `;\n      }\n    }\n    \n    currentImageStatsDiv.innerHTML = statsHtml;\n  }\n\n  /**\n   * 导出自定义数据\n   */\n  exportCustomData() {\n    const exportData = this.customAnnotationManager.exportData();\n    const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n      type: 'application/json'\n    });\n    \n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `custom_annotations_${new Date().toISOString().split('T')[0]}.json`;\n    \n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    \n    URL.revokeObjectURL(url);\n    \n    console.log('Custom annotation data exported');\n  }\n\n  /**\n   * 处理文件选择\n   */\n  handleFileSelection() {\n    const file = this.importFileInput.files[0];\n    if (file) {\n      this.importFileName.textContent = file.name;\n      this.importFileInfo.style.display = 'flex';\n      this.importResults.style.display = 'none';\n    } else {\n      this.importFileInfo.style.display = 'none';\n    }\n  }\n\n  /**\n   * 执行导入\n   */\n  async executeImport() {\n    const file = this.importFileInput.files[0];\n    if (!file) return;\n    \n    try {\n      const text = await file.text();\n      const importData = JSON.parse(text);\n      \n      const result = this.customAnnotationManager.importData(importData);\n      \n      if (result.success) {\n        this.importResultsContent.innerHTML = `\n          <div style=\"color: #059669;\">\n            ✅ Import successful!<br>\n            Imported ${importData.customTypes?.length || 0} custom types and ${importData.customAnnotations?.length || 0} annotations.\n          </div>\n        `;\n        \n        // Refresh all data\n        this.refreshAllData();\n      } else {\n        this.importResultsContent.innerHTML = `\n          <div style=\"color: #dc2626;\">\n            ❌ Import failed: ${result.error}\n          </div>\n        `;\n      }\n      \n      this.importResults.style.display = 'block';\n      \n    } catch (error) {\n      this.importResultsContent.innerHTML = `\n        <div style=\"color: #dc2626;\">\n          ❌ Error reading file: ${error.message}\n        </div>\n      `;\n      this.importResults.style.display = 'block';\n    }\n  }\n}","/**\n * 植物图像关键点标注工具 - 主应用入口\n * \n * 功能：\n * - 应用初始化和加载\n * - File System Access API 支持检测\n * - 基础UI交互绑定\n * - 浏览器兼容性检查\n */\n\nimport { FileSystemManager } from './core/FileSystemManager.js';\nimport { PlantDataManager } from './core/PlantDataManager.js';\nimport { AnnotationTool } from './core/AnnotationTool.js';\nimport { BranchPointPreviewManager } from './core/BranchPointPreviewManager.js';\nimport { NoteManager } from './core/NoteManager.js';\nimport { NoteUI } from './core/NoteUI.js';\nimport { AnnotationManager } from './core/AnnotationManager.js';\nimport { BulkLoadingPerformanceMonitor } from './utils/BulkLoadingPerformanceMonitor.js';\nimport RealTimeSyncManager from './core/RealTimeSyncManager.js';\nimport { CustomAnnotationToolbarController } from './core/CustomAnnotationToolbarController.js';\nimport { CustomAnnotationSettingsController } from './core/CustomAnnotationSettingsController.js';\n\n// 🔧 FIX: Global error handling to prevent uncaught promise errors\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('🚨 Unhandled Promise Rejection:', event.reason);\n  \n  // Check if it's the common Chrome extension message channel error\n  if (event.reason && typeof event.reason === 'object' && \n      event.reason.message && event.reason.message.includes('message channel closed')) {\n    console.warn('Chrome extension message channel error detected - this is usually harmless');\n    event.preventDefault(); // Prevent the error from being logged to console\n    return;\n  }\n  \n  // Log other unhandled rejections but don't prevent them\n  console.error('Unhandled promise rejection details:', {\n    reason: event.reason,\n    promise: event.promise,\n    stack: event.reason?.stack\n  });\n});\n\n// 🔧 FIX: Global error handler for uncaught exceptions\nwindow.addEventListener('error', (event) => {\n  console.error('🚨 Uncaught Error:', event.error);\n  \n  // Check for async listener errors specifically\n  if (event.error && event.error.message && \n      event.error.message.includes('asynchronous response')) {\n    console.warn('Async response listener error detected - likely Chrome extension related');\n    return;\n  }\n  \n  console.error('Global error details:', {\n    message: event.message,\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno,\n    error: event.error\n  });\n});\n\n// DOM元素引用\nlet app = null;\nlet loadingScreen = null;\nlet mainApp = null;\nlet errorModal = null;\n\n// 管理器实例\nlet plantDataManager = null;\nlet annotationTool = null;\nlet branchPointPreviewManager = null;\nlet noteManager = null;\nlet noteUI = null;\nlet annotationManager = null;\nlet realTimeSyncManager = null;\nlet performanceMonitor = null;\nlet currentDataset = null;\nlet customAnnotationToolbarController = null;\nlet customAnnotationSettingsController = null;\n\n// 应用状态\nconst appState = {\n  isInitialized: false,\n  hasBackendAccess: false,\n  currentDatasetPath: null,\n  plants: [],\n  currentPlant: null,\n  currentImage: null,\n  annotations: new Map(),\n  // 🔧 NEW: Navigation state management to prevent race conditions\n  navigation: {\n    isNavigating: false,\n    lastNavigationTime: 0,\n    throttleDelay: 150 // Minimum time between navigation attempts (ms)\n  }\n};\n\n/**\n * 初始化自定义标注控制器\n */\nfunction initializeCustomAnnotationControllers() {\n  // 防止重复初始化\n  if (customAnnotationSettingsController || customAnnotationToolbarController) {\n    console.log('Custom annotation controllers already initialized, skipping...');\n    return;\n  }\n  \n  if (!annotationTool || !annotationTool.customAnnotationManager) {\n    console.warn('CustomAnnotationManager not ready, retrying...');\n    setTimeout(() => {\n      initializeCustomAnnotationControllers();\n    }, 200);\n    return;\n  }\n  \n  try {\n    // 创建设置控制器 - 传入正确的参数\n    customAnnotationSettingsController = new CustomAnnotationSettingsController(annotationTool.customAnnotationManager);\n    \n    // 创建工具栏控制器，传入正确的参数\n    customAnnotationToolbarController = new CustomAnnotationToolbarController(\n      annotationTool.customAnnotationManager,\n      customAnnotationSettingsController\n    );\n    \n    // 初始化工具栏控制器\n    customAnnotationToolbarController.initialize();\n    \n    // 全局引用\n    window.PlantAnnotationTool.customAnnotationToolbarController = customAnnotationToolbarController;\n    window.PlantAnnotationTool.customAnnotationSettingsController = customAnnotationSettingsController;\n    \n    console.log('自定义标注控制器初始化成功');\n  } catch (error) {\n    console.error('自定义标注控制器初始化失败:', error);\n  }\n}\n\n// 设置回调函数\nwindow.onCustomAnnotationSystemReady = initializeCustomAnnotationControllers;\n\n/**\n * 应用初始化\n */\nasync function initializeApp() {\n  console.log('初始化植物图像关键点标注工具...');\n  \n  try {\n    // 全屏加载进度管理\n    updateFullscreenLoading(10, 'Initializing managers...', 'Setting up core components');\n    \n    // 获取DOM元素引用\n    app = document.getElementById('app');\n    loadingScreen = document.getElementById('loading-screen');\n    mainApp = document.getElementById('main-app');\n    errorModal = document.getElementById('error-modal');\n    \n    updateFullscreenLoading(20, 'Creating data managers...', 'Initializing plant data manager');\n    \n    // 初始化管理器\n    plantDataManager = new PlantDataManager();\n\n    // 注意：不在这里初始化annotationStorage，等到选择数据集时再初始化\n    \n    updateFullscreenLoading(30, 'Setting up window objects...', 'Making managers globally available');\n    \n    // 立即设置window对象，确保其他模块可以访问\n    window.PlantAnnotationTool = {\n      appState,\n      plantDataManager,\n      annotationTool: null, // 稍后设置\n      showError,\n      hideError,\n      updateProgressInfo\n    };\n    \n    updateFullscreenLoading(40, 'Initializing annotation tool...', 'Setting up the annotation interface');\n    \n    // 初始化标注工具\n    try {\n      console.log('[调试] 在initializeApp开始时初始化AnnotationTool');\n      annotationTool = new AnnotationTool('annotation-canvas');\n      window.PlantAnnotationTool.annotationTool = annotationTool;\n    } catch (error) {\n      console.warn('AnnotationTool初始化延迟:', error.message);\n      // Canvas可能还没有准备好，稍后再试\n    }\n    \n    updateFullscreenLoading(50, 'Setting up preview manager...', 'Initializing branch point preview functionality');\n    \n    // 初始化分支点预览管理器\n    try {\n      branchPointPreviewManager = new BranchPointPreviewManager();\n      branchPointPreviewManager.setPlantDataManager(plantDataManager);\n      window.PlantAnnotationTool.branchPointPreviewManager = branchPointPreviewManager;\n    } catch (error) {\n      console.warn('BranchPointPreviewManager初始化延迟:', error.message);\n    }\n    \n    updateFullscreenLoading(52, 'Setting up custom annotation system...', 'Initializing custom annotation controllers');\n    \n    // 初始化自定义标注系统 - 需要等待异步加载完成\n    try {\n      // 等待annotation tool的自定义标注系统异步加载完成\n      setTimeout(() => {\n        initializeCustomAnnotationControllers();\n      }, 500); // 给动态导入一些时间来完成\n      \n      console.log('自定义标注系统初始化已启动');\n    } catch (error) {\n      console.warn('自定义标注系统初始化延迟:', error.message);\n    }\n    \n    updateFullscreenLoading(55, 'Setting up note system...', 'Initializing note management functionality');\n    \n    // 初始化笔记系统\n    try {\n      noteManager = new NoteManager(plantDataManager.fileSystemManager);\n      noteUI = new NoteUI(noteManager);\n      \n      // 启动自动清理\n      noteManager.startAutoCleanup();\n      \n      window.PlantAnnotationTool.noteManager = noteManager;\n      window.PlantAnnotationTool.noteUI = noteUI;\n      console.log('笔记系统初始化成功');\n    } catch (error) {\n      console.warn('NoteManager初始化延迟:', error.message);\n    }\n    \n    updateFullscreenLoading(60, 'Setting up annotation manager...', 'Initializing bulk annotation loading system');\n    \n    // 初始化标注管理器\n    try {\n      annotationManager = new AnnotationManager(plantDataManager.fileSystemManager);\n      \n      window.PlantAnnotationTool.annotationManager = annotationManager;\n      console.log('标注管理器初始化成功');\n    } catch (error) {\n      console.warn('AnnotationManager初始化延迟:', error.message);\n    }\n    \n    updateFullscreenLoading(63, 'Setting up real-time sync...', 'Initializing real-time synchronization manager');\n    \n    // 初始化实时同步管理器\n    try {\n      realTimeSyncManager = new RealTimeSyncManager(plantDataManager, plantDataManager.annotationStorage);\n      \n      window.PlantAnnotationTool.realTimeSyncManager = realTimeSyncManager;\n      console.log('🔄 实时同步管理器初始化成功');\n    } catch (error) {\n      console.warn('🔄 RealTimeSyncManager初始化延迟:', error.message);\n    }\n    \n    updateFullscreenLoading(65, 'Setting up performance monitoring...', 'Initializing bulk loading performance tracking');\n    \n    // 初始化性能监控器\n    try {\n      performanceMonitor = new BulkLoadingPerformanceMonitor();\n      \n      window.PlantAnnotationTool.performanceMonitor = performanceMonitor;\n      console.log('性能监控器初始化成功');\n    } catch (error) {\n      console.warn('性能监控器初始化延迟:', error.message);\n    }\n    \n    updateFullscreenLoading(70, 'Checking compatibility...', 'Verifying browser support and backend connection');\n    \n    // 检查浏览器兼容性\n    await checkBrowserCompatibility();\n    \n    updateFullscreenLoading(70, 'Setting up interface...', 'Binding event listeners and UI components');\n    \n    // 绑定基础事件监听器\n    bindEventListeners();\n    \n    updateFullscreenLoading(80, 'Finalizing setup...', 'Completing initialization process');\n    \n    // 模拟加载过程\n    await simulateLoading();\n    \n    // 显示主应用界面\n    showMainApp();\n    \n    // 确保标注工具已初始化（避免重复初始化）\n    if (!annotationTool) {\n      try {\n        console.log('[调试] 在initializeApp中初始化AnnotationTool');\n        annotationTool = new AnnotationTool('annotation-canvas');\n        window.PlantAnnotationTool.annotationTool = annotationTool;\n      } catch (error) {\n        console.error('无法初始化AnnotationTool:', error);\n      }\n    } else {\n      console.log('[调试] AnnotationTool已存在，跳过初始化');\n    }\n    \n    updateFullscreenLoading(90, 'Connecting to dataset...', 'Automatically connecting to plant dataset');\n    \n    // 自动连接数据集\n    setTimeout(async () => {\n      try {\n        await autoConnectDataset();\n      } catch (error) {\n        console.error('自动连接数据集失败:', error);\n        hideFullscreenLoading();\n        showError('自动连接数据集失败', error.message);\n      }\n    }, 500); // 给用户看到最后的加载进度\n    \n    appState.isInitialized = true;\n    console.log('应用初始化完成');\n    \n  } catch (error) {\n    console.error('应用初始化失败:', error);\n    hideFullscreenLoading();\n    showError('应用初始化失败', error.message);\n  }\n}\n\n/**\n * 检查浏览器兼容性\n */\nasync function checkBrowserCompatibility() {\n  console.log('检查浏览器兼容性...');\n  \n  // 检查后端服务连接\n  try {\n    const isConnected = await plantDataManager.fileSystemManager.checkConnection();\n    if (isConnected) {\n      await plantDataManager.fileSystemManager.initialize();\n      appState.hasBackendAccess = true;\n      console.log('✅ 后端服务连接成功');\n    } else {\n      throw new Error('后端服务不可用');\n    }\n  } catch (error) {\n    appState.hasBackendAccess = false;\n    const errorMessage = error.message.includes('fetch') || error.message.includes('ERR_CONNECTION_REFUSED') ?\n      '后端服务未启动，请运行 ./start-backend.sh 启动服务器' :\n      error.message;\n    console.warn('❌ 后端服务连接失败:', errorMessage);\n  }\n  \n  // 检查其他必要的API\n  const requiredAPIs = [\n    { name: 'Canvas API', check: () => !!document.createElement('canvas').getContext },\n    { name: 'IndexedDB', check: () => !!window.indexedDB },\n    { name: 'Web Workers', check: () => !!window.Worker },\n    { name: 'Intersection Observer', check: () => !!window.IntersectionObserver }\n  ];\n  \n  const unsupportedAPIs = requiredAPIs.filter(api => !api.check());\n  \n  if (unsupportedAPIs.length > 0) {\n    const missingAPIs = unsupportedAPIs.map(api => api.name).join(', ');\n    throw new Error(`浏览器不支持以下必要API: ${missingAPIs}`);\n  }\n  \n  console.log('✅ 浏览器兼容性检查通过');\n}\n\n/**\n * 绑定事件监听器\n */\nfunction bindEventListeners() {\n  console.log('绑定事件监听器...');\n  \n  // 选择数据集按钮\n  const selectDatasetBtn = document.getElementById('select-dataset-btn');\n  if (selectDatasetBtn) {\n    selectDatasetBtn.addEventListener('click', handleSelectDataset);\n  }\n  \n  // 错误模态框关闭按钮\n  const errorCloseBtn = document.getElementById('error-close-btn');\n  if (errorCloseBtn) {\n    errorCloseBtn.addEventListener('click', hideError);\n  }\n  \n  // 视图控制按钮\n  const resetZoomBtn = document.getElementById('reset-zoom-btn');\n  if (resetZoomBtn) {\n    resetZoomBtn.addEventListener('click', () => {\n      if (annotationTool) {\n        annotationTool.resetView();\n      }\n    });\n  }\n  \n  const fitScreenBtn = document.getElementById('fit-screen-btn');\n  if (fitScreenBtn) {\n    fitScreenBtn.addEventListener('click', () => {\n      if (annotationTool) {\n        annotationTool.fitToScreen();\n      }\n    });\n  }\n  \n  // 视角选择按钮事件委托\n  document.addEventListener('click', (event) => {\n    if (event.target.classList.contains('btn-view-angle')) {\n      const viewAngle = event.target.dataset.viewAngle;\n      handleViewAngleSelect(viewAngle);\n    }\n  });\n  \n  // 标注控制按钮\n  const undoBtn = document.getElementById('undo-btn');\n  if (undoBtn) {\n    undoBtn.addEventListener('click', () => {\n      if (annotationTool) {\n        annotationTool.undo();\n      }\n    });\n  }\n  \n  const redoBtn = document.getElementById('redo-btn');\n  if (redoBtn) {\n    redoBtn.addEventListener('click', () => {\n      if (annotationTool) {\n        annotationTool.redo();\n      }\n    });\n  }\n  \n  const clearAllBtn = document.getElementById('clear-all-btn');\n  if (clearAllBtn) {\n    clearAllBtn.addEventListener('click', handleClearAllAnnotations);\n  }\n  \n  // 🔧 NEW: SIFT匹配按钮\n  const siftMatchBtn = document.getElementById('sift-match-btn');\n  if (siftMatchBtn) {\n    siftMatchBtn.addEventListener('click', handleSiftMatch);\n  }\n  \n  // 分支点预览切换按钮\n  const togglePreviewBtn = document.getElementById('toggle-preview-btn');\n  if (togglePreviewBtn) {\n    togglePreviewBtn.addEventListener('click', () => {\n      if (branchPointPreviewManager) {\n        branchPointPreviewManager.toggleVisibility();\n      }\n    });\n  }\n\n\n  \n  // 自动化方向选择按钮\n  const autoDirectionBtn = document.getElementById('auto-direction-btn');\n  if (autoDirectionBtn) {\n    autoDirectionBtn.addEventListener('click', handleAutoDirectionSelection);\n  }\n\n  // 🔧 NEW: Auto Direction Mode Selector (Longitudinal vs Cross-Sectional)\n  const autoDirectionModeSelector = document.getElementById('auto-direction-mode-selector');\n  if (autoDirectionModeSelector) {\n    autoDirectionModeSelector.addEventListener('change', handleAutoDirectionModeChange);\n  }\n\n  // 锁定倍数控件\n  const zoomLockCheckbox = document.getElementById('zoom-lock-checkbox');\n  const zoomLockValue = document.getElementById('zoom-lock-value');\n  if (zoomLockCheckbox && zoomLockValue) {\n    zoomLockCheckbox.addEventListener('change', handleZoomLockChange);\n    zoomLockValue.addEventListener('change', handleZoomLockValueChange);\n  }\n\n  // 自动切换到预期位置控件\n  const autoMoveCheckbox = document.getElementById('auto-move-checkbox');\n  if (autoMoveCheckbox) {\n    autoMoveCheckbox.addEventListener('change', handleAutoMoveChange);\n  }\n\n  // 🔄 实时变更同步控件\n  const realTimeChangeCheckbox = document.getElementById('real-time-change-checkbox');\n  if (realTimeChangeCheckbox) {\n    realTimeChangeCheckbox.addEventListener('change', handleRealTimeChangeChange);\n  }\n\n  // 跳过植株模态框事件\n  const skipModalClose = document.getElementById('skip-modal-close');\n  const skipCancelBtn = document.getElementById('skip-cancel-btn');\n  const skipConfirmBtn = document.getElementById('skip-confirm-btn');\n\n  if (skipModalClose) {\n    skipModalClose.addEventListener('click', hideSkipPlantModal);\n  }\n\n  if (skipCancelBtn) {\n    skipCancelBtn.addEventListener('click', hideSkipPlantModal);\n  }\n\n  if (skipConfirmBtn) {\n    skipConfirmBtn.addEventListener('click', confirmSkipPlant);\n  }\n\n  // 模态框背景点击关闭\n  const skipModal = document.getElementById('skip-plant-modal');\n  if (skipModal) {\n    skipModal.addEventListener('click', (e) => {\n      if (e.target === skipModal) {\n        hideSkipPlantModal();\n      }\n    });\n  }\n\n  // 状态过滤器\n  const statusFilter = document.getElementById('status-filter');\n  if (statusFilter) {\n    statusFilter.addEventListener('change', handleStatusFilterChange);\n  }\n\n  // 植株搜索\n  const plantSearch = document.getElementById('plant-search');\n  if (plantSearch) {\n    plantSearch.addEventListener('input', handlePlantSearchInput);\n  }\n  \n  // 标注操作按钮\n  const saveAnnotationBtn = document.getElementById('save-annotation-btn');\n  if (saveAnnotationBtn) {\n    saveAnnotationBtn.addEventListener('click', handleSaveAnnotation);\n  }\n  \n  // 保存标注模态框事件\n  const saveAnnotationCancelBtn = document.getElementById('save-annotation-cancel-btn');\n  if (saveAnnotationCancelBtn) {\n    saveAnnotationCancelBtn.addEventListener('click', hideSaveAnnotationModal);\n  }\n  \n  const saveAnnotationConfirmBtn = document.getElementById('save-annotation-confirm-btn');\n  if (saveAnnotationConfirmBtn) {\n    saveAnnotationConfirmBtn.addEventListener('click', () => {\n      const selectedMode = document.querySelector('input[name=\"save-mode\"]:checked');\n      if (selectedMode) {\n        const isManualAdjustment = selectedMode.value === 'current-only';\n        performSaveAnnotation(isManualAdjustment);\n      }\n    });\n  }\n  \n  const completePlantBtn = document.getElementById('complete-plant-btn');\n  if (completePlantBtn) {\n    completePlantBtn.addEventListener('click', handleCompletePlant);\n  }\n  \n  const exportDataBtn = document.getElementById('export-data-btn');\n  if (exportDataBtn) {\n    exportDataBtn.addEventListener('click', handleExportData);\n  }\n  \n  // 🔧 NEW: Delete Plant Annotations button\n  const deletePlantAnnotationsBtn = document.getElementById('delete-plant-annotations-btn');\n  if (deletePlantAnnotationsBtn) {\n    deletePlantAnnotationsBtn.addEventListener('click', handleDeletePlantAnnotations);\n  }\n  \n  // 🔧 NEW: Delete Plant Annotations modal events\n  const deleteModalClose = document.getElementById('delete-modal-close');\n  const deleteCancelBtn = document.getElementById('delete-cancel-btn');\n  const deleteConfirmBtn = document.getElementById('delete-confirm-btn');\n  const deleteConfirmationCheckbox = document.getElementById('delete-confirmation-checkbox');\n  \n  if (deleteModalClose) {\n    deleteModalClose.addEventListener('click', hideDeletePlantAnnotationsModal);\n  }\n  \n  if (deleteCancelBtn) {\n    deleteCancelBtn.addEventListener('click', hideDeletePlantAnnotationsModal);\n  }\n  \n  if (deleteConfirmBtn) {\n    deleteConfirmBtn.addEventListener('click', confirmDeletePlantAnnotations);\n  }\n  \n  if (deleteConfirmationCheckbox) {\n    deleteConfirmationCheckbox.addEventListener('change', handleDeleteConfirmationChange);\n  }\n  \n  // 🔧 NEW: Delete modal background click close\n  const deleteModal = document.getElementById('delete-plant-annotations-modal');\n  if (deleteModal) {\n    deleteModal.addEventListener('click', (e) => {\n      if (e.target === deleteModal) {\n        hideDeletePlantAnnotationsModal();\n      }\n    });\n  }\n  \n  // 键盘快捷键\n  document.addEventListener('keydown', handleKeyboardShortcuts);\n  \n  // 防止右键菜单（在标注区域）\n  const canvasContainer = document.getElementById('canvas-container');\n  if (canvasContainer) {\n    canvasContainer.addEventListener('contextmenu', (e) => e.preventDefault());\n  }\n  \n  // 植物更新事件监听\n  document.addEventListener('plantUpdated', handlePlantUpdated);\n  \n  // 模态框背景点击关闭事件\n  const errorModal = document.getElementById('error-modal');\n  if (errorModal) {\n    errorModal.addEventListener('click', (e) => {\n      if (e.target === errorModal) {\n        hideError();\n      }\n    });\n  }\n  \n  const saveAnnotationModal = document.getElementById('save-annotation-modal');\n  if (saveAnnotationModal) {\n    saveAnnotationModal.addEventListener('click', (e) => {\n      if (e.target === saveAnnotationModal) {\n        hideSaveAnnotationModal();\n      }\n    });\n  }\n  \n  // 🔧 NEW: Unskip Plant Modal Events\n  const unskipModalClose = document.getElementById('unskip-modal-close');\n  const unskipCancelBtn = document.getElementById('unskip-cancel-btn');\n  const unskipConfirmBtn = document.getElementById('unskip-confirm-btn');\n  \n  if (unskipModalClose) {\n    unskipModalClose.addEventListener('click', hideUnskipPlantModal);\n  }\n  \n  if (unskipCancelBtn) {\n    unskipCancelBtn.addEventListener('click', hideUnskipPlantModal);\n  }\n  \n  if (unskipConfirmBtn) {\n    unskipConfirmBtn.addEventListener('click', confirmUnskipPlant);\n  }\n  \n  // 🔧 NEW: Uncomplete Plant Modal Events\n  const uncompleteModalClose = document.getElementById('uncomplete-modal-close');\n  const uncompleteCancelBtn = document.getElementById('uncomplete-cancel-btn');\n  const uncompleteConfirmBtn = document.getElementById('uncomplete-confirm-btn');\n  \n  if (uncompleteModalClose) {\n    uncompleteModalClose.addEventListener('click', hideUncompletePlantModal);\n  }\n  \n  if (uncompleteCancelBtn) {\n    uncompleteCancelBtn.addEventListener('click', hideUncompletePlantModal);\n  }\n  \n  if (uncompleteConfirmBtn) {\n    uncompleteConfirmBtn.addEventListener('click', confirmUncompletePlant);\n  }\n  \n  // 🔧 NEW: Modal background click close events\n  const unskipModal = document.getElementById('unskip-plant-modal');\n  if (unskipModal) {\n    unskipModal.addEventListener('click', (e) => {\n      if (e.target === unskipModal) {\n        hideUnskipPlantModal();\n      }\n    });\n  }\n  \n  const uncompleteModal = document.getElementById('uncomplete-plant-modal');\n  if (uncompleteModal) {\n    uncompleteModal.addEventListener('click', (e) => {\n      if (e.target === uncompleteModal) {\n        hideUncompletePlantModal();\n      }\n    });\n  }\n  \n  console.log('✅ 事件监听器绑定完成');\n}\n\n/**\n * 处理数据集选择\n */\nasync function handleSelectDataset() {\n  console.log('开始连接数据集...');\n  \n  // 确保plantDataManager已初始化\n  if (!plantDataManager) {\n    console.error('PlantDataManager未初始化');\n    showError('系统错误', '数据管理器未正确初始化，请刷新页面重试');\n    return;\n  }\n  \n  try {\n    // 显示加载状态\n    const selectBtn = document.getElementById('select-dataset-btn');\n    const originalText = selectBtn.textContent;\n    selectBtn.textContent = 'Connecting...';\n    selectBtn.disabled = true;\n    \n    // 检查后端连接\n    updateProgressInfo('Connecting to backend...');\n    const datasetInfo = await plantDataManager.fileSystemManager.getDatasetInfo();\n    \n    if (!datasetInfo) {\n      throw new Error('无法连接到后端服务，请确保后端服务已启动');\n    }\n\n    console.log('连接的数据集:', datasetInfo.datasetPath);\n\n    // 验证目录结构\n    await validateDatasetStructure();\n\n    // 使用PlantDataManager加载数据集\n    updateProgressInfo('Loading plants...');\n    const plants = await plantDataManager.loadDataset();\n    \n    // 更新应用状态\n    appState.currentDatasetPath = datasetInfo.datasetPath;\n    appState.plants = plants;\n    currentDataset = {\n      path: datasetInfo.datasetPath,\n      name: 'Brassica napus dataset',\n      plantCount: plants.length\n    };\n    \n    // 更新UI\n    updateProgressInfo(`Loaded ${plants.length} plants`);\n    selectBtn.textContent = 'Reconnect Dataset';\n    \n    // 显示植物列表\n    renderPlantList(plants);\n    \n    // 初始更新统计显示\n    updateProgressStats();\n    \n    console.log(`成功加载数据集: ${plants.length} 个植物`);\n    \n  } catch (error) {\n    console.error('选择数据集失败:', error);\n    \n    showError('连接数据集失败', error.message);\n  } finally {\n    // 恢复按钮状态\n    const selectBtn = document.getElementById('select-dataset-btn');\n    selectBtn.textContent = appState.currentDatasetPath ? '重新连接数据集' : '连接数据集';\n    selectBtn.disabled = false;\n  }\n}\n\n/**\n * 验证数据集目录结构\n */\nasync function validateDatasetStructure() {\n  console.log('验证数据集结构...');\n  \n  try {\n    // 通过HTTP后端获取植物文件夹列表\n    const plantDirectories = await plantDataManager.fileSystemManager.traversePlantDirectories();\n    \n    if (!plantDirectories || plantDirectories.length === 0) {\n      throw new Error('数据集中未找到植物文件夹（以BR开头的文件夹）');\n    }\n    \n    // 验证至少一个植物文件夹的结构\n    const firstPlant = plantDirectories[0];\n    const imagesByView = await plantDataManager.fileSystemManager.readPlantImages(firstPlant.id);\n    \n    if (!imagesByView || Object.keys(imagesByView).length === 0) {\n      throw new Error(`植物文件夹 ${firstPlant.id} 中未找到有效的视角目录`);\n    }\n    \n    // 检查是否有sv-000视角\n    if (!imagesByView['sv-000'] || imagesByView['sv-000'].length === 0) {\n      throw new Error(`植物文件夹 ${firstPlant.id} 中未找到 sv-000 视角图像`);\n    }\n    \n    console.log(`✅ 数据集结构验证通过，发现 ${plantDirectories.length} 个植物文件夹`);\n    \n  } catch (error) {\n    console.error('数据集结构验证失败:', error);\n    throw error;\n  }\n}\n\n/**\n * 更新统计进度条显示 - 🔧 ENHANCED: Plant-based progress instead of image-based\n */\nfunction updateProgressStats() {\n  if (!plantDataManager) {\n    hideProgressStats();\n    return;\n  }\n\n  const progressStats = plantDataManager.getProgress();\n\n  // 获取DOM元素\n  const progressStatsElement = document.getElementById('progress-stats');\n  const completedImagesCount = document.getElementById('completed-images-count');\n  const totalImagesCount = document.getElementById('total-images-count');\n  const completionPercentage = document.getElementById('completion-percentage');\n  const completedPlantsCount = document.getElementById('completed-plants-count');\n  const totalPlantsCount = document.getElementById('total-plants-count');\n  const progressBarFill = document.getElementById('progress-bar-fill');\n\n  if (!progressStatsElement) return;\n\n  // 显示统计区域\n  progressStatsElement.style.display = 'block';\n\n  // 🔧 FIX: Change from image count to plant count display\n  // Update completed plants count in the main progress display\n  if (completedImagesCount) {\n    const totalCompleted = progressStats.totalCompleted || (progressStats.completed + progressStats.skipped);\n    completedImagesCount.textContent = totalCompleted; // Now shows completed plants instead of images\n  }\n  \n  if (totalImagesCount) {\n    totalImagesCount.textContent = progressStats.total; // Now shows total plants instead of images\n  }\n\n  // 更新完成百分比（基于植株完成率）\n  if (completionPercentage) {\n    completionPercentage.textContent = progressStats.completionRate + '%';\n  }\n\n  // 更新植株数量详细信息（显示总完成数，包括跳过的）\n  if (completedPlantsCount) {\n    const totalCompleted = progressStats.totalCompleted || (progressStats.completed + progressStats.skipped);\n    const skippedText = progressStats.skipped > 0 ? ` (${progressStats.skipped} skipped)` : '';\n    completedPlantsCount.textContent = `${totalCompleted} plants finished ${skippedText}`;\n  }\n\n  if (totalPlantsCount) {\n    totalPlantsCount.textContent = `Total ${progressStats.total} plants`;\n  }\n\n  // 更新进度条（使用植株完成率，包含跳过的植株）\n  if (progressBarFill) {\n    const percentage = parseFloat(progressStats.completionRate) || 0;\n    progressBarFill.style.width = percentage + '%';\n    \n    // 根据完成度改变进度条颜色\n    if (percentage >= 100) {\n      progressBarFill.style.background = 'linear-gradient(90deg, #059669 0%, #047857 100%)';\n    } else if (percentage >= 75) {\n      progressBarFill.style.background = 'linear-gradient(90deg, #10b981 0%, #059669 100%)';\n    } else if (percentage >= 50) {\n      progressBarFill.style.background = 'linear-gradient(90deg, #34d399 0%, #10b981 100%)';\n    } else if (percentage >= 25) {\n      progressBarFill.style.background = 'linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%)';\n    } else {\n      progressBarFill.style.background = 'linear-gradient(90deg, #f87171 0%, #ef4444 100%)';\n    }\n  }\n\n  // 🔧 FIX: Update console log to show plant-based progress\n  const totalCompleted = progressStats.totalCompleted || (progressStats.completed + progressStats.skipped);\n  console.log(`统计更新: ${totalCompleted}/${progressStats.total} 植株 (${progressStats.completionRate}%)`);\n}\n\n/**\n * 隐藏统计进度条\n */\nfunction hideProgressStats() {\n  const progressStatsElement = document.getElementById('progress-stats');\n  if (progressStatsElement) {\n    progressStatsElement.style.display = 'none';\n  }\n}\n\n/**\n * 渲染植物列表\n */\nfunction renderPlantList(plants) {\n  const container = document.getElementById('plant-list-container');\n  if (!container) return;\n  \n  // 清空现有内容\n  container.innerHTML = '';\n  \n  if (plants.length === 0) {\n    container.innerHTML = '<div class=\"no-data\">no data</div>';\n    return;\n  }\n  \n  // 创建植物列表项\n  plants.forEach(plant => {\n    const plantItem = createPlantListItem(plant);\n    container.appendChild(plantItem);\n  });\n  \n  // 更新统计显示\n  updateProgressStats();\n  \n  // 🔧 OPTIMIZED: Auto-load note badges immediately upon plant list render\n  const updateBadgesInstantly = async () => {\n    console.log('[Badge Update] Starting automatic badge loading for all plants');\n    \n    // Wait for note system with more aggressive retry for better UX\n    let retryCount = 0;\n    const maxRetries = 15; // Increased retries\n    const retryDelay = 300; // Reduced delay for faster startup\n    \n    while (retryCount < maxRetries) {\n      if (window.PlantAnnotationTool?.noteManager && window.PlantAnnotationTool?.noteUI) {\n        try {\n          console.log('[Badge Update] Note system available, starting bulk badge update');\n          const startTime = performance.now();\n          \n          // Try to use pre-cached bulk data first (fastest option)\n          let bulkData = window.PlantAnnotationTool.noteManager.bulkNoteData;\n          \n          if (!bulkData) {\n            console.log('[Badge Update] No pre-cached data, fetching bulk notes for instant display...');\n            try {\n              bulkData = await window.PlantAnnotationTool.noteManager.getAllNotesInBulk();\n              console.log('[Badge Update] Bulk data fetched successfully');\n            } catch (bulkError) {\n              console.warn('[Badge Update] Bulk API failed, using optimized individual requests:', bulkError.message);\n              // Fall back to individual badge updates but with optimized approach\n              await window.PlantAnnotationTool.noteUI.updateAllPlantNoteBadges();\n              const endTime = performance.now();\n              console.log(`[Badge Update] Individual badge update completed in ${(endTime - startTime).toFixed(2)}ms`);\n              return;\n            }\n          }\n          \n          if (bulkData) {\n            // Use instant bulk badge update\n            await window.PlantAnnotationTool.noteUI.updateAllPlantNoteBadgesFromBulk(bulkData);\n            const endTime = performance.now();\n            console.log(`[Badge Update] INSTANT bulk badge update completed in ${(endTime - startTime).toFixed(2)}ms`);\n            console.log('[Badge Update] ✅ All plant note badges are now visible immediately');\n          } else {\n            // Ultimate fallback to individual updates\n            console.log('[Badge Update] Using fallback individual badge updates');\n            await window.PlantAnnotationTool.noteUI.updateAllPlantNoteBadges();\n            const endTime = performance.now();\n            console.log(`[Badge Update] Fallback badge update completed in ${(endTime - startTime).toFixed(2)}ms`);\n          }\n          \n          return; // Success, exit retry loop\n        } catch (error) {\n          console.error('[Badge Update] Badge update failed:', error);\n          retryCount++;\n          if (retryCount >= maxRetries) {\n            console.error('[Badge Update] Max retries reached, badge update failed permanently');\n            return;\n          }\n        }\n      } else {\n        console.log(`[Badge Update] Note system not ready, retry ${retryCount + 1}/${maxRetries}`);\n        retryCount++;\n      }\n      \n      // Wait before next retry\n      await new Promise(resolve => setTimeout(resolve, retryDelay));\n    }\n    \n    console.warn('[Badge Update] ❌ Note system initialization timeout, badges will load later');\n  };\n  \n  // Start badge update immediately, but don't block plant list rendering\n  setTimeout(updateBadgesInstantly, 100);\n  \n  console.log(`渲染了 ${plants.length} 个植物列表项`);\n}\n\n/**\n * Create plant list item with note indicators\n */\nfunction createPlantListItem(plant) {\n  const item = document.createElement('div');\n  item.className = 'plant-item';\n  item.dataset.plantId = plant.id;\n  \n  // Status icon\n  const statusIcon = getStatusIcon(plant.status);\n  \n  // Image count info\n  const imageCountText = plant.imageCount > 0 ? \n    `${plant.imageCount} images` : \n    (plant.hasImages ? 'loading...' : 'no image');\n  \n  // View angle info\n  const viewAnglesText = plant.viewAngles.length > 0 ? \n    `view: ${plant.viewAngles.join(', ')}` :\n    'view: checking...';\n    \n  // Selected view info\n  const selectedViewText = plant.selectedViewAngle ? \n    `Chosen: ${plant.selectedViewAngle}` : '';\n  \n  // 🔧 NEW: State-based button system for skip/unskip and complete/uncomplete\n  const isSkipped = plant.status === 'skipped';\n  const isCompleted = plant.status === 'completed';\n  \n  // 🔧 FIX: Ensure CSS classes reflect current state\n  if (isSkipped) {\n    item.classList.add('skipped');\n  } else {\n    item.classList.remove('skipped');\n  }\n\n  // Skip reason display\n  const skipReasonHtml = isSkipped && plant.skipReason ?\n    `<div class=\"skip-reason\">skip reason: ${plant.skipReason}</div>` : '';\n\n  // 🔧 NEW: Dynamic button generation based on plant state\n  let stateButtonsHtml = '';\n  \n  // Only Skip/Unskip button - Complete functionality is handled by main interface\n  if (isSkipped) {\n    stateButtonsHtml += `<button class=\"skip-button unskip-variant\" onclick=\"handleUnskipPlant('${plant.id}', event)\">Unskip</button>`;\n  } else {\n    stateButtonsHtml += `<button class=\"skip-button\" onclick=\"showSkipPlantModal('${plant.id}', event)\">Skip</button>`;\n  }\n\n  item.innerHTML = `\n    <div class=\"plant-item-content\">\n      <div class=\"plant-header\">\n        <div class=\"plant-status\">${statusIcon}</div>\n        <div class=\"plant-id\">${plant.id}</div>\n        <div class=\"right-box\">\n          <div class=\"plant-note-badge\" id=\"note-badge-${plant.id}\" style=\"display: none;\"></div>\n          <div class=\"state-buttons\">${stateButtonsHtml}</div>\n        </div>\n      </div>\n      <div class=\"plant-info\">\n        <div class=\"image-count\">${imageCountText}</div>\n        <div class=\"status-text\">${getStatusText(plant.status)}</div>\n      </div>\n      <div class=\"plant-view-info\">\n        <div class=\"view-angles\">${viewAnglesText}</div>\n        ${selectedViewText ? `<div class=\"selected-view\">${selectedViewText}</div>` : ''}\n      </div>\n      ${skipReasonHtml}\n    </div>\n  `;\n  \n  // Click event\n  item.addEventListener('click', () => handlePlantSelect(plant));\n  \n  // Note: Badge updates are handled by NoteUI.updateAllPlantNoteBadges()\n  // No individual loading needed here to avoid race conditions\n  \n  return item;\n}\n\n/**\n * Load and display image note count with refresh detection\n */\nasync function loadImageNoteCount(plantId, imageId) {\n  try {\n    // Check if note system is available\n    if (!window.PlantAnnotationTool || !window.PlantAnnotationTool.noteManager) {\n      console.warn(`[Thumbnail] Note system not available for ${imageId}`);\n      return;\n    }\n    \n    const noteManager = window.PlantAnnotationTool.noteManager;\n    console.log(`[Thumbnail] Loading note count for ${plantId}/${imageId}`);\n    \n    // 🔧 FIX: Check if this is a forced refresh (no cache) scenario\n    const isDirectRefresh = arguments[2]; // Hidden parameter for direct refresh flag\n    let notes;\n    \n    if (isDirectRefresh) {\n      // Force direct API call without cache\n      console.log(`[Thumbnail] Using direct API for forced refresh of ${imageId}`);\n      try {\n        const response = await fetch(`${noteManager.baseUrl}/notes/image/${plantId}/${imageId}`);\n        if (response.ok) {\n          const result = await response.json();\n          notes = result.success ? (result.data || []) : [];\n        } else {\n          notes = [];\n        }\n      } catch (directError) {\n        console.warn(`[Thumbnail] Direct API failed, falling back to cache for ${imageId}:`, directError);\n        notes = await noteManager.getImageNotes(plantId, imageId);\n      }\n    } else {\n      // Normal cached operation\n      notes = await noteManager.getImageNotes(plantId, imageId);\n    }\n    \n    const noteCount = notes ? notes.length : 0;\n    console.log(`[Thumbnail] Found ${noteCount} notes for ${imageId}`);\n    \n    const badge = document.getElementById(`image-note-badge-${imageId}`);\n    if (badge) {\n      console.log(`[Thumbnail] Badge element found for ${imageId}`);\n      if (noteCount > 0) {\n        badge.innerHTML = `<span class=\"image-note-count\">📝 ${noteCount}</span>`;\n        badge.style.display = 'inline-block';\n        badge.className = 'image-note-badge';\n        console.log(`[Thumbnail] Badge updated with ${noteCount} notes for ${imageId}`);\n      } else {\n        // 🔧 FIX: Clear badge when no notes exist\n        badge.innerHTML = '';\n        badge.style.display = 'none';\n        console.log(`[Thumbnail] Badge cleared for ${imageId} (no notes)`);\n      }\n      console.log(`[Thumbnail] Badge updated for ${imageId}: ${noteCount} notes`);\n    } else {\n      console.error(`[Thumbnail] Badge element NOT FOUND for ${imageId} (ID: image-note-badge-${imageId})`);\n    }\n  } catch (error) {\n    // Silently handle errors - note loading is not critical for UI\n    console.error(`[Thumbnail] Note loading failed for image ${imageId}:`, error.message);\n    \n    // 🔧 FIX: Clear badge on error to prevent stale data\n    const badge = document.getElementById(`image-note-badge-${imageId}`);\n    if (badge) {\n      badge.innerHTML = '';\n      badge.style.display = 'none';\n      console.log(`[Thumbnail] Badge cleared on error for ${imageId}`);\n    }\n  }\n}\n\n// 🔧 FIX: 将加载图像笔记计数函数暴露到全局，供NoteUI调用\nwindow.loadImageNoteCount = loadImageNoteCount;\n\n/**\n * 获取状态图标\n */\nfunction getStatusIcon(status) {\n  switch (status) {\n    case 'completed':\n      return '✅';\n    case 'in-progress':\n      return '🔄';\n    case 'skipped':\n      return '⏭️';\n    case 'pending':\n    default:\n      return '⭕';\n  }\n}\n\n/**\n * 获取状态文本\n */\nfunction getStatusText(status) {\n  switch (status) {\n    case 'completed':\n      return 'Finished';\n    case 'in-progress':\n      return 'In progress';\n    case 'skipped':\n      return 'Skipped';\n    case 'pending':\n    default:\n      return 'Not started';\n  }\n}\n\n/**\n * 初始化工作区到空状态\n */\nfunction initializeEmptyWorkspace() {\n  console.log('初始化空工作区状态');\n  \n  // 清空应用状态\n  appState.currentPlant = null;\n  appState.currentImage = null;\n  \n  // 清空工作区\n  clearWorkspaceState();\n  \n  // 🔧 FIX: Ensure branch point preview is reset in empty workspace state  \n  if (branchPointPreviewManager) {\n    branchPointPreviewManager.reset();\n    console.log('[EmptyWorkspace] Branch point preview reset - entering empty state');\n  }\n  \n  // 隐藏视角选择区域\n  const viewAngleSection = document.getElementById('view-angle-section');\n  if (viewAngleSection) {\n    viewAngleSection.style.display = 'none';\n  }\n  \n  // 🔧 FIX: Clear image note button badge when initializing empty workspace\n  if (window.PlantAnnotationTool?.noteUI) {\n    window.PlantAnnotationTool.noteUI.updateImageNoteButton(null, null);\n    console.log('[EmptyWorkspace] Image note button badge cleared');\n  }\n  \n  // 更新进度信息\n  updateProgressInfo('Please connect to dataset and select a plant');\n  \n  // 🔧 NEW: Update delete button state when workspace is empty\n  updateDeletePlantAnnotationsButtonState();\n  \n  // 🔧 NEW: Update complete plant button state when workspace is empty\n  updateCompletePlantButtonState();\n}\n\n/**\n * 清空工作区状态\n */\nfunction clearWorkspaceState() {\n  console.log('清空工作区状态');\n  \n  // 清空标注工具 - 使用新的clearImage方法完全清空图像\n  if (annotationTool) {\n    annotationTool.clearImage(); // 🔧 FIX: 使用clearImage替代resetView，防止显示残留图像\n  }\n  \n  // 🔧 FIX: Reset branch point preview when clearing workspace (no previous image context)\n  if (branchPointPreviewManager) {\n    branchPointPreviewManager.reset();\n    console.log('[Workspace] Branch point preview reset - no previous image context');\n  }\n  \n  // 🔧 FIX: 在清空工作区后再设置 currentImage 为 null（防止自动保存引用错误）\n  appState.currentImage = null;\n  \n  // 隐藏状态显示\n  hideAnnotationStatusDisplay();\n  \n  // 清空缩略图容器\n  const thumbnailContainer = document.getElementById('thumbnail-container');\n  if (thumbnailContainer) {\n    thumbnailContainer.innerHTML = '<div class=\"no-images\">Please choose view</div>';\n  }\n  \n  // 重置视角按钮\n  const viewAngleButtons = document.querySelectorAll('.btn-view-angle');\n  viewAngleButtons.forEach(button => {\n    button.classList.remove('selected');\n    button.disabled = true;\n  });\n  \n  // 清空当前植物标题\n  const titleElement = document.getElementById('current-plant-title');\n  if (titleElement && !appState.currentPlant) {\n    titleElement.textContent = 'Plant: Please select';\n  }\n  \n  // 🔧 FIX: Clear image note button badge when no image is selected\n  if (window.PlantAnnotationTool?.noteUI) {\n    window.PlantAnnotationTool.noteUI.updateImageNoteButton(null, null);\n    console.log('[Workspace] Image note button badge cleared');\n  }\n}\n\n/**\n * 处理植物选择\n */\nasync function handlePlantSelect(plant) {\n  console.log('选择植物:', plant.id);\n  \n  // 确保plantDataManager已初始化\n  if (!plantDataManager) {\n    console.error('PlantDataManager未初始化');\n    showError('系统错误', '数据管理器未正确初始化，请刷新页面重试');\n    return;\n  }\n  \n  try {\n    // 🔧 FIX: 在切换植物前先保存当前图像的标注（防止标注丢失）\n    if (appState.currentImage && annotationTool) {\n      try {\n        const currentAnnotations = annotationTool.getAnnotationData();\n        if (currentAnnotations.keypoints.length > 0) {\n          console.log('植物切换前自动保存当前图像标注:', appState.currentImage.id);\n          await plantDataManager.saveImageAnnotations(\n            appState.currentImage.id,\n            currentAnnotations.keypoints\n          );\n          console.log('植物切换前标注保存成功');\n          \n          // 🔧 FIX: 植物切换前保存后立即刷新缩略图状态\n          await refreshThumbnailAnnotationStatus(appState.currentImage.id);\n          console.log('植物切换前缩略图状态已刷新');\n        }\n      } catch (error) {\n        console.warn('植物切换前自动保存标注失败:', error);\n        // 不阻断切换流程，但记录错误\n      }\n    }\n    \n    // 清空工作区状态 - 当切换植物时\n    clearWorkspaceState();\n    \n    // 更新当前植物\n    appState.currentPlant = plant;\n    \n    // 更新UI\n    updateCurrentPlantTitle(plant);\n    updatePlantItemSelection(plant.id);\n    \n    // 加载植物图像数据（所有视角）\n    updateProgressInfo(`Loading ${plant.id} image data...`);\n    const imagesByView = await plantDataManager.getPlantImages(plant.id);\n    \n    console.log(`植物 ${plant.id} 图像数据:`, imagesByView);\n    \n    // 更新笔记系统当前植物\n    if (window.PlantAnnotationTool?.noteUI) {\n      window.PlantAnnotationTool.noteUI.setCurrentPlant(plant.id);\n    }\n\n    // 预加载笔记（性能优化）\n    if (window.PlantAnnotationTool?.noteManager) {\n      // 获取植物的所有图像ID进行预加载\n      const allImageIds = Object.values(imagesByView).flat().map(img => img.id);\n      window.PlantAnnotationTool.noteManager.preloadNotes(plant.id, allImageIds.slice(0, 5)); // 只预加载前5个\n    }\n    \n    // 显示视角选择界面\n    await showViewAngleSelection(plant, imagesByView);\n    \n    updateProgressInfo(`Loaded ${plant.id} - Total ${plant.imageCount} images`);\n    \n    // 🔧 NEW: Update delete button state when plant is selected\n    updateDeletePlantAnnotationsButtonState();\n    \n    // 🔧 NEW: Update complete plant button state when plant is selected\n    updateCompletePlantButtonState();\n    \n  } catch (error) {\n    console.error('选择植物失败:', error);\n    showError('加载植物数据失败', error.message);\n  }\n}\n\n/**\n * 显示视角选择界面\n */\nasync function showViewAngleSelection(plant, imagesByView) {\n  const viewAngleSection = document.getElementById('view-angle-section');\n  const thumbnailContainer = document.getElementById('thumbnail-container');\n  const viewAngleInfo = document.getElementById('view-angle-info');\n  \n  if (!viewAngleSection || !thumbnailContainer || !viewAngleInfo) return;\n  \n  // 显示视角选择区域\n  viewAngleSection.style.display = 'block';\n  \n  // 清空缩略图\n  thumbnailContainer.innerHTML = '<div class=\"no-images\">Please choose view</div>';\n  \n  // 更新视角信息\n  const availableViews = Object.keys(imagesByView).filter(view => imagesByView[view].length > 0);\n  viewAngleInfo.textContent = `available view: ${availableViews.length}`;\n  \n  // 更新视角按钮状态\n  const viewAngleButtons = document.querySelectorAll('.btn-view-angle');\n  viewAngleButtons.forEach(button => {\n    const viewAngle = button.dataset.viewAngle;\n    const hasImages = imagesByView[viewAngle] && imagesByView[viewAngle].length > 0;\n    \n    button.disabled = !hasImages;\n    button.classList.remove('selected');\n    \n    // 更新按钮文本，显示图像数量\n    const imageCount = hasImages ? imagesByView[viewAngle].length : 0;\n    const buttonText = button.textContent.split('(')[0].trim();\n    button.textContent = `${buttonText} (${imageCount})`;\n    \n    if (hasImages) {\n      button.title = `${viewAngle}: ${imageCount} images`;\n    } else {\n      button.title = `${viewAngle}: no image`;\n    }\n  });\n  \n  // 如果已经选择了视角，自动选中\n  if (plant.selectedViewAngle) {\n    const selectedButton = document.querySelector(`[data-view-angle=\"${plant.selectedViewAngle}\"]`);\n    if (selectedButton && !selectedButton.disabled) {\n      selectedButton.classList.add('selected');\n      // 显示该视角的图像\n      await renderImageThumbnails(imagesByView[plant.selectedViewAngle] || []);\n    }\n  }\n}\n\n/**\n * 处理视角选择\n */\nasync function handleViewAngleSelect(viewAngle) {\n  console.log('选择视角:', viewAngle);\n  \n  if (!appState.currentPlant) {\n    showError('操作失败', '请先选择植物');\n    return;\n  }\n  \n  try {\n    // 更新视角按钮状态\n    const viewAngleButtons = document.querySelectorAll('.btn-view-angle');\n    viewAngleButtons.forEach(button => {\n      button.classList.remove('selected');\n      if (button.dataset.viewAngle === viewAngle) {\n        button.classList.add('selected');\n      }\n    });\n    \n    // 设置植物的选中视角\n    plantDataManager.setSelectedViewAngle(appState.currentPlant.id, viewAngle);\n    appState.currentPlant.selectedViewAngle = viewAngle;\n    \n    // 获取该视角的图像\n    updateProgressInfo(`Loading ${viewAngle} image view...`);\n    const images = await plantDataManager.getPlantImages(appState.currentPlant.id, viewAngle);\n    \n    console.log(`${viewAngle} 视角包含 ${images.length} 张图像`);\n\n    // 显示图像缩略图\n    await renderImageThumbnails(images);\n    \n    // 如果有图像，自动选择第一张（首次加载）\n    if (images.length > 0) {\n      await handleImageSelect(images[0], false);\n    }\n    \n    updateProgressInfo(`已选择 ${viewAngle} 视角 - ${images.length} 张图像`);\n    \n  } catch (error) {\n    console.error('选择视角失败:', error);\n    showError('加载视角数据失败', error.message);\n  }\n}\n\n/**\n * 更新当前植物标题\n */\nfunction updateCurrentPlantTitle(plant) {\n  const titleElement = document.getElementById('current-plant-title');\n  if (titleElement) {\n    titleElement.textContent = `Plant: ${plant.id}`;\n  }\n}\n\n/**\n * 更新植物列表项选中状态\n */\nfunction updatePlantItemSelection(selectedPlantId) {\n  // 清除所有选中状态\n  document.querySelectorAll('.plant-item').forEach(item => {\n    item.classList.remove('selected');\n  });\n  \n  // 设置新的选中状态\n  const selectedItem = document.querySelector(`[data-plant-id=\"${selectedPlantId}\"]`);\n  if (selectedItem) {\n    selectedItem.classList.add('selected');\n  }\n}\n\n/**\n * 渲染图像缩略图\n */\nasync function renderImageThumbnails(images) {\n  const container = document.getElementById('thumbnail-container');\n  if (!container) return;\n\n  // 清空现有内容\n  container.innerHTML = '';\n\n  if (images.length === 0) {\n    container.innerHTML = '<div class=\"no-images\">该植物暂无图像</div>';\n    return;\n  }\n\n  // 创建缩略图（异步检查标注状态）\n  for (let i = 0; i < images.length; i++) {\n    const image = images[i];\n    const thumbnail = await createImageThumbnail(image, i === 0);\n    container.appendChild(thumbnail);\n  }\n\n  console.log(`渲染了 ${images.length} 个图像缩略图`);\n}\n\n/**\n * Create image thumbnail with note indicators\n */\nasync function createImageThumbnail(image, isFirst = false) {\n  const thumbnail = document.createElement('div');\n  thumbnail.className = 'image-thumbnail';\n  thumbnail.dataset.imageId = image.id;\n\n  if (isFirst) {\n    thumbnail.classList.add('selected');\n  }\n\n  // Check for annotations\n  let hasAnnotations = false;\n  let annotationCount = 0;\n\n  try {\n    if (plantDataManager) {\n      const annotations = await plantDataManager.getImageAnnotations(image.id);\n      if (annotations && annotations.length > 0) {\n        hasAnnotations = true;\n        annotationCount = annotations.length;\n        thumbnail.classList.add('has-annotations');\n      }\n    }\n  } catch (error) {\n    // Ignore errors, continue rendering\n  }\n\n  thumbnail.innerHTML = `\n    <div class=\"thumbnail-image\">\n      <img src=\"\" alt=\"${image.name}\" data-src=\"${image.id}\" />\n      <div class=\"thumbnail-loading\">Loading...</div>\n      ${hasAnnotations ? `<div class=\"annotation-badge\">${annotationCount}</div>` : ''}\n      <div class=\"image-note-badge\" id=\"image-note-badge-${image.id}\" style=\"display: none;\"></div>\n    </div>\n    <div class=\"thumbnail-info\">\n      <div class=\"image-time\">${image.timeString}</div>\n      ${hasAnnotations ? '<div class=\"annotation-status\">✓ Annotated</div>' : ''}\n    </div>\n  `;\n\n  // Click event (image switching)\n\n/**\n * 刷新缩略图标注状态 - 用于自动保存后的UI同步\n */\nasync function refreshThumbnailAnnotationStatus(imageId) {\n  console.log(`[缩略图刷新] 开始刷新图像: ${imageId}`);\n  \n  const thumbnail = document.querySelector(`[data-image-id=\"${imageId}\"]`);\n  if (!thumbnail) {\n    console.warn(`[缩略图刷新] 找不到图像 ${imageId} 的缩略图元素`);\n    return;\n  }\n  \n  try {\n    console.log(`[缩略图刷新] 正在获取图像 ${imageId} 的标注数据...`);\n    const annotations = await plantDataManager.getImageAnnotations(imageId);\n    const hasAnnotations = annotations && annotations.length > 0;\n    const annotationCount = annotations ? annotations.length : 0;\n    \n    console.log(`[缩略图刷新] 图像 ${imageId} 标注数据: ${annotationCount} 个标注点`);\n    \n    // 更新缩略图类\n    if (hasAnnotations) {\n      thumbnail.classList.add('has-annotations');\n      console.log(`[缩略图刷新] 添加了 has-annotations 类`);\n    } else {\n      thumbnail.classList.remove('has-annotations');\n      console.log(`[缩略图刷新] 移除了 has-annotations 类`);\n    }\n    \n    // 更新标注徽章\n    let annotationBadge = thumbnail.querySelector('.annotation-badge');\n    if (hasAnnotations) {\n      if (!annotationBadge) {\n        annotationBadge = document.createElement('div');\n        annotationBadge.className = 'annotation-badge';\n        thumbnail.querySelector('.thumbnail-image').appendChild(annotationBadge);\n        console.log(`[缩略图刷新] 创建了新的标注徽章`);\n      }\n      annotationBadge.textContent = annotationCount;\n      console.log(`[缩略图刷新] 更新徽章数量: ${annotationCount}`);\n    } else if (annotationBadge) {\n      annotationBadge.remove();\n      console.log(`[缩略图刷新] 移除了标注徽章`);\n    }\n    \n    // 更新标注状态文本\n    let statusElement = thumbnail.querySelector('.annotation-status');\n    if (hasAnnotations) {\n      if (!statusElement) {\n        statusElement = document.createElement('div');\n        statusElement.className = 'annotation-status';\n        statusElement.textContent = '✓ Annotated';\n        thumbnail.querySelector('.thumbnail-info').appendChild(statusElement);\n        console.log(`[缩略图刷新] 创建了 '✓ Annotated' 状态`);\n      }\n    } else if (statusElement) {\n      statusElement.remove();\n      console.log(`[缩略图刷新] 移除了 '✓ Annotated' 状态`);\n    }\n    \n    console.log(`[缩略图刷新] 完成刷新图像 ${imageId}`);\n    \n  } catch (error) {\n    console.error(`[缩略图刷新] 刷新失败:`, error);\n  }\n}\n\n// 🔧 FIX: 将刷新函数暴露到全局，供AnnotationTool调用\nwindow.refreshThumbnailAnnotationStatus = refreshThumbnailAnnotationStatus;\n  thumbnail.addEventListener('click', () => handleImageSelect(image, true));\n\n  // Async load image\n  loadThumbnailImage(thumbnail, image);\n  \n  // Async load note count\n  if (appState.currentPlant) {\n    loadImageNoteCount(appState.currentPlant.id, image.id);\n  }\n\n  return thumbnail;\n}\n\n/**\n * 异步加载缩略图图像\n */\nasync function loadThumbnailImage(thumbnailElement, imageData) {\n  try {\n    const imgElement = thumbnailElement.querySelector('img');\n    const loadingElement = thumbnailElement.querySelector('.thumbnail-loading');\n    \n    // 检查plantDataManager是否已初始化\n    if (!plantDataManager || !plantDataManager.fileSystemManager) {\n      console.error('PlantDataManager或FileSystemManager未初始化');\n      loadingElement.textContent = '初始化错误';\n      loadingElement.style.color = '#dc2626';\n      return;\n    }\n    \n    // 创建图像URL\n    const imageURL = await plantDataManager.fileSystemManager.createImageURL(imageData);\n    \n    // 加载图像\n    imgElement.onload = () => {\n      loadingElement.style.display = 'none';\n      imgElement.style.display = 'block';\n    };\n    \n    imgElement.onerror = () => {\n      loadingElement.textContent = '加载失败';\n      loadingElement.style.color = '#dc2626';\n    };\n    \n    imgElement.src = imageURL;\n    \n  } catch (error) {\n    console.error('加载缩略图失败:', error);\n    const loadingElement = thumbnailElement.querySelector('.thumbnail-loading');\n    loadingElement.textContent = '加载失败';\n    loadingElement.style.color = '#dc2626';\n  }\n}\n\n/**\n * 处理图像选择\n */\nasync function handleImageSelect(image, isImageSwitch = true) {\n  // 🔧 FIX: Prevent race conditions during rapid navigation\n  if (appState.navigation.isNavigating) {\n    console.log(`[Navigation] Blocked concurrent navigation to ${image.name} - already navigating`);\n    return;\n  }\n\n  // 🔧 FIX: Throttle rapid navigation attempts with user feedback\n  const now = Date.now();\n  if (now - appState.navigation.lastNavigationTime < appState.navigation.throttleDelay) {\n    console.log(`[Navigation] Throttled navigation to ${image.name} - too fast (${now - appState.navigation.lastNavigationTime}ms since last)`);\n    // 🔧 NEW: Optional visual feedback for throttled navigation\n    if (window.updateProgressInfo) {\n      const remaining = appState.navigation.throttleDelay - (now - appState.navigation.lastNavigationTime);\n      window.updateProgressInfo(`Navigation throttled - please wait ${remaining}ms`);\n      // Clear the message after a short delay\n      setTimeout(() => {\n        if (window.updateProgressInfo) {\n          window.updateProgressInfo('Ready for navigation');\n        }\n      }, remaining + 100);\n    }\n    return;\n  }\n\n  // Lock navigation\n  appState.navigation.isNavigating = true;\n  appState.navigation.lastNavigationTime = now;\n\n  try {\n    console.log('选择图像:', image.name);\n    \n    // 保存当前图像的标注（如果有的话）\n    if (appState.currentImage && annotationTool) {\n      try {\n        // 🔧 FIX: Store the image ID to prevent race condition corruption\n        const imageToSave = appState.currentImage.id;\n        const currentAnnotations = annotationTool.getAnnotationData();\n        if (currentAnnotations.keypoints.length > 0) {\n          console.log(`[Auto-save] Saving ${currentAnnotations.keypoints.length} annotations for ${imageToSave}`);\n          await plantDataManager.saveImageAnnotations(\n            imageToSave,\n            currentAnnotations.keypoints\n          );\n          console.log(`[Auto-save] Successfully saved annotations for ${imageToSave}`);\n          \n          // 🔧 FIX: 自动保存后立即刷新缩略图状态\n          await refreshThumbnailAnnotationStatus(imageToSave);\n          console.log(`[Auto-save] Thumbnail status refreshed for ${imageToSave}`);\n        }\n      } catch (error) {\n        console.warn(`[Auto-save] Failed to save annotations for ${appState.currentImage?.id}:`, error);\n      }\n    }\n    \n    // 检测是否为该植物的首张图像加载\n    const isFirstImageForPlant = !appState.currentImage || \n                                (appState.currentPlant && appState.currentImage && \n                                 !appState.currentImage.id.startsWith(appState.currentPlant.id));\n    \n    // 更新应用状态\n    appState.currentImage = image;\n    \n    // 更新缩略图选中状态\n    updateImageThumbnailSelection(image.id);\n    \n    // 更新笔记系统当前图像\n    if (window.PlantAnnotationTool?.noteUI) {\n      window.PlantAnnotationTool.noteUI.setCurrentImage(image.id);\n    }\n    \n    // 设置植物的选中图像（重要：这里恢复了原来的逻辑）\n    if (appState.currentPlant) {\n      plantDataManager.setSelectedImage(appState.currentPlant.id, image);\n    }\n    \n    // 加载图像到标注工具\n    if (annotationTool) {\n      // 强制刷新Canvas尺寸，确保正确计算\n      annotationTool.resizeCanvas();\n\n      // 获取锁定倍数设置和自动切换设置\n      const zoomSettings = getZoomLockSettings();\n      const autoMoveSettings = getAutoMoveSettings();\n\n      // 决定是否保持视图状态：只有在非首张图像且是图像切换时才保持\n      const shouldPreserveView = isImageSwitch && !isFirstImageForPlant;\n      console.log(`[调试] isImageSwitch: ${isImageSwitch}, isFirstImageForPlant: ${isFirstImageForPlant}, shouldPreserveView: ${shouldPreserveView}`);\n      \n      await annotationTool.loadImage(image, shouldPreserveView);\n\n      // 应用锁定倍数设置或确保首张图像适合屏幕\n      if (isFirstImageForPlant) {\n        // 首张图像始终适合屏幕\n        console.log('首张图像：重置视图到适合屏幕');\n        setTimeout(() => {\n          annotationTool.fitToScreen();\n        }, 100); // 短暂延迟确保图像加载完成\n      } else if (isImageSwitch && zoomSettings.isLocked) {\n        // 图片切换且启用了锁定倍数\n        annotationTool.setZoom(zoomSettings.lockValue);\n        console.log(`图片切换：应用锁定倍数 ${zoomSettings.lockValue}x`);\n      } else if (isImageSwitch) {\n        console.log('图片切换：保持当前缩放和视图状态');\n      } else {\n        console.log('其他情况：重置视图到适合屏幕');\n        annotationTool.fitToScreen();\n      }\n      \n      // 加载已有的标注数据\n      try {\n        console.log(`[标注] 开始加载图像标注: ${image.id}`);\n        const existingAnnotations = await plantDataManager.getImageAnnotations(image.id);\n        if (existingAnnotations && existingAnnotations.length > 0) {\n          annotationTool.loadAnnotationData({ keypoints: existingAnnotations });\n          console.log(`[标注] 加载了 ${existingAnnotations.length} 个已有标注点`);\n          \n          // 🔧 FIX: 同步自定义标注到CustomAnnotationManager内部状态\n          if (annotationTool.customAnnotationManager) {\n            const customAnnotations = existingAnnotations.filter(ann => ann.annotationType === 'custom');\n            if (customAnnotations.length > 0) {\n              console.log(`[自定义标注] 发现 ${customAnnotations.length} 个自定义标注，同步到CustomAnnotationManager`);\n              annotationTool.customAnnotationManager.syncAnnotationsFromKeypoints(image.id, customAnnotations);\n            }\n          }\n\n          // 🔧 FIX: 只有在开启自动移动时才移动视角到最高标记点\n          if (annotationTool.state.autoMoveToExpectedPosition) {\n            setTimeout(() => {\n              annotationTool.moveToHighestKeypoint();\n              console.log('[自动移动] 移动视角到最高标记点（auto-move已开启）');\n            }, 100); // 稍微延迟确保渲染完成\n          } else {\n            console.log('[自动移动] 跳过移动到最高标记点（auto-move已关闭）');\n          }\n        } else {\n          // 如果没有已有标注，清空标注工具\n          annotationTool.clearKeypoints();\n          console.log(`[标注] 图像 ${image.id} 无标注数据`);\n        }\n      } catch (error) {\n        console.warn('[标注] 加载标注数据失败:', error);\n        annotationTool.clearKeypoints();\n      }\n    } else {\n      console.error('AnnotationTool未初始化');\n      showError('标注工具错误', '标注工具未正确初始化，请刷新页面重试');\n    }\n    \n    // 更新分支点预览\n    if (branchPointPreviewManager && appState.currentPlant) {\n      try {\n        const images = await plantDataManager.getPlantImages(\n          appState.currentPlant.id, \n          appState.currentPlant.selectedViewAngle\n        );\n        const imageIndex = images.findIndex(img => img.id === image.id);\n        const currentKeypointCount = annotationTool ? annotationTool.keypoints.length : 0;\n        \n        await branchPointPreviewManager.updateContext(\n          appState.currentPlant.id,\n          appState.currentPlant.selectedViewAngle,\n          imageIndex,\n          currentKeypointCount\n        );\n      } catch (error) {\n        console.warn('更新分支点预览失败:', error);\n      }\n    }\n    \n    // 更新标注状态显示\n    await updateAnnotationStatusDisplay();\n\n    // 自动切换到预期位置（如果开启）\n    if (annotationTool) {\n      setTimeout(() => {\n        annotationTool.moveToExpectedPosition(isImageSwitch);\n      }, 100); // 稍微延迟确保渲染完成\n    }\n\n    console.log('图像选择完成');\n    \n  } catch (error) {\n    console.error('图像选择失败:', error);\n    showError('图像加载失败', error.message);\n  } finally {\n    // 🔧 FIX: Always unlock navigation to prevent permanent locks\n    appState.navigation.isNavigating = false;\n    console.log(`[Navigation] Navigation unlocked after processing ${image.name}`);\n  }\n}\n\n/**\n * 更新缩略图选择状态并滚动到对应位置\n */\nfunction updateImageThumbnailSelection(selectedImageId) {\n  // 清除所有选中状态\n  document.querySelectorAll('.image-thumbnail').forEach(thumb => {\n    thumb.classList.remove('selected');\n  });\n  \n  // 设置新的选中状态\n  const selectedThumb = document.querySelector(`[data-image-id=\"${selectedImageId}\"]`);\n  if (selectedThumb) {\n    selectedThumb.classList.add('selected');\n    \n    // 滚动到选中的缩略图\n    scrollToThumbnail(selectedThumb);\n  }\n}\n\n/**\n * 滚动到指定的缩略图，使其在视图垂直中央\n */\nfunction scrollToThumbnail(thumbnailElement) {\n  const container = document.getElementById('thumbnail-container');\n  if (!container || !thumbnailElement) return;\n  \n  try {\n    // 获取容器和缩略图的尺寸信息\n    const containerRect = container.getBoundingClientRect();\n    const thumbnailRect = thumbnailElement.getBoundingClientRect();\n    \n    // 计算需要滚动的距离，使缩略图在容器垂直中央\n    const containerScrollTop = container.scrollTop;\n    const thumbnailOffsetTop = thumbnailElement.offsetTop;\n    const containerHeight = containerRect.height;\n    const thumbnailHeight = thumbnailRect.height;\n    \n    // 计算目标滚动位置：缩略图中心对齐到容器中心\n    const targetScrollTop = thumbnailOffsetTop - (containerHeight / 2) + (thumbnailHeight / 2);\n    \n    // 平滑滚动到目标位置\n    container.scrollTo({\n      top: targetScrollTop,\n      behavior: 'smooth'\n    });\n    \n    console.log(`滚动到缩略图: ${thumbnailElement.dataset.imageId}`);\n    \n  } catch (error) {\n    console.warn('滚动到缩略图失败:', error);\n  }\n}\n\n/**\n * 更新标注状态显示\n */\nasync function updateAnnotationStatusDisplay() {\n  if (!appState.currentPlant || !appState.currentImage) {\n    hideAnnotationStatusDisplay();\n    return;\n  }\n\n  const statusSection = document.getElementById('annotation-status-section');\n  const currentImageIndex = document.getElementById('current-image-index');\n  const annotationSource = document.getElementById('annotation-source');\n  const timeSeriesStats = document.getElementById('time-series-stats');\n  const manualAdjustmentNotice = document.getElementById('manual-adjustment-notice');\n\n  if (!statusSection) return;\n\n  // 显示状态区域\n  statusSection.style.display = 'block';\n\n  try {\n    // 获取当前视角的所有图像\n    const images = await plantDataManager.getPlantImages(\n      appState.currentPlant.id, \n      appState.currentPlant.selectedViewAngle\n    );\n    \n    const currentIndex = images.findIndex(img => img.id === appState.currentImage.id);\n    \n    // 更新当前图像索引\n    currentImageIndex.textContent = currentIndex >= 0 ? \n      `${currentIndex + 1} / ${images.length}` : \n      '- / -';\n\n    // 检查当前图像是否有标注\n    const savedAnnotations = await plantDataManager.getImageAnnotations(appState.currentImage.id);\n    const hasAnnotations = savedAnnotations && savedAnnotations.length > 0;\n\n    // 更新标注来源\n    if (hasAnnotations) {\n      annotationSource.textContent = 'Document';\n    } else {\n      annotationSource.textContent = 'No annotation';\n    }\n\n    // 计算视角统计\n    let annotatedCount = 0;\n    for (const image of images) {\n      const imageAnnotations = await plantDataManager.getImageAnnotations(image.id);\n      if (imageAnnotations && imageAnnotations.length > 0) {\n        annotatedCount++;\n      }\n    }\n    \n    const coverage = images.length > 0 ? Math.round((annotatedCount / images.length) * 100) : 0;\n    timeSeriesStats.textContent = `${annotatedCount}/${images.length} (${coverage}%)`;\n\n    // 隐藏微调模式通知（新方案不需要）\n    manualAdjustmentNotice.style.display = 'none';\n    \n  } catch (error) {\n    console.error('更新标注状态显示失败:', error);\n    hideAnnotationStatusDisplay();\n  }\n}\n\n/**\n * 隐藏标注状态显示\n */\nfunction hideAnnotationStatusDisplay() {\n  const statusSection = document.getElementById('annotation-status-section');\n  const manualAdjustmentNotice = document.getElementById('manual-adjustment-notice');\n\n  if (statusSection) statusSection.style.display = 'none';\n  if (manualAdjustmentNotice) manualAdjustmentNotice.style.display = 'none';\n}\n\n/**\n * 处理保存标注 - 显示模态框\n */\nasync function handleSaveAnnotation() {\n  if (!annotationTool || !appState.currentPlant) {\n    showError('保存失败', '请先选择植物和图像');\n    return;\n  }\n  \n  const annotationData = annotationTool.getAnnotationData();\n  \n  if (annotationData.keypoints.length === 0) {\n    showError('保存失败', '请先添加标注点');\n    return;\n  }\n  \n  // 显示保存确认模态框\n  showSaveAnnotationModal();\n}\n\n/**\n * 显示保存标注模态框\n */\nfunction showSaveAnnotationModal() {\n  const modal = document.getElementById('save-annotation-modal');\n  if (modal) {\n    modal.style.display = 'flex';\n  }\n}\n\n/**\n * 隐藏保存标注模态框\n */\nfunction hideSaveAnnotationModal() {\n  const modal = document.getElementById('save-annotation-modal');\n  if (modal) {\n    modal.style.display = 'none';\n  }\n}\n\n/**\n * 执行实际的保存操作\n */\nasync function performSaveAnnotation(isManualAdjustment) {\n  if (!annotationTool || !appState.currentPlant) {\n    showError('保存失败', '请先选择植物和图像');\n    return;\n  }\n  \n  try {\n    const annotationData = annotationTool.getAnnotationData();\n    \n    if (annotationData.keypoints.length === 0) {\n      showError('保存失败', '请先添加标注点');\n      return;\n    }\n    \n    // 获取方向保存模式\n    const directionSaveMode = document.querySelector('input[name=\"direction-save-mode\"]:checked');\n    const saveDirectionsOnly = directionSaveMode && directionSaveMode.value === 'directions-only';\n    \n    // 保存标注数据\n    const saveResult = await plantDataManager.savePlantAnnotations(\n      appState.currentPlant.id, \n      annotationData.keypoints, \n      isManualAdjustment,\n      { saveDirectionsOnly } // 传递方向保存选项\n    );\n    \n    updateProgressInfo(saveResult.message || `已保存 ${annotationData.keypoints.length} 个标注点`);\n    \n    // 更新状态显示\n    updateAnnotationStatusDisplay();\n    \n    // 更新统计显示\n    updateProgressStats();\n    \n    // 更新分支点预览（重新计算标注点数量）\n    if (branchPointPreviewManager && appState.currentPlant && appState.currentImage) {\n      const images = await plantDataManager.getPlantImages(\n        appState.currentPlant.id, \n        appState.currentPlant.selectedViewAngle\n      );\n      const imageIndex = images.findIndex(img => img.id === appState.currentImage.id);\n      const currentAnnotations = await plantDataManager.getImageAnnotations(appState.currentImage.id);\n      const currentKeypointCount = currentAnnotations ? currentAnnotations.length : 0;\n      \n      await branchPointPreviewManager.updateContext(\n        appState.currentPlant.id,\n        appState.currentPlant.selectedViewAngle,\n        imageIndex,\n        currentKeypointCount\n      );\n    }\n    \n    console.log('标注数据已保存到持久化存储');\n    \n    // 🔧 FIX: 立即刷新当前图像的缩略图标注状态\n    if (appState.currentImage) {\n      await refreshThumbnailAnnotationStatus(appState.currentImage.id);\n      console.log('缩略图标注状态已刷新');\n    }\n    \n    // 🔧 FIX: 如果是传播保存，刷新所有受影响的缩略图\n    if (!isManualAdjustment && saveResult.affectedImages && saveResult.affectedImages.length > 0) {\n      console.log(`刷新 ${saveResult.affectedImages.length} 个受影响图像的缩略图状态`);\n      for (const imageId of saveResult.affectedImages) {\n        await refreshThumbnailAnnotationStatus(imageId);\n      }\n    }\n    \n    // 🔧 FIX: 刷新植物笔记徽章（标注可能影响笔记统计）\n    if (window.PlantAnnotationTool?.noteUI && appState.currentPlant) {\n      await window.PlantAnnotationTool.noteUI.updatePlantNoteBadge(appState.currentPlant.id);\n      console.log('植物笔记徽章已刷新');\n    }\n    \n    // 隐藏模态框\n    hideSaveAnnotationModal();\n    \n  } catch (error) {\n    console.error('保存标注失败:', error);\n    showError('保存失败', `保存标注数据时出错: ${error.message}`);\n  }\n}\n\n/**\n * 🔧 NEW: 处理完成/撤销完成植物 (统一处理函数)\n */\nfunction handleCompletePlant() {\n  if (!appState.currentPlant) {\n    showError('操作失败', '请先选择植物');\n    return;\n  }\n  \n  const plant = appState.currentPlant;\n  \n  // 根据当前状态决定操作\n  if (plant.status === 'completed') {\n    // 如果已完成，则撤销完成\n    showUncompletePlantModal(plant.id);\n  } else {\n    // 如果未完成，则完成植物\n    if (plant.status === 'skipped') {\n      showError('操作错误', '无法完成已跳过的植株，请先撤销跳过');\n      return;\n    }\n    \n    const confirmMessage = `确定要标记植株 \"${plant.id}\" 为已完成吗？`;\n    \n    if (!confirm(confirmMessage)) {\n      return;\n    }\n    \n    try {\n      // 标记植物为已完成\n      plantDataManager.updatePlantStatus(plant.id, 'completed');\n      plant.status = 'completed';\n      \n      // 重新渲染植株列表项\n      const plantItem = document.querySelector(`[data-plant-id=\"${plant.id}\"]`);\n      if (plantItem) {\n        const newItem = createPlantListItem(plant);\n        plantItem.parentNode.replaceChild(newItem, plantItem);\n        \n        // 🔧 FIX: Update note badge for the re-rendered plant item\n        if (window.PlantAnnotationTool?.noteUI) {\n          setTimeout(() => {\n            window.PlantAnnotationTool.noteUI.updatePlantNoteBadge(plant.id);\n          }, 100);\n        }\n      }\n      \n      // 更新统计显示\n      updateProgressStats();\n      \n      // 更新按钮状态\n      updateCompletePlantButtonState();\n      \n      showSuccess('完成成功', `植株 ${plant.id} 已标记为完成`);\n      \n      // 查找下一个未完成的植物\n      const nextPlant = plantDataManager.getNextPendingPlant(plant.id);\n      \n      if (nextPlant) {\n        // 询问是否跳转到下一个植物\n        const shouldNavigate = confirm(`植株 ${plant.id} 已完成！\\n\\n是否跳转到下一个未完成的植株 ${nextPlant.id}？`);\n        if (shouldNavigate) {\n          handlePlantSelect(nextPlant);\n          updateProgressInfo(`已完成 ${plant.id}，跳转到 ${nextPlant.id}`);\n        }\n      } else {\n        updateProgressInfo('恭喜！所有植物都已完成标注');\n      }\n      \n    } catch (error) {\n      console.error('完成植物失败:', error);\n      showError('操作失败', error.message);\n    }\n  }\n}\n\n/**\n * 处理导出数据\n */\nasync function handleExportData() {\n  if (!plantDataManager) {\n    showError('导出失败', '请先加载数据集');\n    return;\n  }\n  \n  try {\n    // 显示导出格式选择\n    await showExportOptionsModal();\n    \n  } catch (error) {\n    console.error('导出数据失败:', error);\n    showError('导出失败', error.message);\n  }\n}\n\n/**\n * 显示导出选项模态框\n */\nasync function showExportOptionsModal() {\n  // Create modal HTML\n  const modalHTML = `\n    <div id=\"export-modal\" class=\"modal\" style=\"display: flex;\">\n      <div class=\"modal-content\" style=\"max-width: 600px; max-height: 90vh; overflow-y: auto;\">\n        <h3>Export Annotation Data</h3>\n\n        <!-- Statistics Area -->\n        <div id=\"export-stats\" style=\"background: #f9fafb; padding: 15px; border-radius: 8px; margin: 20px 0; font-size: 14px;\">\n          <div style=\"font-weight: 600; margin-bottom: 10px;\">Data Statistics:</div>\n          <div id=\"stats-content\">Loading...</div>\n        </div>\n\n        <!-- Preview Area -->\n        <div style=\"margin: 20px 0;\">\n          <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h4 style=\"margin: 0;\">Export Data Preview</h4>\n            <button id=\"refresh-preview-btn\" class=\"btn btn-secondary\" style=\"padding: 5px 15px; font-size: 14px;\">Refresh Preview</button>\n          </div>\n          <div id=\"export-preview\" style=\"background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; max-height: 400px; overflow-y: auto;\">\n            Generating preview...\n          </div>\n        </div>\n\n        <div style=\"display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;\">\n          <button id=\"export-cancel-btn\" class=\"btn btn-secondary\">Cancel</button>\n          <button id=\"export-confirm-btn\" class=\"btn btn-primary\">Confirm Export</button>\n        </div>\n      </div>\n    </div>\n  `;\n  \n  // 移除已存在的模态框\n  const existingModal = document.getElementById('export-modal');\n  if (existingModal) {\n    existingModal.remove();\n  }\n  \n  // 添加到body\n  document.body.insertAdjacentHTML('beforeend', modalHTML);\n  \n  // 获取统计信息并显示\n  await updateExportStats();\n\n  // 生成导出预览\n  await generateExportPreview();\n\n  // 绑定事件\n  document.getElementById('export-cancel-btn').addEventListener('click', () => {\n    document.getElementById('export-modal').remove();\n  });\n\n  document.getElementById('export-confirm-btn').addEventListener('click', async () => {\n    document.getElementById('export-modal').remove();\n    await performExport();\n  });\n\n  document.getElementById('refresh-preview-btn').addEventListener('click', async () => {\n    await generateExportPreview();\n  });\n}\n\n/**\n * 更新导出统计信息\n */\nasync function updateExportStats() {\n  const statsContent = document.getElementById('stats-content');\n  if (!statsContent) return;\n\n  try {\n    // 直接从文件系统获取标注数据统计\n    const exportData = await getDirectExportData();\n    const stats = calculateExportStats(exportData);\n\n    const html = `\n      <div>📊 Annotated Images: <strong>${stats.annotatedImages}</strong></div>\n      <div>🎯 Total Keypoints: <strong>${stats.totalKeypoints}</strong></div>\n      <div>📈 Average per Image: <strong>${stats.averageKeypointsPerImage}</strong> keypoints</div>\n      <div style=\"margin-top: 10px; color: #059669;\">✅ Pure annotation data, ready for data analysis</div>\n      <div style=\"color: #059669;\">✅ Includes all annotated images and skipped plant information</div>\n    `;\n\n    statsContent.innerHTML = html;\n  } catch (error) {\n    console.error('Failed to get export statistics:', error);\n    statsContent.innerHTML = '<div style=\"color: #dc2626;\">Failed to load statistics, please check console</div>';\n  }\n}\n\n/**\n * 执行导出\n */\nasync function performExport() {\n  try {\n    // 获取纯净的标注数据\n    const exportData = await getDirectExportData();\n    const stats = calculateExportStats(exportData);\n\n    if (stats.annotatedImages === 0) {\n      showError('Export Failed', 'No annotation data available for export');\n      return;\n    }\n\n    // 创建导出数据结构\n    const finalExportData = {\n      exportTime: new Date().toISOString(),\n      version: '3.0',\n      format: 'pure_annotations',\n      description: 'Pure annotation data, including image annotations and skipped plant information',\n      stats: {\n        annotatedImages: stats.annotatedImages,\n        totalKeypoints: stats.totalKeypoints,\n        averageKeypointsPerImage: stats.averageKeypointsPerImage,\n        skippedPlants: stats.skippedPlants\n      },\n      annotations: exportData.annotations,\n      skippedPlants: exportData.skippedPlants\n    };\n\n    // 下载文件\n    const blob = new Blob([JSON.stringify(finalExportData, null, 2)], {\n      type: 'application/json'\n    });\n\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `annotations_${new Date().toISOString().split('T')[0]}.json`;\n\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n\n    URL.revokeObjectURL(url);\n\n    const message = `Exported annotation data for ${stats.annotatedImages} images with ${stats.totalKeypoints} keypoints`;\n    updateProgressInfo(message);\n    console.log('Annotation data exported', finalExportData);\n\n  } catch (error) {\n    console.error('Failed to export data:', error);\n    showError('Export Failed', error.message);\n  }\n}\n\n/**\n * 直接从文件系统获取导出数据\n */\nasync function getDirectExportData() {\n  const exportData = {\n    annotations: {},\n    skippedPlants: {}\n  };\n\n  if (!plantDataManager || !plantDataManager.annotationStorage) {\n    throw new Error('数据管理器未初始化');\n  }\n\n  const annotationStorage = plantDataManager.annotationStorage;\n\n  // 获取所有标注文件\n  if (annotationStorage.useFileSystem && annotationStorage.fileSystemManager) {\n    const annotationsHandle = annotationStorage.fileSystemManager.getAnnotationsDirectory();\n    if (!annotationsHandle) {\n      throw new Error('无法访问标注目录');\n    }\n\n    // 扫描所有文件\n    for await (const [name, handle] of annotationsHandle.entries()) {\n      if (handle.kind === 'file' && name.endsWith('.json')) {\n        try {\n          const file = await handle.getFile();\n          const content = await file.text();\n          const data = JSON.parse(content);\n\n          if (name.endsWith('_skip_info.json')) {\n            // 跳过信息文件\n            const plantId = name.replace('_skip_info.json', '');\n            exportData.skippedPlants[plantId] = {\n              plantId: data.plantId,\n              skipReason: data.skipReason,\n              skipDate: data.skipDate,\n              status: data.status\n            };\n          } else {\n            // 标注文件\n            const imageId = name.replace('.json', '');\n            if (data.annotations && data.annotations.length > 0) {\n              // 如果没有plantId，尝试从imageId推断\n              const plantId = data.plantId || inferPlantIdFromImageId(imageId);\n\n              exportData.annotations[imageId] = {\n                imageId: data.imageId || imageId,\n                plantId: plantId,\n                annotations: data.annotations,\n                timestamp: data.timestamp,\n                version: data.version\n              };\n            }\n          }\n        } catch (error) {\n          console.warn(`读取文件失败 (${name}):`, error);\n        }\n      }\n    }\n  } else {\n    // 从内存中获取数据（兼容模式）\n    for (const [plantId, annotationData] of annotationStorage.annotations) {\n      if (annotationData.status === 'skipped') {\n        exportData.skippedPlants[plantId] = {\n          plantId,\n          skipReason: annotationData.skipReason,\n          skipDate: annotationData.skipDate,\n          status: annotationData.status\n        };\n      }\n    }\n\n    // 获取图像标注数据\n    for (const [imageId, annotationData] of annotationStorage.imageAnnotations) {\n      if (annotationData.annotations && annotationData.annotations.length > 0) {\n        exportData.annotations[imageId] = {\n          imageId,\n          plantId: annotationData.plantId,\n          annotations: annotationData.annotations,\n          timestamp: annotationData.timestamp,\n          version: annotationData.version\n        };\n      }\n    }\n  }\n\n  return exportData;\n}\n\n/**\n * 计算导出数据统计\n */\nfunction calculateExportStats(exportData) {\n  const annotatedImages = Object.keys(exportData.annotations).length;\n  const skippedPlants = Object.keys(exportData.skippedPlants).length;\n\n  let totalKeypoints = 0;\n  for (const imageData of Object.values(exportData.annotations)) {\n    totalKeypoints += imageData.annotations.length;\n  }\n\n  const averageKeypointsPerImage = annotatedImages > 0 ?\n    (totalKeypoints / annotatedImages).toFixed(1) : '0';\n\n  return {\n    annotatedImages,\n    totalKeypoints,\n    averageKeypointsPerImage,\n    skippedPlants\n  };\n}\n\n/**\n * 处理植物更新事件\n */\nfunction handlePlantUpdated(event) {\n  const { plant } = event.detail;\n  \n  // 更新列表中的植物项\n  const plantItem = document.querySelector(`[data-plant-id=\"${plant.id}\"]`);\n  if (plantItem) {\n    // 更新状态图标\n    const statusElement = plantItem.querySelector('.plant-status');\n    if (statusElement) {\n      statusElement.textContent = getStatusIcon(plant.status);\n    }\n    \n    // 更新状态文本\n    const statusTextElement = plantItem.querySelector('.status-text');\n    if (statusTextElement) {\n      statusTextElement.textContent = getStatusText(plant.status);\n    }\n    \n    // 更新图像数量\n    const imageCountElement = plantItem.querySelector('.image-count');\n    if (imageCountElement && plant.imageCount > 0) {\n      imageCountElement.textContent = `${plant.imageCount} images`;\n    }\n    \n    // 更新视角信息\n    const viewAnglesElement = plantItem.querySelector('.view-angles');\n    if (viewAnglesElement) {\n      const viewAnglesText = plant.viewAngles.length > 0 ? \n        `view: ${plant.viewAngles.join(', ')}` :\n        'view: detecting...';\n      viewAnglesElement.textContent = viewAnglesText;\n    }\n    \n    // 更新选中视角信息\n    const plantViewInfo = plantItem.querySelector('.plant-view-info');\n    if (plantViewInfo) {\n      let selectedViewElement = plantViewInfo.querySelector('.selected-view');\n      if (plant.selectedViewAngle) {\n        if (!selectedViewElement) {\n          selectedViewElement = document.createElement('div');\n          selectedViewElement.className = 'selected-view';\n          plantViewInfo.appendChild(selectedViewElement);\n        }\n        selectedViewElement.textContent = `Choosed: ${plant.selectedViewAngle}`;\n      } else if (selectedViewElement) {\n        selectedViewElement.remove();\n      }\n    }\n  }\n  \n  // 更新统计显示\n  updateProgressStats();\n  \n  // 更新旧的进度信息\n  const progress = plantDataManager.getProgress();\n  updateProgressInfo(`Progress: ${progress.completed}/${progress.total} (${progress.completionRate}%)`);\n}\n\n/**\n * 键盘快捷键处理\n */\nfunction handleKeyboardShortcuts(event) {\n  // 全局快捷键\n  if (event.ctrlKey || event.metaKey) {\n    switch (event.key) {\n      case 'o':\n        event.preventDefault();\n        handleSelectDataset();\n        break;\n      case 's':\n        event.preventDefault();\n        handleSaveAnnotation();\n        break;\n    }\n  }\n  \n  // 🔧 NEW: SIFT匹配快捷键 (Shift+S)\n  if (event.shiftKey && event.key.toLowerCase() === 's') {\n    event.preventDefault();\n    handleSiftMatch();\n    return;\n  }\n  \n  // 应用快捷键（仅在主应用显示时）\n  if (mainApp && mainApp.style.display !== 'none') {\n    switch (event.key) {\n      case 'Enter':\n        event.preventDefault();\n        handleCompletePlant();\n        break;\n      case 'ArrowLeft':\n        event.preventDefault();\n        // 🔧 FIX: Add navigation state feedback\n        if (appState.navigation.isNavigating) {\n          console.log('[Navigation] Previous image blocked - navigation in progress');\n        } else {\n          navigateToPreviousImage();\n        }\n        break;\n      case 'ArrowRight':\n        event.preventDefault();\n        // 🔧 FIX: Add navigation state feedback\n        if (appState.navigation.isNavigating) {\n          console.log('[Navigation] Next image blocked - navigation in progress');\n        } else {\n          navigateToNextImage();\n        }\n        break;\n    }\n  }\n}\n\n/**\n * 模拟加载过程\n */\nasync function simulateLoading() {\n  const loadingTexts = [\n    '正在初始化标注工具...',\n    '检查浏览器兼容性...',\n    '加载组件模块...',\n    '准备用户界面...'\n  ];\n  \n  const loadingP = loadingScreen.querySelector('p');\n  \n  for (const text of loadingTexts) {\n    loadingP.textContent = text;\n    await new Promise(resolve => setTimeout(resolve, 300));\n  }\n}\n\n/**\n * 显示主应用界面\n */\nfunction showMainApp() {\n  loadingScreen.style.display = 'none';\n  mainApp.style.display = 'flex';\n  \n  // 确保界面完全渲染后再检查和初始化AnnotationTool\n  setTimeout(() => {\n    if (!annotationTool) {\n      try {\n        console.log('[调试] 在showMainApp中延迟初始化AnnotationTool');\n        annotationTool = new AnnotationTool('annotation-canvas');\n        window.PlantAnnotationTool.annotationTool = annotationTool;\n        console.log('AnnotationTool延迟初始化完成');\n      } catch (error) {\n        console.error('延迟初始化AnnotationTool失败:', error);\n      }\n    } else {\n      console.log('[调试] AnnotationTool已存在，跳过延迟初始化，调整Canvas尺寸');\n      // 如果已经初始化，强制重新调整Canvas尺寸\n      annotationTool.resizeCanvas();\n    }\n    \n    // 确保分支点预览管理器已初始化\n    if (!branchPointPreviewManager) {\n      try {\n        branchPointPreviewManager = new BranchPointPreviewManager();\n        branchPointPreviewManager.setPlantDataManager(plantDataManager);\n        window.PlantAnnotationTool.branchPointPreviewManager = branchPointPreviewManager;\n        console.log('BranchPointPreviewManager延迟初始化完成');\n      } catch (error) {\n        console.error('延迟初始化BranchPointPreviewManager失败:', error);\n      }\n    }\n  }, 300);\n}\n\n/**\n * 更新进度信息\n */\nfunction updateProgressInfo(text) {\n  const progressText = document.getElementById('progress-text');\n  if (progressText) {\n    progressText.textContent = text;\n  }\n}\n\n/**\n * 显示错误信息\n */\nfunction showError(title, message) {\n  const errorMessage = document.getElementById('error-message');\n  if (errorMessage && errorModal) {\n    errorMessage.textContent = message;\n    errorModal.style.display = 'flex';\n  }\n  console.error(`${title}: ${message}`);\n}\n\n/**\n * 隐藏错误信息\n */\nfunction hideError() {\n  if (errorModal) {\n    errorModal.style.display = 'none';\n  }\n}\n\n/**\n * 显示成功信息\n */\nfunction showSuccess(title, message) {\n  // 使用updateProgressInfo显示成功消息\n  updateProgressInfo(`✅ ${title}: ${message}`);\n  console.log(`${title}: ${message}`);\n}\n\n/**\n * 应用入口点\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n  console.log('DOM加载完成，开始初始化应用...');\n  initializeApp();\n});\n\n// 开发环境调试\nif (import.meta.env?.DEV) {\n  window.DEBUG_APP_STATE = appState;\n  window.DEBUG_PLANT_MANAGER = () => window.PlantAnnotationTool?.plantDataManager;\n  window.DEBUG_ANNOTATION_TOOL = () => window.PlantAnnotationTool?.annotationTool;\n  \n  // 添加时间序列导出调试功能\n  window.DEBUG_TIME_SERIES_EXPORT = async () => {\n    const plantManager = window.PlantAnnotationTool?.plantDataManager;\n    if (plantManager) {\n      return await plantManager.debugTimeSeriesExport();\n    } else {\n      console.error('PlantDataManager未初始化');\n      return null;\n    }\n  };\n  \n  // 添加立即导出纯净数据的调试功能\n  window.DEBUG_EXPORT_PURE = async () => {\n    const plantManager = window.PlantAnnotationTool?.plantDataManager;\n    if (plantManager) {\n      const pureData = await plantManager.exportPureImageAnnotations();\n      console.log('调试：纯净导出数据', pureData);\n      return pureData;\n    } else {\n      console.error('PlantDataManager未初始化');\n      return null;\n    }\n  };\n  \n  // 临时修复脚本：为传统标注数据添加序号字段\n  window.fixLegacyDataOrder = async function() {\n    console.log('=== 开始修复传统数据的序号字段 ===');\n    \n    try {\n      // 获取植物数据管理器和存储管理器\n      const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n      if (!plantDataManager) {\n        throw new Error('植物数据管理器未初始化，请先加载数据集');\n      }\n      \n      const annotationStorage = plantDataManager.annotationStorage;\n      if (!annotationStorage) {\n        throw new Error('标注存储管理器未找到');\n      }\n      \n      console.log('正在扫描图像标注数据...');\n      \n      let processedImages = 0;\n      let fixedAnnotations = 0;\n      let totalAnnotations = 0;\n      \n      // 处理imageAnnotations中的数据\n      for (const [imageId, annotationData] of annotationStorage.imageAnnotations) {\n        if (annotationData.annotations && annotationData.annotations.length > 0) {\n          processedImages++;\n          \n          let hasOrderIssues = false;\n          const annotations = annotationData.annotations;\n          totalAnnotations += annotations.length;\n          \n          // 检查是否有标注点没有序号\n          for (let i = 0; i < annotations.length; i++) {\n            if (typeof annotations[i].order !== 'number' || annotations[i].order <= 0) {\n              hasOrderIssues = true;\n              break;\n            }\n          }\n          \n          // 检查序号是否重复或不连续\n          if (!hasOrderIssues) {\n            const orders = annotations.map(kp => kp.order).sort((a, b) => a - b);\n            for (let i = 0; i < orders.length; i++) {\n              if (orders[i] !== i + 1) {\n                hasOrderIssues = true;\n                break;\n              }\n            }\n          }\n          \n          // 如果有问题，修复序号\n          if (hasOrderIssues) {\n            console.log(`修复图像 ${imageId} 的 ${annotations.length} 个标注点的序号...`);\n            \n            // 按照原有顺序分配序号（保持传统数据的顺序不变）\n            for (let i = 0; i < annotations.length; i++) {\n              annotations[i].order = i + 1;\n            }\n            \n            fixedAnnotations += annotations.length;\n            \n            // 重新保存到存储\n            await annotationStorage.saveImageAnnotation(imageId, annotationData);\n            \n            console.log(`✓ 已修复图像 ${imageId}：分配序号 1-${annotations.length}`);\n          }\n        }\n      }\n      \n      // 处理植物标注数据中的annotations字段\n      console.log('正在扫描植物标注数据...');\n      \n      let processedPlants = 0;\n      let fixedPlantAnnotations = 0;\n      \n      for (const [plantId, plantData] of annotationStorage.annotations) {\n        if (plantData.annotations && plantData.annotations.length > 0) {\n          processedPlants++;\n          \n          let hasOrderIssues = false;\n          const annotations = plantData.annotations;\n          \n          // 检查是否有标注点没有序号\n          for (let i = 0; i < annotations.length; i++) {\n            if (typeof annotations[i].order !== 'number' || annotations[i].order <= 0) {\n              hasOrderIssues = true;\n              break;\n            }\n          }\n          \n          // 检查序号是否重复或不连续\n          if (!hasOrderIssues) {\n            const orders = annotations.map(kp => kp.order).sort((a, b) => a - b);\n            for (let i = 0; i < orders.length; i++) {\n              if (orders[i] !== i + 1) {\n                hasOrderIssues = true;\n                break;\n              }\n            }\n          }\n          \n          // 如果有问题，修复序号\n          if (hasOrderIssues) {\n            console.log(`修复植物 ${plantId} 的 ${annotations.length} 个标注点的序号...`);\n            \n            // 按照原有顺序分配序号\n            for (let i = 0; i < annotations.length; i++) {\n              annotations[i].order = i + 1;\n            }\n            \n            fixedPlantAnnotations += annotations.length;\n            \n            console.log(`✓ 已修复植物 ${plantId}：分配序号 1-${annotations.length}`);\n          }\n        }\n      }\n      \n      // 保存所有修改到服务器\n      if (fixedAnnotations > 0 || fixedPlantAnnotations > 0) {\n        console.log('正在保存修复的数据到服务器...');\n        await annotationStorage.saveAnnotationsToServer();\n        console.log('✓ 所有修复的数据已保存');\n      }\n      \n      // 输出修复结果\n      console.log('=== 修复完成 ===');\n      console.log(`扫描了 ${processedImages} 张图像的标注数据`);\n      console.log(`扫描了 ${processedPlants} 个植物的标注数据`);\n      console.log(`总计 ${totalAnnotations} 个标注点`);\n      console.log(`修复了 ${fixedAnnotations} 个图像标注点的序号`);\n      console.log(`修复了 ${fixedPlantAnnotations} 个植物标注点的序号`);\n      \n      if (fixedAnnotations === 0 && fixedPlantAnnotations === 0) {\n        console.log('✅ 所有数据的序号都是正确的，无需修复');\n      } else {\n        console.log(`✅ 已成功修复 ${fixedAnnotations + fixedPlantAnnotations} 个标注点的序号`);\n      }\n      \n      // 建议用户重新加载页面以确保数据生效\n      if (fixedAnnotations > 0 || fixedPlantAnnotations > 0) {\n        console.log('💡 建议重新加载页面以确保修复的数据完全生效');\n      }\n      \n      return {\n        success: true,\n        processedImages,\n        processedPlants,\n        totalAnnotations,\n        fixedAnnotations,\n        fixedPlantAnnotations,\n        totalFixed: fixedAnnotations + fixedPlantAnnotations\n      };\n      \n    } catch (error) {\n      console.error('修复传统数据失败:', error);\n      console.log('❌ 修复过程中发生错误，请检查控制台输出');\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n  \n  // 调试标注文件读取\n  window.DEBUG_ANNOTATION_FILE = async (imageId) => {\n    if (plantDataManager && plantDataManager.fileSystemManager) {\n      try {\n        console.log(`[调试] 尝试读取标注文件: ${imageId}`);\n        const data = await plantDataManager.fileSystemManager.loadAnnotationFile(imageId);\n        console.log(`[调试] 标注文件内容:`, data);\n        return data;\n      } catch (error) {\n        console.error(`[调试] 读取失败:`, error);\n        return null;\n      }\n    }\n    return null;\n  };\n\n  // 调试：查找有标注数据的文件\n  window.DEBUG_FIND_ANNOTATED_FILES = async (maxCheck = 10) => {\n    if (plantDataManager && plantDataManager.fileSystemManager) {\n      try {\n        const allFiles = await plantDataManager.fileSystemManager.getAllAnnotationFiles();\n        console.log(`[调试] 总共 ${allFiles.length} 个标注文件，检查前 ${maxCheck} 个...`);\n\n        const annotatedFiles = [];\n        for (let i = 0; i < Math.min(maxCheck, allFiles.length); i++) {\n          const imageId = allFiles[i];\n          const data = await plantDataManager.fileSystemManager.loadAnnotationFile(imageId);\n          if (data && data.annotations && data.annotations.length > 0) {\n            annotatedFiles.push({\n              imageId,\n              annotationCount: data.annotations.length,\n              data\n            });\n            console.log(`[调试] 找到有标注的文件: ${imageId} (${data.annotations.length} 个标注点)`);\n          }\n        }\n\n        console.log(`[调试] 检查完成，找到 ${annotatedFiles.length} 个有标注数据的文件`);\n        return annotatedFiles;\n      } catch (error) {\n        console.error(`[调试] 查找失败:`, error);\n        return [];\n      }\n    }\n    return [];\n  };\n\n  console.log('开发模式：调试对象已绑定到window');\n  console.log('可用调试方法:');\n  console.log('- DEBUG_TIME_SERIES_EXPORT() - 检查时间序列导出状态');\n  console.log('- DEBUG_EXPORT_PURE() - 检查纯净导出数据');\n  console.log('- DEBUG_ANNOTATION_FILE(imageId) - 调试标注文件读取');\n  console.log('- DEBUG_FIND_ANNOTATED_FILES(maxCheck) - 查找有标注数据的文件');\n  console.log('- fixLegacyDataOrder() - 修复传统数据的序号字段');\n  console.log('- MIGRATE_PLANT_STATUS() - 🔧 NEW: 迁移植物完成状态数据');\n  \n  // 🔧 NEW: Migration script for plant completion status\n  window.MIGRATE_PLANT_STATUS = async function() {\n    console.log('=== 开始迁移植物完成状态数据 ===');\n    \n    try {\n      const plantDataManager = window.PlantAnnotationTool?.plantDataManager;\n      if (!plantDataManager) {\n        throw new Error('PlantDataManager未初始化，请先加载数据集');\n      }\n      \n      console.log('正在扫描所有植物状态...');\n      \n      const plants = plantDataManager.getPlantList();\n      let migratedCount = 0;\n      let alreadyCorrectCount = 0;\n      \n      for (const plant of plants) {\n        const plantId = plant.id;\n        console.log(`检查植物 ${plantId}，当前状态: ${plant.status}`);\n        \n        // Skip already skipped plants\n        if (plant.status === 'skipped') {\n          console.log(`${plantId}: 保持跳过状态`);\n          alreadyCorrectCount++;\n          continue;\n        }\n        \n        // Check if plant has annotations\n        let hasAnnotations = false;\n        try {\n          const annotations = plantDataManager.getPlantAnnotations(plantId);\n          hasAnnotations = annotations && annotations.length > 0;\n        } catch (error) {\n          console.warn(`无法检查 ${plantId} 的标注:`, error);\n        }\n        \n        let newStatus;\n        if (hasAnnotations && plant.status === 'completed') {\n          // 🔧 MIGRATION LOGIC: Plants with annotations that were auto-marked as completed\n          // should be set to 'completed' to maintain existing user expectations\n          newStatus = 'completed';\n          console.log(`${plantId}: 有标注且已标记完成 → 保持 completed 状态 (迁移兼容)`);\n          alreadyCorrectCount++;\n        } else if (hasAnnotations && plant.status !== 'completed') {\n          // Plants with annotations but not explicitly completed should be in-progress\n          newStatus = 'in-progress';\n          plantDataManager.updatePlantStatus(plantId, newStatus);\n          console.log(`${plantId}: 有标注但未明确完成 → 设置为 in-progress`);\n          migratedCount++;\n        } else if (!hasAnnotations) {\n          // Plants without annotations should be pending\n          newStatus = 'pending';\n          if (plant.status !== 'pending') {\n            plantDataManager.updatePlantStatus(plantId, newStatus);\n            console.log(`${plantId}: 无标注 → 设置为 pending`);\n            migratedCount++;\n          } else {\n            alreadyCorrectCount++;\n          }\n        } else {\n          alreadyCorrectCount++;\n        }\n      }\n      \n      console.log('=== 迁移完成 ===');\n      console.log(`总计扫描 ${plants.length} 个植物`);\n      console.log(`迁移了 ${migratedCount} 个植物的状态`);\n      console.log(`${alreadyCorrectCount} 个植物状态已正确`);\n      \n      // Refresh UI to show updated status\n      if (renderPlantList && typeof renderPlantList === 'function') {\n        renderPlantList(plants);\n        console.log('UI已刷新以显示新状态');\n      }\n      \n      if (updateProgressStats && typeof updateProgressStats === 'function') {\n        updateProgressStats();\n        console.log('进度统计已更新');\n      }\n      \n      console.log('💡 现在，只有点击 \"Complete Plant\" 按钮的植物才会标记为 completed');\n      console.log('💡 有标注但未点击完成按钮的植物显示为 in-progress');\n      \n      return {\n        success: true,\n        totalPlants: plants.length,\n        migratedCount,\n        alreadyCorrectCount\n      };\n      \n    } catch (error) {\n      console.error('迁移植物状态失败:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n}\n\n/**\n * 生成导出数据预览\n */\nasync function generateExportPreview() {\n  const previewContainer = document.getElementById('export-preview');\n  if (!previewContainer) return;\n\n  try {\n    previewContainer.innerHTML = '正在生成预览...';\n\n    // 获取导出数据\n    const exportData = await getDirectExportData();\n\n    if (Object.keys(exportData.annotations).length === 0 && Object.keys(exportData.skippedPlants).length === 0) {\n      previewContainer.innerHTML = '<div style=\"color: #6b7280; text-align: center; padding: 20px;\">No annotation data available</div>';\n      return;\n    }\n\n    // 生成预览HTML\n    const previewHTML = generateSimplePreviewHTML(exportData);\n    previewContainer.innerHTML = previewHTML;\n\n    // 绑定展开/折叠事件\n    bindPreviewEvents();\n\n  } catch (error) {\n    console.error('Failed to generate export preview:', error);\n    previewContainer.innerHTML = '<div style=\"color: #dc2626;\">Failed to generate preview, please check console</div>';\n  }\n}\n\n/**\n * 从图像ID推断植株ID\n */\nfunction inferPlantIdFromImageId(imageId) {\n  // 图像ID格式通常是: BR017-028122_sv-000_BR017-028122-2018-07-04_00_VIS_sv_000-0-0-0.png\n  // 植株ID通常是: BR017-028122\n\n  if (imageId.includes('_')) {\n    const parts = imageId.split('_');\n    if (parts.length > 0) {\n      // 取第一部分作为植株ID\n      return parts[0];\n    }\n  }\n\n  // 如果无法解析，尝试从文件名中提取\n  if (imageId.includes('-')) {\n    const parts = imageId.split('-');\n    if (parts.length >= 2) {\n      // 组合前两部分作为植株ID (如 BR017-028122)\n      return `${parts[0]}-${parts[1]}`;\n    }\n  }\n\n  // 最后的备选方案：返回原始imageId的前缀\n  return imageId.split('.')[0].split('_')[0];\n}\n\n/**\n * 生成简化的预览HTML\n */\nfunction generateSimplePreviewHTML(exportData) {\n  let html = '';\n\n  // Display annotation data\n  const annotationCount = Object.keys(exportData.annotations).length;\n  if (annotationCount > 0) {\n    html += `\n      <div style=\"margin-bottom: 20px;\">\n        <div style=\"font-weight: 600; margin-bottom: 10px; color: #374151;\">\n          📊 Annotation Data (${annotationCount} images)\n        </div>\n        <div style=\"max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 4px; padding: 10px;\">\n    `;\n\n    // 显示前10个标注数据作为预览\n    const imageIds = Object.keys(exportData.annotations).slice(0, 10);\n    for (const imageId of imageIds) {\n      const data = exportData.annotations[imageId];\n      // 如果没有plantId，尝试从imageId推断\n      const plantId = data.plantId || inferPlantIdFromImageId(imageId);\n\n      html += `\n        <div style=\"margin-bottom: 8px; padding: 8px; background: #f9fafb; border-radius: 4px; font-size: 13px;\">\n          <div style=\"font-weight: 500;\">${imageId}</div>\n          <div style=\"color: #6b7280;\">\n            Plant: ${plantId} |\n            Keypoints: ${data.annotations.length} |\n            Time: ${data.timestamp ? new Date(data.timestamp).toLocaleString() : 'N/A'}\n          </div>\n        </div>\n      `;\n    }\n\n    if (annotationCount > 10) {\n      html += `<div style=\"text-align: center; color: #6b7280; margin-top: 10px;\">... ${annotationCount - 10} more images</div>`;\n    }\n\n    html += '</div></div>';\n  }\n\n  // Display skipped plants\n  const skippedCount = Object.keys(exportData.skippedPlants).length;\n  if (skippedCount > 0) {\n    html += `\n      <div style=\"margin-bottom: 20px;\">\n        <div style=\"font-weight: 600; margin-bottom: 10px; color: #374151;\">\n          ⏭️ Skipped Plants (${skippedCount})\n        </div>\n        <div style=\"max-height: 150px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 4px; padding: 10px;\">\n    `;\n\n    for (const [plantId, data] of Object.entries(exportData.skippedPlants)) {\n      html += `\n        <div style=\"margin-bottom: 8px; padding: 8px; background: #fef3c7; border-radius: 4px; font-size: 13px;\">\n          <div style=\"font-weight: 500;\">${plantId}</div>\n          <div style=\"color: #92400e;\">\n            Reason: ${data.skipReason} |\n            Time: ${data.skipDate ? new Date(data.skipDate).toLocaleString() : 'N/A'}\n          </div>\n        </div>\n      `;\n    }\n\n    html += '</div></div>';\n  }\n\n  if (html === '') {\n    html = '<div style=\"color: #6b7280; text-align: center; padding: 20px;\">No data available</div>';\n  }\n\n  return html;\n}\n\n/**\n * 按植株和视角分组图像数据\n */\nfunction groupImagesByPlantAndView(imageData) {\n  const groupedData = {};\n  \n  for (const [imageId, annotations] of Object.entries(imageData)) {\n    // 解析图像ID获取植株和视角信息\n    const parts = imageId.split('_');\n    if (parts.length >= 2) {\n      const plantId = parts[0]; // BR017-028111\n      const viewAngle = parts[1]; // sv-000\n      \n      if (!groupedData[plantId]) {\n        groupedData[plantId] = {};\n      }\n      \n      if (!groupedData[plantId][viewAngle]) {\n        groupedData[plantId][viewAngle] = [];\n      }\n      \n      groupedData[plantId][viewAngle].push({\n        imageId,\n        annotations,\n        imageName: imageId,\n        keypointCount: annotations.length\n      });\n    }\n  }\n  \n  // 按时间排序每个视角的图像\n  for (const plantId of Object.keys(groupedData)) {\n    for (const viewAngle of Object.keys(groupedData[plantId])) {\n      groupedData[plantId][viewAngle].sort((a, b) => {\n        return a.imageId.localeCompare(b.imageId);\n      });\n    }\n  }\n  \n  return groupedData;\n}\n\n/**\n * 生成预览HTML\n */\nasync function generatePreviewHTML(groupedData) {\n  const plantIds = Object.keys(groupedData).sort();\n  \n  if (plantIds.length === 0) {\n    return '<div style=\"color: #6b7280; text-align: center; padding: 20px;\">暂无数据</div>';\n  }\n  \n  let html = `\n    <div style=\"margin-bottom: 15px; font-weight: 600; color: #374151;\">\n      共 ${plantIds.length} 个植株参与导出\n    </div>\n  `;\n  \n  for (const plantId of plantIds) {\n    const plantData = groupedData[plantId];\n    const viewAngles = Object.keys(plantData);\n    const totalImages = Object.values(plantData).reduce((sum, images) => sum + images.length, 0);\n    const totalKeypoints = Object.values(plantData).reduce((sum, images) => \n      sum + images.reduce((imgSum, img) => imgSum + img.keypointCount, 0), 0\n    );\n    \n    html += `\n      <div class=\"preview-plant\" style=\"border: 1px solid #d1d5db; border-radius: 8px; margin-bottom: 15px; overflow: hidden;\">\n        <div class=\"preview-plant-header\" style=\"background: #f3f4f6; padding: 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;\"\n             onclick=\"togglePlantPreview('${plantId}')\">\n          <div>\n            <span style=\"font-weight: 600; color: #1f2937;\">🌱 ${plantId}</span>\n            <span style=\"color: #6b7280; margin-left: 10px;\">\n              ${viewAngles.length} views • ${totalImages} images • ${totalKeypoints} 个标注点\n            </span>\n          </div>\n          <span class=\"preview-toggle\" style=\"color: #6b7280;\">▼</span>\n        </div>\n        <div class=\"preview-plant-content\" id=\"preview-${plantId}\" style=\"display: none;\">\n          ${generateViewAnglesHTML(plantId, plantData)}\n        </div>\n      </div>\n    `;\n  }\n  \n  return html;\n}\n\n/**\n * 生成视角HTML\n */\nfunction generateViewAnglesHTML(plantId, plantData) {\n  let html = '';\n  \n  for (const [viewAngle, images] of Object.entries(plantData)) {\n    const totalKeypoints = images.reduce((sum, img) => sum + img.keypointCount, 0);\n    \n    html += `\n      <div class=\"preview-view-angle\" style=\"border-top: 1px solid #e5e7eb;\">\n        <div class=\"preview-view-header\" style=\"background: #fafafa; padding: 10px 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;\"\n             onclick=\"toggleViewPreview('${plantId}', '${viewAngle}')\">\n          <div>\n            <span style=\"font-weight: 500; color: #374151;\">📷 ${viewAngle}</span>\n            <span style=\"color: #6b7280; margin-left: 10px;\">\n              ${images.length} images • ${totalKeypoints} annotations\n            </span>\n          </div>\n          <span class=\"preview-toggle\" style=\"color: #6b7280;\">▶</span>\n        </div>\n        <div class=\"preview-view-content\" id=\"preview-${plantId}-${viewAngle}\" style=\"display: none; padding: 10px 15px;\">\n          ${generateImagesHTML(images)}\n        </div>\n      </div>\n    `;\n  }\n  \n  return html;\n}\n\n/**\n * 生成图像HTML\n */\nfunction generateImagesHTML(images) {\n  let html = '<div style=\"display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;\">';\n  \n  for (const image of images) {\n    // 正确提取文件名 - 从完整的imageId中提取最后的文件名部分\n    const fileName = extractDisplayFileName(image.imageName);\n    \n    html += `\n      <div class=\"preview-image\" style=\"border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px; background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1);\">\n        <div style=\"margin-bottom: 10px;\">\n          <div style=\"font-weight: 500; color: #374151; font-size: 14px; word-break: break-all;\" title=\"${image.imageName}\">\n            📄 ${fileName}\n          </div>\n          <div style=\"color: #6b7280; font-size: 12px; margin-top: 4px;\">\n            ${image.keypointCount} 个标注点\n          </div>\n        </div>\n        \n        <div class=\"preview-annotations\" style=\"background: #f8fafc; border-radius: 6px; padding: 10px;\">\n          <div style=\"font-size: 13px; font-weight: 500; color: #374151; margin-bottom: 8px;\">标注点预览:</div>\n          <div class=\"annotation-preview-container\" style=\"position: relative; width: 100%; height: 200px; border: 1px solid #d1d5db; border-radius: 4px; overflow: hidden; background: #f9fafb;\">\n            <canvas \n              class=\"annotation-preview-canvas\" \n              data-image-id=\"${image.imageId}\"\n              data-annotations='${JSON.stringify(image.annotations)}'\n              style=\"width: 100%; height: 100%; cursor: pointer;\"\n              title=\"点击查看大图\"\n              onclick=\"showImageDetail('${image.imageId}')\"\n            ></canvas>\n            <div class=\"preview-loading\" style=\"position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #6b7280; font-size: 12px;\">\n              加载中...\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }\n  \n  html += '</div>';\n  return html;\n}\n\n/**\n * 正确提取显示用的文件名\n */\nfunction extractDisplayFileName(imageName) {\n  // 从imageId中提取有意义的部分\n  // 例如: BR017-028111_sv-000_BR017-028111-2018-07-09_00_VIS_sv_000-0-0-0.png\n  // 提取: BR017-028111-2018-07-09_00_VIS_sv_000-0-0-0.png\n  \n  const parts = imageName.split('_');\n  if (parts.length >= 3) {\n    // 从第三部分开始是有意义的文件名信息\n    return parts.slice(2).join('_');\n  }\n  \n  // 如果格式不符合预期，返回原始名称\n  return imageName;\n}\n\n/**\n * 绑定预览事件\n */\nfunction bindPreviewEvents() {\n  // 植株展开/折叠事件通过onclick属性绑定\n  window.togglePlantPreview = function(plantId) {\n    const content = document.getElementById(`preview-${plantId}`);\n    const toggle = content.parentElement.querySelector('.preview-plant-header .preview-toggle');\n    \n    if (content.style.display === 'none') {\n      content.style.display = 'block';\n      toggle.textContent = '▲';\n      // 展开时渲染canvas\n      setTimeout(() => renderPreviewCanvases(content), 100);\n    } else {\n      content.style.display = 'none';\n      toggle.textContent = '▼';\n    }\n  };\n  \n  // 视角展开/折叠事件\n  window.toggleViewPreview = function(plantId, viewAngle) {\n    const content = document.getElementById(`preview-${plantId}-${viewAngle}`);\n    const toggle = content.parentElement.querySelector('.preview-view-header .preview-toggle');\n    \n    if (content.style.display === 'none') {\n      content.style.display = 'block';\n      toggle.textContent = '▼';\n      // 展开时渲染canvas\n      setTimeout(() => renderPreviewCanvases(content), 100);\n    } else {\n      content.style.display = 'none';\n      toggle.textContent = '▶';\n    }\n  };\n  \n  // 显示图像详情\n  window.showImageDetail = function(imageId) {\n    showImageDetailModal(imageId);\n  };\n  \n  // 渲染所有可见的canvas\n  setTimeout(() => {\n    const allCanvases = document.querySelectorAll('.annotation-preview-canvas');\n    allCanvases.forEach(canvas => {\n      if (isElementVisible(canvas)) {\n        renderAnnotationPreview(canvas);\n      }\n    });\n  }, 500);\n}\n\n/**\n * 渲染预览区域内的所有canvas\n */\nfunction renderPreviewCanvases(container) {\n  const canvases = container.querySelectorAll('.annotation-preview-canvas');\n  canvases.forEach(canvas => {\n    if (isElementVisible(canvas)) {\n      renderAnnotationPreview(canvas);\n    }\n  });\n}\n\n/**\n * 检查元素是否可见\n */\nfunction isElementVisible(element) {\n  const rect = element.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\n\n/**\n * 渲染单个标注预览canvas\n */\nasync function renderAnnotationPreview(canvas) {\n  try {\n    const imageId = canvas.dataset.imageId;\n    const annotations = JSON.parse(canvas.dataset.annotations);\n    const loadingElement = canvas.parentElement.querySelector('.preview-loading');\n    \n    // 检查是否已经渲染过\n    if (canvas.dataset.rendered === 'true') {\n      return;\n    }\n    \n    // 显示加载状态\n    if (loadingElement) {\n      loadingElement.style.display = 'block';\n      loadingElement.textContent = '加载图像...';\n    }\n    \n    // 获取图像数据\n    const imageData = await getImageDataFromId(imageId);\n    if (!imageData) {\n      throw new Error('无法获取图像数据');\n    }\n    \n    // 加载图像\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n    \n    await new Promise((resolve, reject) => {\n      image.onload = () => resolve();\n      image.onerror = () => reject(new Error('图像加载失败'));\n      image.src = imageData.url;\n    });\n    \n    // 设置canvas尺寸\n    const container = canvas.parentElement;\n    const containerRect = container.getBoundingClientRect();\n    const targetWidth = containerRect.width - 2; // 减去边框\n    const targetHeight = containerRect.height - 2;\n    \n    canvas.width = targetWidth * window.devicePixelRatio;\n    canvas.height = targetHeight * window.devicePixelRatio;\n    canvas.style.width = targetWidth + 'px';\n    canvas.style.height = targetHeight + 'px';\n    \n    const ctx = canvas.getContext('2d');\n    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);\n    \n    // 计算图像适应容器的尺寸\n    const imgAspect = image.width / image.height;\n    const containerAspect = targetWidth / targetHeight;\n    \n    let drawWidth, drawHeight, offsetX, offsetY;\n    \n    if (imgAspect > containerAspect) {\n      // 图像较宽，以宽度为准\n      drawWidth = targetWidth;\n      drawHeight = targetWidth / imgAspect;\n      offsetX = 0;\n      offsetY = (targetHeight - drawHeight) / 2;\n    } else {\n      // 图像较高，以高度为准\n      drawHeight = targetHeight;\n      drawWidth = targetHeight * imgAspect;\n      offsetX = (targetWidth - drawWidth) / 2;\n      offsetY = 0;\n    }\n    \n    // 绘制图像\n    ctx.clearRect(0, 0, targetWidth, targetHeight);\n    ctx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight);\n    \n    // 绘制标注点\n    if (annotations && annotations.length > 0) {\n      // 计算标注点在canvas中的位置\n      const scaleX = drawWidth / image.width;\n      const scaleY = drawHeight / image.height;\n      \n      annotations.forEach((annotation, index) => {\n        const x = annotation.x * scaleX + offsetX;\n        const y = annotation.y * scaleY + offsetY;\n        \n        // 绘制标注点\n        ctx.fillStyle = '#ef4444';\n        ctx.strokeStyle = '#ffffff';\n        ctx.lineWidth = 2;\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.stroke();\n        \n        // 绘制标注点编号\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold 10px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText((index + 1).toString(), x, y);\n      });\n    }\n    \n    // 隐藏加载状态\n    if (loadingElement) {\n      loadingElement.style.display = 'none';\n    }\n    \n    // 标记为已渲染\n    canvas.dataset.rendered = 'true';\n    \n  } catch (error) {\n    console.error('渲染标注预览失败:', error);\n    const loadingElement = canvas.parentElement.querySelector('.preview-loading');\n    if (loadingElement) {\n      loadingElement.textContent = '加载失败';\n      loadingElement.style.color = '#dc2626';\n    }\n  }\n}\n\n/**\n * 从图像ID获取图像数据\n */\nasync function getImageDataFromId(imageId) {\n  try {\n    // 从imageId中解析植株ID\n    const parts = imageId.split('_');\n    if (parts.length < 2) {\n      throw new Error('无效的图像ID格式');\n    }\n    \n    const plantId = parts[0];\n    const viewAngle = parts[1];\n    \n    // 获取植株的图像数据\n    if (!plantDataManager) {\n      throw new Error('PlantDataManager未初始化');\n    }\n    \n    const images = await plantDataManager.getPlantImages(plantId, viewAngle);\n    const targetImage = images.find(img => img.id === imageId);\n    \n    if (!targetImage) {\n      throw new Error(`未找到图像: ${imageId}`);\n    }\n    \n    // 创建图像URL\n    const imageURL = await plantDataManager.fileSystemManager.createImageURL(targetImage);\n    \n    return {\n      url: imageURL,\n      data: targetImage\n    };\n    \n  } catch (error) {\n    console.error('获取图像数据失败:', error);\n    return null;\n  }\n}\n\n/**\n * 显示图像详情模态框\n */\nfunction showImageDetailModal(imageId) {\n  // 创建详情模态框 - 简单实现，显示原图和标注点\n  const modalHTML = `\n    <div id=\"image-detail-modal\" class=\"modal\" style=\"display: flex; z-index: 2000;\">\n      <div class=\"modal-content\" style=\"max-width: 90vw; max-height: 90vh; padding: 20px;\">\n        <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\n          <h3 style=\"margin: 0;\">图像详情</h3>\n          <button onclick=\"closeImageDetailModal()\" class=\"modal-close\"></button>\n        </div>\n        <div style=\"text-align: center;\">\n          <div style=\"font-size: 14px; color: #6b7280; margin-bottom: 10px; word-break: break-all;\">\n            ${imageId}\n          </div>\n          <div style=\"max-width: 100%; max-height: 70vh; overflow: auto; border: 1px solid #e5e7eb; border-radius: 8px;\">\n            <canvas id=\"detail-canvas\" style=\"max-width: 100%; height: auto;\"></canvas>\n          </div>\n        </div>\n      </div>\n    </div>\n  `;\n  \n  // 移除已存在的详情模态框\n  const existingModal = document.getElementById('image-detail-modal');\n  if (existingModal) {\n    existingModal.remove();\n  }\n  \n  // 添加到body\n  document.body.insertAdjacentHTML('beforeend', modalHTML);\n  \n  // 渲染大图\n  renderImageDetail(imageId);\n  \n  // 绑定关闭事件\n  window.closeImageDetailModal = function() {\n    const modal = document.getElementById('image-detail-modal');\n    if (modal) {\n      modal.remove();\n    }\n  };\n}\n\n/**\n * 渲染图像详情\n */\nasync function renderImageDetail(imageId) {\n  const canvas = document.getElementById('detail-canvas');\n  if (!canvas) return;\n  \n  try {\n    // 获取标注数据\n    const previewCanvas = document.querySelector(`[data-image-id=\"${imageId}\"]`);\n    const annotations = previewCanvas ? JSON.parse(previewCanvas.dataset.annotations) : [];\n    \n    // 获取图像数据\n    const imageData = await getImageDataFromId(imageId);\n    if (!imageData) {\n      throw new Error('无法获取图像数据');\n    }\n    \n    // 加载图像\n    const image = new Image();\n    image.crossOrigin = 'anonymous';\n    \n    await new Promise((resolve, reject) => {\n      image.onload = () => resolve();\n      image.onerror = () => reject(new Error('图像加载失败'));\n      image.src = imageData.url;\n    });\n    \n    // 设置canvas尺寸（保持原图比例，但限制最大尺寸）\n    const maxWidth = 800;\n    const maxHeight = 600;\n    \n    let drawWidth = image.width;\n    let drawHeight = image.height;\n    \n    if (drawWidth > maxWidth || drawHeight > maxHeight) {\n      const scale = Math.min(maxWidth / drawWidth, maxHeight / drawHeight);\n      drawWidth *= scale;\n      drawHeight *= scale;\n    }\n    \n    canvas.width = drawWidth;\n    canvas.height = drawHeight;\n    \n    const ctx = canvas.getContext('2d');\n    \n    // 绘制图像\n    ctx.drawImage(image, 0, 0, drawWidth, drawHeight);\n    \n    // 绘制标注点\n    if (annotations && annotations.length > 0) {\n      const scaleX = drawWidth / image.width;\n      const scaleY = drawHeight / image.height;\n      \n      annotations.forEach((annotation, index) => {\n        const x = annotation.x * scaleX;\n        const y = annotation.y * scaleY;\n        \n        // 绘制标注点\n        ctx.fillStyle = '#ef4444';\n        ctx.strokeStyle = '#ffffff';\n        ctx.lineWidth = 3;\n        \n        ctx.beginPath();\n        ctx.arc(x, y, 8, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.stroke();\n        \n        // 绘制标注点编号\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold 14px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText((index + 1).toString(), x, y);\n      });\n    }\n    \n  } catch (error) {\n    console.error('渲染图像详情失败:', error);\n    canvas.parentElement.innerHTML = '<div style=\"color: #dc2626; padding: 20px;\">图像加载失败</div>';\n  }\n}\n\n// 全局函数：切换分支点预览\nwindow.toggleBranchPointPreview = function(show = null) {\n  if (branchPointPreviewManager) {\n    branchPointPreviewManager.toggleVisibility(show);\n  }\n};\n\n/**\n * 导航到上一张图片\n */\nasync function navigateToPreviousImage() {\n  // 🔧 FIX: Additional navigation lock check\n  if (appState.navigation.isNavigating) {\n    console.log('[Navigation] navigateToPreviousImage blocked - already navigating');\n    return;\n  }\n\n  if (!appState.currentPlant || !appState.currentImage) {\n    console.log('没有当前植物或图像，无法导航');\n    return;\n  }\n  \n  try {\n    // 获取当前视角的所有图像\n    const images = await plantDataManager.getPlantImages(\n      appState.currentPlant.id, \n      appState.currentPlant.selectedViewAngle\n    );\n    \n    if (images.length <= 1) {\n      console.log('只有一张图像，无法导航到上一张');\n      return;\n    }\n    \n    // 找到当前图像的索引\n    const currentIndex = images.findIndex(img => img.id === appState.currentImage.id);\n    \n    if (currentIndex === -1) {\n      console.warn('未找到当前图像在列表中的位置');\n      return;\n    }\n    \n    // 计算上一张图像的索引（循环到最后一张）\n    const previousIndex = currentIndex === 0 ? images.length - 1 : currentIndex - 1;\n    const previousImage = images[previousIndex];\n    \n    console.log(`导航：从第${currentIndex + 1}张切换到第${previousIndex + 1}张`);\n    \n    // 切换到上一张图像\n    await handleImageSelect(previousImage, true);\n    \n  } catch (error) {\n    console.error('导航到上一张图像失败:', error);\n    showError('图像导航失败', error.message);\n  }\n}\n\n/**\n * 导航到下一张图片\n * @param {boolean} autoMode - 是否为自动化模式（不循环回第一张）\n * @returns {boolean} 是否成功切换到下一张图片\n */\nasync function navigateToNextImage(autoMode = false) {\n  // 🔧 FIX: Additional navigation lock check\n  if (appState.navigation.isNavigating) {\n    console.log('[Navigation] navigateToNextImage blocked - already navigating');\n    return false;\n  }\n\n  if (!appState.currentPlant || !appState.currentImage) {\n    console.log('没有当前植物或图像，无法导航');\n    return false;\n  }\n\n  try {\n    // 获取当前视角的所有图像\n    const images = await plantDataManager.getPlantImages(\n      appState.currentPlant.id,\n      appState.currentPlant.selectedViewAngle\n    );\n\n    if (images.length <= 1) {\n      console.log('只有一张图像，无法导航到下一张');\n      return false;\n    }\n\n    // 找到当前图像的索引\n    const currentIndex = images.findIndex(img => img.id === appState.currentImage.id);\n\n    if (currentIndex === -1) {\n      console.warn('未找到当前图像在列表中的位置');\n      return false;\n    }\n\n    // 检查是否已经是最后一张\n    if (currentIndex === images.length - 1) {\n      if (autoMode) {\n        console.log('自动化模式：已经是最后一张图片，不循环');\n        return false;\n      }\n      // 非自动化模式：循环到第一张\n    }\n\n    // 计算下一张图像的索引\n    const nextIndex = currentIndex === images.length - 1 ? 0 : currentIndex + 1;\n    const nextImage = images[nextIndex];\n\n    console.log(`导航：从第${currentIndex + 1}张切换到第${nextIndex + 1}张`);\n\n    // 切换到下一张图像\n    await handleImageSelect(nextImage, true);\n    return true;\n\n  } catch (error) {\n    console.error('导航到下一张图像失败:', error);\n    showError('图像导航失败', error.message);\n    return false;\n  }\n}\n\n/**\n * 处理自动化方向选择（传统标注升级）\n */\nfunction handleAutoDirectionSelection() {\n  if (!annotationTool) {\n    showError('功能不可用', '标注工具未初始化');\n    return;\n  }\n\n  // 检查是否有标注点\n  if (!annotationTool.keypoints || annotationTool.keypoints.length === 0) {\n    showError('传统标注升级', '当前图像没有标注点，请先添加标注点');\n    return;\n  }\n\n  // 额外检查：若当前类型存在且不支持方向，提示并退出\n  const currentType = window.PlantAnnotationTool?.annotationTool?.customAnnotationManager?.getCurrentCustomType?.();\n  if (currentType && currentType.metadata && currentType.metadata.isDirectional === false) {\n    showError('Auto Direction Disabled', '当前选择的类型未启用方向功能');\n    return;\n  }\n\n  // 🔧 FIX: Read mode from UI selector before starting auto direction mode\n  const modeSelector = document.getElementById('auto-direction-mode-selector');\n  if (modeSelector && modeSelector.value) {\n    console.log(`[调试] 从UI选择器读取模式: ${modeSelector.value}`);\n    annotationTool.autoDirectionMode = modeSelector.value;\n  } else {\n    // Fallback to longitudinal if no selection\n    console.log('[调试] UI选择器无值，使用默认longitudinal模式');\n    annotationTool.autoDirectionMode = 'longitudinal';\n    if (modeSelector) {\n      modeSelector.value = 'longitudinal';\n    }\n  }\n\n  // 启动自动化方向升级模式\n  const success = annotationTool.startAutoDirectionMode();\n\n  if (!success) {\n    // startAutoDirectionMode 内部已经显示了提示信息\n    return;\n  }\n\n  // 更新按钮状态\n  const autoDirectionBtn = document.getElementById('auto-direction-btn');\n  if (autoDirectionBtn) {\n    console.log('[调试] 更新按钮状态为自动模式');\n\n    // 先移除现有的事件监听器\n    autoDirectionBtn.removeEventListener('click', handleAutoDirectionSelection);\n\n    // 更新按钮外观\n    autoDirectionBtn.textContent = 'Exit Auto Mode';\n    autoDirectionBtn.classList.add('active');\n\n    // 创建新的事件处理函数\n    const pauseHandler = () => {\n      console.log('[调试] 自动化按钮被点击，暂停模式');\n      annotationTool.pauseAutoDirectionMode();\n    };\n\n    // 添加新的事件监听器\n    autoDirectionBtn.addEventListener('click', pauseHandler);\n\n    // 保存处理函数引用，以便后续移除\n    autoDirectionBtn._pauseHandler = pauseHandler;\n  }\n\n  updateProgressInfo('传统标注升级模式已启动。移动鼠标选择方向，左键确认，右键暂停。');\n}\n\n/**\n * 重置自动方向选择按钮状态\n */\nfunction resetAutoDirectionButton() {\n  const autoDirectionBtn = document.getElementById('auto-direction-btn');\n  if (autoDirectionBtn) {\n    console.log('[调试] 重置自动方向按钮状态');\n\n    // 移除暂停处理函数\n    if (autoDirectionBtn._pauseHandler) {\n      autoDirectionBtn.removeEventListener('click', autoDirectionBtn._pauseHandler);\n      autoDirectionBtn._pauseHandler = null;\n    }\n\n    // 恢复按钮外观\n    autoDirectionBtn.textContent = 'Auto Direction';\n    autoDirectionBtn.classList.remove('active');\n\n    // 重新添加原始事件监听器\n    autoDirectionBtn.addEventListener('click', handleAutoDirectionSelection);\n    \n    console.log('[调试] 自动方向按钮已重置为初始状态');\n  }\n}\n\n// 将重置函数暴露到全局，供AnnotationTool调用\nwindow.resetAutoDirectionButton = resetAutoDirectionButton;\n\n/**\n * 显示跳过植株模态框\n */\nfunction showSkipPlantModal(plantId, event) {\n  // 阻止事件冒泡，避免触发植株选择\n  if (event) {\n    event.stopPropagation();\n  }\n\n  const plant = appState.plants.find(p => p.id === plantId);\n  if (!plant) {\n    showError('错误', '未找到指定的植株');\n    return;\n  }\n\n  // 设置植株名称\n  const plantNameElement = document.getElementById('skip-plant-name');\n  if (plantNameElement) {\n    plantNameElement.textContent = plant.id;\n  }\n\n  // 清空之前的输入\n  const reasonTextarea = document.getElementById('skip-reason');\n  if (reasonTextarea) {\n    reasonTextarea.value = '';\n  }\n\n  // 显示模态框\n  const modal = document.getElementById('skip-plant-modal');\n  if (modal) {\n    modal.style.display = 'flex';\n    modal.dataset.plantId = plantId;\n\n    // 聚焦到文本框\n    setTimeout(() => {\n      if (reasonTextarea) {\n        reasonTextarea.focus();\n      }\n    }, 100);\n  }\n}\n\n/**\n * 隐藏跳过植株模态框\n */\nfunction hideSkipPlantModal() {\n  const modal = document.getElementById('skip-plant-modal');\n  if (modal) {\n    modal.style.display = 'none';\n    modal.dataset.plantId = '';\n  }\n}\n\n/**\n * 确认跳过植株\n */\nasync function confirmSkipPlant() {\n  const modal = document.getElementById('skip-plant-modal');\n  const plantId = modal?.dataset.plantId;\n  const reasonTextarea = document.getElementById('skip-reason');\n  const reason = reasonTextarea?.value.trim();\n\n  if (!plantId) {\n    showError('错误', '未找到要跳过的植株');\n    return;\n  }\n\n  if (!reason) {\n    showError('输入错误', '请输入跳过原因');\n    reasonTextarea?.focus();\n    return;\n  }\n\n  try {\n    // 更新植株状态\n    await plantDataManager.skipPlant(plantId, reason);\n\n    // 更新UI\n    const plant = appState.plants.find(p => p.id === plantId);\n    if (plant) {\n      plant.status = 'skipped';\n      plant.skipReason = reason;\n      plant.skipDate = new Date().toISOString();\n\n      // 重新渲染植株列表项\n      const plantItem = document.querySelector(`[data-plant-id=\"${plantId}\"]`);\n      if (plantItem) {\n        const newItem = createPlantListItem(plant);\n        plantItem.parentNode.replaceChild(newItem, plantItem);\n        \n        // 🔧 FIX: Update note badge for the re-rendered plant item\n        if (window.PlantAnnotationTool?.noteUI) {\n          setTimeout(() => {\n            window.PlantAnnotationTool.noteUI.updatePlantNoteBadge(plantId);\n          }, 100);\n        }\n      }\n\n      // 更新统计\n      updateProgressStats();\n\n      // 如果当前选中的是被跳过的植株，清除选择\n      if (appState.currentPlant?.id === plantId) {\n        console.log('当前植株被跳过，初始化空工作区');\n        initializeEmptyWorkspace();\n      }\n    }\n\n    hideSkipPlantModal();\n    showSuccess('跳过成功', `植株 ${plantId} 已标记为跳过`);\n\n  } catch (error) {\n    console.error('跳过植株失败:', error);\n    showError('跳过失败', error.message);\n  }\n}\n\n/**\n * 🔧 NEW: 处理撤销跳过植株 - 显示确认模态框\n */\nasync function handleUnskipPlant(plantId, event) {\n  // 阻止事件冒泡，避免触发植株选择\n  if (event) {\n    event.stopPropagation();\n  }\n\n  const plant = appState.plants.find(p => p.id === plantId);\n  if (!plant) {\n    showError('错误', '未找到指定的植株');\n    return;\n  }\n\n  if (plant.status !== 'skipped') {\n    showError('操作错误', '植株当前状态不是跳过状态');\n    return;\n  }\n\n  // 显示撤销跳过确认模态框\n  showUnskipPlantModal(plantId, plant.skipReason);\n}\n\n/**\n * 🔧 NEW: 处理撤销完成植株 - 显示确认模态框\n */\nasync function handleUncompletePlant(plantId, event) {\n  // 阻止事件冒泡，避免触发植株选择\n  if (event) {\n    event.stopPropagation();\n  }\n\n  const plant = appState.plants.find(p => p.id === plantId);\n  if (!plant) {\n    showError('错误', '未找到指定的植株');\n    return;\n  }\n\n  if (plant.status !== 'completed') {\n    showError('操作错误', '植株当前状态不是已完成状态');\n    return;\n  }\n\n  // 显示撤销完成确认模态框\n  showUncompletePlantModal(plantId);\n}\n\n/**\n * 处理状态过滤器变化\n */\nfunction handleStatusFilterChange() {\n  const statusFilter = document.getElementById('status-filter');\n  const searchInput = document.getElementById('plant-search');\n\n  if (!statusFilter || !plantDataManager) return;\n\n  const selectedStatus = statusFilter.value;\n  const searchQuery = searchInput?.value.trim() || '';\n\n  // 应用过滤\n  applyPlantsFilter(selectedStatus, searchQuery);\n}\n\n/**\n * 处理植株搜索输入\n */\nfunction handlePlantSearchInput() {\n  const statusFilter = document.getElementById('status-filter');\n  const searchInput = document.getElementById('plant-search');\n\n  if (!searchInput || !plantDataManager) return;\n\n  const searchQuery = searchInput.value.trim();\n  const selectedStatus = statusFilter?.value || 'all';\n\n  // 应用过滤\n  applyPlantsFilter(selectedStatus, searchQuery);\n}\n\n/**\n * 应用植株过滤\n */\nfunction applyPlantsFilter(status, searchQuery) {\n  if (!plantDataManager) return;\n\n  let filteredPlants = plantDataManager.filterPlantsByStatus(status);\n\n  // 如果有搜索查询，进一步过滤\n  if (searchQuery) {\n    const lowerQuery = searchQuery.toLowerCase();\n    filteredPlants = filteredPlants.filter(plant =>\n      plant.id.toLowerCase().includes(lowerQuery) ||\n      plant.name.toLowerCase().includes(lowerQuery)\n    );\n  }\n\n  // 重新渲染植株列表\n  renderPlantList(filteredPlants);\n\n  console.log(`过滤结果: 状态=${status}, 搜索=\"${searchQuery}\", 结果=${filteredPlants.length}个植株`);\n}\n\n/**\n * 🔧 NEW: 显示撤销跳过植株模态框\n */\nfunction showUnskipPlantModal(plantId, skipReason) {\n  const modal = document.getElementById('unskip-plant-modal');\n  const plantIdElement = document.getElementById('unskip-plant-id');\n  const skipReasonElement = document.getElementById('unskip-skip-reason');\n  const newStatusElement = document.getElementById('unskip-new-status');\n  \n  if (!modal) {\n    console.error('Unskip plant modal not found');\n    return;\n  }\n\n  // 设置植株信息\n  if (plantIdElement) {\n    plantIdElement.textContent = plantId;\n  }\n  \n  if (skipReasonElement) {\n    skipReasonElement.textContent = skipReason || '无';\n  }\n\n  // 🔧 FIX: Set the new status that will be applied\n  if (newStatusElement) {\n    newStatusElement.textContent = 'Pending (will be determined by annotations)';\n  }\n\n  // 显示模态框\n  modal.style.display = 'flex';\n  modal.dataset.plantId = plantId;\n}\n\n/**\n * 🔧 NEW: 隐藏撤销跳过植株模态框\n */\nfunction hideUnskipPlantModal() {\n  const modal = document.getElementById('unskip-plant-modal');\n  if (modal) {\n    modal.style.display = 'none';\n    modal.dataset.plantId = '';\n  }\n}\n\n/**\n * 🔧 NEW: 确认撤销跳过植株\n */\nasync function confirmUnskipPlant() {\n  const modal = document.getElementById('unskip-plant-modal');\n  const plantId = modal?.dataset.plantId;\n\n  if (!plantId) {\n    showError('错误', '未找到要撤销跳过的植株');\n    return;\n  }\n\n  try {\n    // 调用PlantDataManager的撤销跳过方法\n    await plantDataManager.unskipPlant(plantId);\n    console.log(`[Debug] 后端unskip操作完成，植物ID: ${plantId}`);\n\n    // 更新本地植株对象\n    const plant = appState.plants.find(p => p.id === plantId);\n    if (plant) {\n      console.log(`[Debug] 更新前植物状态: ${plant.status}, skipReason: ${plant.skipReason}`);\n      \n      const annotations = await plantDataManager.getPlantAnnotations(plantId);\n      plant.status = (annotations && annotations.length > 0) ? 'in-progress' : 'pending';\n      delete plant.skipReason;\n      delete plant.skipDate;\n      \n      console.log(`[Debug] 更新后植物状态: ${plant.status}, skipReason: ${plant.skipReason}`);\n\n      // 重新渲染植株列表项\n      const plantItem = document.querySelector(`[data-plant-id=\"${plantId}\"]`);\n      if (plantItem) {\n        const newItem = createPlantListItem(plant);\n        plantItem.parentNode.replaceChild(newItem, plantItem);\n        console.log(`[Debug] 植物列表项已重新渲染: ${plantId}`);\n        \n        // 🔧 FIX: Update note badge for the re-rendered plant item\n        if (window.PlantAnnotationTool?.noteUI) {\n          setTimeout(() => {\n            window.PlantAnnotationTool.noteUI.updatePlantNoteBadge(plantId);\n          }, 100);\n        }\n      }\n\n      // 更新统计\n      updateProgressStats();\n      \n      // 🔧 NEW: Update complete plant button state after uncomplete\n      updateCompletePlantButtonState();\n    }\n\n    hideUnskipPlantModal();\n    showSuccess('撤销成功', `植株 ${plantId} 已恢复到正常状态`);\n\n  } catch (error) {\n    console.error('撤销跳过植株失败:', error);\n    showError('撤销失败', error.message);\n  }\n}\n\n/**\n * 🔧 NEW: 显示撤销完成植株模态框\n */\nfunction showUncompletePlantModal(plantId) {\n  const modal = document.getElementById('uncomplete-plant-modal');\n  const plantIdElement = document.getElementById('uncomplete-plant-id');\n  \n  if (!modal) {\n    console.error('Uncomplete plant modal not found');\n    return;\n  }\n\n  // 设置植株信息\n  if (plantIdElement) {\n    plantIdElement.textContent = plantId;\n  }\n\n  // 显示模态框\n  modal.style.display = 'flex';\n  modal.dataset.plantId = plantId;\n}\n\n/**\n * 🔧 NEW: 隐藏撤销完成植株模态框\n */\nfunction hideUncompletePlantModal() {\n  const modal = document.getElementById('uncomplete-plant-modal');\n  if (modal) {\n    modal.style.display = 'none';\n    modal.dataset.plantId = '';\n  }\n}\n\n/**\n * 🔧 NEW: 确认撤销完成植株\n */\nasync function confirmUncompletePlant() {\n  const modal = document.getElementById('uncomplete-plant-modal');\n  const plantId = modal?.dataset.plantId;\n\n  if (!plantId) {\n    showError('错误', '未找到要撤销完成的植株');\n    return;\n  }\n\n  try {\n    // 调用PlantDataManager的撤销完成方法\n    await plantDataManager.uncompletePlant(plantId);\n\n    // 更新本地植株对象\n    const plant = appState.plants.find(p => p.id === plantId);\n    if (plant) {\n      const annotations = await plantDataManager.getPlantAnnotations(plantId);\n      plant.status = (annotations && annotations.length > 0) ? 'in-progress' : 'pending';\n\n      // 重新渲染植株列表项\n      const plantItem = document.querySelector(`[data-plant-id=\"${plantId}\"]`);\n      if (plantItem) {\n        const newItem = createPlantListItem(plant);\n        plantItem.parentNode.replaceChild(newItem, plantItem);\n        \n        // 🔧 FIX: Update note badge for the re-rendered plant item\n        if (window.PlantAnnotationTool?.noteUI) {\n          setTimeout(() => {\n            window.PlantAnnotationTool.noteUI.updatePlantNoteBadge(plantId);\n          }, 100);\n        }\n      }\n\n      // 更新统计\n      updateProgressStats();\n      \n      // 🔧 NEW: Update complete plant button state after uncomplete\n      updateCompletePlantButtonState();\n    }\n\n    hideUncompletePlantModal();\n    showSuccess('撤销成功', `植株 ${plantId} 已恢复到进行中状态`);\n\n  } catch (error) {\n    console.error('撤销完成植株失败:', error);\n    showError('撤销失败', error.message);\n  }\n}\n\n// 将函数添加到全局对象，以便AnnotationTool可以访问\nwindow.handleAutoDirectionSelection = handleAutoDirectionSelection;\nwindow.navigateToNextImage = navigateToNextImage;\nwindow.showSkipPlantModal = showSkipPlantModal;\n\n// 🔧 NEW: Global functions for state reversal operations\nwindow.handleUnskipPlant = handleUnskipPlant;\n\n// 🔧 FIX: Expose handleImageSelect for cross-sectional mode support\nwindow.handleImageSelect = handleImageSelect;\n\n/**\n * 处理锁定倍数开关变化\n */\nfunction handleZoomLockChange() {\n  const zoomLockCheckbox = document.getElementById('zoom-lock-checkbox');\n  const zoomLockValue = document.getElementById('zoom-lock-value');\n\n  if (zoomLockCheckbox && zoomLockValue) {\n    const isLocked = zoomLockCheckbox.checked;\n    zoomLockValue.disabled = !isLocked;\n\n    console.log(`缩放锁定: ${isLocked ? '开启' : '关闭'}`);\n\n    if (isLocked) {\n      const lockValue = parseFloat(zoomLockValue.value);\n      console.log(`锁定倍数设置为: ${lockValue}x`);\n    }\n  }\n}\n\n/**\n * 处理锁定倍数值变化\n */\nfunction handleZoomLockValueChange() {\n  const zoomLockValue = document.getElementById('zoom-lock-value');\n  if (zoomLockValue) {\n    const lockValue = parseFloat(zoomLockValue.value);\n    console.log(`锁定倍数更新为: ${lockValue}x`);\n  }\n}\n\n/**\n * 处理自动切换到预期位置开关变化\n */\nfunction handleAutoMoveChange() {\n  const autoMoveCheckbox = document.getElementById('auto-move-checkbox');\n\n  if (autoMoveCheckbox) {\n    const isEnabled = autoMoveCheckbox.checked;\n    console.log(`自动切换到预期位置: ${isEnabled ? '开启' : '关闭'}`);\n\n    // 通知AnnotationTool更新设置\n    if (annotationTool && typeof annotationTool.setAutoMoveToExpectedPosition === 'function') {\n      annotationTool.setAutoMoveToExpectedPosition(isEnabled);\n    }\n  }\n}\n\n/**\n * 🔄 处理实时变更同步开关变化\n */\nfunction handleRealTimeChangeChange() {\n  const realTimeChangeCheckbox = document.getElementById('real-time-change-checkbox');\n  \n  if (realTimeChangeCheckbox) {\n    const isEnabled = realTimeChangeCheckbox.checked;\n    console.log(`🔄 实时变更同步: ${isEnabled ? '开启' : '关闭'}`);\n    \n    // 通知RealTimeSyncManager更新设置\n    if (realTimeSyncManager && typeof realTimeSyncManager.setEnabled === 'function') {\n      realTimeSyncManager.setEnabled(isEnabled);\n    }\n    \n    // 立即更新进度信息以反映状态变化\n    updateProgressInfo(`实时变更同步已${isEnabled ? '开启' : '关闭'}`);\n  }\n}\n\n/**\n * 🔧 NEW: Handle auto direction mode change (Longitudinal vs Cross-Sectional)\n */\nfunction handleAutoDirectionModeChange() {\n  const autoDirectionModeSelector = document.getElementById('auto-direction-mode-selector');\n  \n  if (autoDirectionModeSelector) {\n    const selectedMode = autoDirectionModeSelector.value;\n    console.log(`Auto direction mode changed to: ${selectedMode}`);\n    \n    // Notify AnnotationTool about the mode change\n    if (annotationTool && typeof annotationTool.setAutoDirectionMode === 'function') {\n      annotationTool.setAutoDirectionMode(selectedMode);\n    }\n    \n    // Update progress info to reflect the change\n    const modeText = selectedMode === 'cross-sectional' ? 'Vertical Mode (Order by Order)' : 'Horizontal Mode (Image by Image)';\n    updateProgressInfo(`Auto direction mode set to: ${modeText}`);\n    \n    // Update UI classes for visual feedback\n    const autoDirectionBtn = document.getElementById('auto-direction-btn');\n    if (autoDirectionBtn) {\n      autoDirectionBtn.classList.remove('longitudinal-mode', 'cross-sectional-mode');\n      autoDirectionBtn.classList.add(`${selectedMode}-mode`);\n    }\n  }\n}\n\n/**\n * 获取自动切换设置\n */\nfunction getAutoMoveSettings() {\n  const autoMoveCheckbox = document.getElementById('auto-move-checkbox');\n  return {\n    isEnabled: autoMoveCheckbox ? autoMoveCheckbox.checked : false\n  };\n}\n\n/**\n * 获取锁定倍数设置\n */\nfunction getZoomLockSettings() {\n  const zoomLockCheckbox = document.getElementById('zoom-lock-checkbox');\n  const zoomLockValue = document.getElementById('zoom-lock-value');\n\n  if (zoomLockCheckbox && zoomLockValue) {\n    return {\n      isLocked: zoomLockCheckbox.checked,\n      lockValue: parseFloat(zoomLockValue.value) || 2.5\n    };\n  }\n\n  return { isLocked: false, lockValue: 2.5 };\n}\n\n/**\n * 更新全屏加载进度\n */\nfunction updateFullscreenLoading(progress, subtitle, details) {\n  const progressFill = document.getElementById('progress-fill');\n  const progressText = document.getElementById('progress-text');\n  const loadingSubtitle = document.getElementById('loading-subtitle');\n  const loadingDetails = document.getElementById('loading-details');\n  \n  if (progressFill) {\n    progressFill.style.width = `${progress}%`;\n  }\n  \n  if (progressText) {\n    progressText.textContent = `${progress}%`;\n  }\n  \n  if (loadingSubtitle) {\n    loadingSubtitle.textContent = subtitle;\n  }\n  \n  if (loadingDetails) {\n    loadingDetails.textContent = details;\n  }\n}\n\n/**\n * 隐藏全屏加载指示器\n */\nfunction hideFullscreenLoading() {\n  const fullscreenLoading = document.getElementById('fullscreen-loading');\n  if (fullscreenLoading) {\n    fullscreenLoading.style.display = 'none';\n  }\n}\n\n/**\n * 自动连接数据集 - 完整批量加载版本 (带性能监控)\n */\nasync function autoConnectDataset() {\n  console.log('开始自动连接数据集 - 完整批量加载模式...');\n  \n  // 🔧 PERFORMANCE: 开始性能监控\n  if (performanceMonitor) {\n    performanceMonitor.startMonitoring();\n    performanceMonitor.addCheckpoint('开始数据集连接');\n  }\n  \n  try {\n    updateFullscreenLoading(5, 'Connecting to backend...', 'Establishing connection to the dataset service');\n    \n    // 检查后端连接\n    let datasetInfo;\n    try {\n      datasetInfo = await plantDataManager.fileSystemManager.getDatasetInfo();\n      performanceMonitor?.addCheckpoint('后端连接成功');\n    } catch (connectionError) {\n      performanceMonitor?.recordError(connectionError, '后端连接失败');\n      throw new ConnectionError(\n        '无法连接到后端服务',\n        '请确保后端服务已启动。运行 ./start-backend.sh 启动服务器',\n        {\n          originalError: connectionError,\n          serverUrl: 'http://localhost:3003',\n          suggestion: '尝试运行: ./start-backend.sh'\n        }\n      );\n    }\n    \n    if (!datasetInfo) {\n      const error = new Error('后端服务响应异常：数据集信息为空');\n      performanceMonitor?.recordError(error, '数据集信息验证');\n      throw error;\n    }\n\n    console.log('连接的数据集:', datasetInfo.datasetPath);\n\n    updateFullscreenLoading(15, 'Validating dataset structure...', 'Checking plant directories and structure');\n\n    // 验证目录结构\n    await validateDatasetStructure();\n    performanceMonitor?.addCheckpoint('目录结构验证完成');\n\n    updateFullscreenLoading(25, 'Loading plant data...', 'Scanning plant directories and loading basic info');\n\n    // 使用PlantDataManager加载数据集\n    const plants = await plantDataManager.loadDataset();\n    performanceMonitor?.recordDataLoaded('plants', plants.length);\n    \n    // 更新应用状态\n    appState.currentDatasetPath = datasetInfo.datasetPath;\n    appState.plants = plants;\n    currentDataset = {\n      path: datasetInfo.datasetPath,\n      name: 'Brassica napus dataset',\n      plantCount: plants.length\n    };\n    \n    console.log(`植物数据加载完成: ${plants.length} 个植物`);\n\n    // 🔧 PERFORMANCE OPTIMIZATION: 并行加载所有数据类型\n    updateFullscreenLoading(40, 'Loading all data types...', 'Bulk loading annotations, notes, and statistics');\n    performanceMonitor?.addCheckpoint('开始并行数据加载');\n\n    const loadingTasks = [];\n    const loadingResults = {\n      annotations: null,\n      notes: null,\n      annotationsLoaded: false,\n      notesLoaded: false,\n      errors: []\n    };\n\n    // 任务1: 批量加载标注数据\n    if (window.PlantAnnotationTool?.annotationManager) {\n      loadingTasks.push(\n        window.PlantAnnotationTool.annotationManager.getAllAnnotationsInBulk()\n          .then(bulkAnnotations => {\n            if (bulkAnnotations) {\n              loadingResults.annotations = bulkAnnotations;\n              loadingResults.annotationsLoaded = true;\n              performanceMonitor?.recordNetworkRequest('annotations', true);\n              performanceMonitor?.recordDataLoaded('annotations', \n                Object.keys(bulkAnnotations.plantAnnotations || {}).length + \n                Object.keys(bulkAnnotations.imageAnnotations || {}).length\n              );\n              console.log('[批量加载] 标注数据加载成功');\n              updateFullscreenLoading(60, 'Annotations loaded successfully...', 'Processing bulk annotation data');\n            } else {\n              console.log('[批量加载] 标注批量API不可用，将使用懒加载模式');\n              performanceMonitor?.recordFallback('标注批量API不可用');\n            }\n          })\n          .catch(error => {\n            console.warn('[批量加载] 标注数据加载失败:', error.message);\n            performanceMonitor?.recordError(error, '标注数据批量加载');\n            loadingResults.errors.push(`标注加载失败: ${error.message}`);\n          })\n      );\n    }\n\n    // 任务2: 批量加载笔记数据\n    if (window.PlantAnnotationTool?.noteManager) {\n      loadingTasks.push(\n        window.PlantAnnotationTool.noteManager.getAllNotesInBulk()\n          .then(bulkNotes => {\n            if (bulkNotes) {\n              loadingResults.notes = bulkNotes;\n              loadingResults.notesLoaded = true;\n              performanceMonitor?.recordNetworkRequest('notes', true);\n              performanceMonitor?.recordDataLoaded('notes',\n                Object.keys(bulkNotes.plantNotes || {}).length +\n                Object.keys(bulkNotes.imageNotes || {}).length\n              );\n              console.log('[批量加载] 笔记数据加载成功');\n              updateFullscreenLoading(80, 'Notes loaded successfully...', 'Processing bulk note data');\n            } else {\n              console.log('[批量加载] 笔记批量API不可用，将使用懒加载模式');\n              performanceMonitor?.recordFallback('笔记批量API不可用');\n            }\n          })\n          .catch(error => {\n            console.warn('[批量加载] 笔记数据加载失败:', error.message);\n            performanceMonitor?.recordError(error, '笔记数据批量加载');\n            loadingResults.errors.push(`笔记加载失败: ${error.message}`);\n          })\n      );\n    }\n\n    // 等待所有加载任务完成\n    await Promise.allSettled(loadingTasks);\n    performanceMonitor?.addCheckpoint('并行数据加载完成');\n\n    updateFullscreenLoading(90, 'Processing loaded data...', 'Updating caches and preparing UI components');\n\n    // 生成最终状态消息\n    const loadedComponents = [];\n    if (loadingResults.annotationsLoaded) {\n      const annotationStats = loadingResults.annotations.statistics || {};\n      const totalAnnotations = annotationStats.totalAnnotations || 0;\n      loadedComponents.push(`${totalAnnotations} annotations`);\n    }\n    if (loadingResults.notesLoaded) {\n      const noteStats = loadingResults.notes.statistics || {};\n      const totalNotes = noteStats.totalNotes || 0;\n      loadedComponents.push(`${totalNotes} notes`);\n    }\n\n    const loadedMessage = loadedComponents.length > 0 \n      ? `All data loaded: ${plants.length} plants, ${loadedComponents.join(', ')}`\n      : `Dataset loaded: ${plants.length} plants (bulk APIs not available)`;\n\n    updateFullscreenLoading(95, 'Finalizing initialization...', loadedMessage);\n\n    // 🔧 PERFORMANCE: 预填充缓存以获得即时徽章更新\n    if (loadingResults.notesLoaded && window.PlantAnnotationTool?.noteUI) {\n      try {\n        await window.PlantAnnotationTool.noteUI.updateAllPlantNoteBadgesFromBulk(loadingResults.notes);\n        performanceMonitor?.addCheckpoint('笔记徽章预填充完成');\n        console.log('[批量加载] 笔记徽章预填充完成');\n      } catch (error) {\n        console.warn('[批量加载] 笔记徽章预填充失败:', error.message);\n        performanceMonitor?.recordError(error, '笔记徽章预填充');\n      }\n    }\n\n    updateFullscreenLoading(100, 'Initialization complete!', 'All systems ready - entering main application');\n    \n    // 🔧 WAIT FOR COMPLETE LOADING: 只有在所有数据加载完成后才进入主应用\n    console.log(`[完整加载] 数据加载完成 - 标注: ${loadingResults.annotationsLoaded}, 笔记: ${loadingResults.notesLoaded}`);\n    \n    if (loadingResults.errors.length > 0) {\n      console.warn('[完整加载] 部分数据加载失败:', loadingResults.errors);\n    }\n\n    // 🔧 PERFORMANCE: 结束性能监控并生成报告\n    let performanceReport = null;\n    if (performanceMonitor) {\n      performanceReport = performanceMonitor.endMonitoring();\n      console.log('🚀 [性能报告] 批量加载性能:', performanceReport);\n      \n      // 将性能报告存储到全局对象中以便调试\n      window.PlantAnnotationTool.lastPerformanceReport = performanceReport;\n    }\n\n    // 短暂显示成功状态，然后进入主应用\n    setTimeout(() => {\n      hideFullscreenLoading();\n      \n      // 显示植物列表\n      renderPlantList(plants);\n      \n      // 初始更新统计显示\n      updateProgressStats();\n      \n      // 更新进度信息\n      updateProgressInfo(loadedMessage);\n      \n      // 显示性能信息（如果有的话）\n      if (performanceReport && performanceReport.performanceGrade) {\n        const gradeMsg = `性能评级: ${performanceReport.performanceGrade} (${performanceReport.summary.totalLoadingTime})`;\n        console.log(`[完整加载] ${gradeMsg}`);\n      }\n      \n      console.log(`[完整加载] 应用启动完成: ${plants.length} 个植物, 标注已加载: ${loadingResults.annotationsLoaded}, 笔记已加载: ${loadingResults.notesLoaded}`);\n    }, 1500); // 稍长的延迟以显示完成状态\n    \n  } catch (error) {\n    console.error('自动连接数据集失败:', error);\n    \n    // 记录错误到性能监控\n    performanceMonitor?.recordError(error, '数据集连接失败');\n    performanceMonitor?.endMonitoring();\n    \n    if (error instanceof ConnectionError) {\n      hideFullscreenLoading();\n      showConnectionError(error);\n    } else {\n      hideFullscreenLoading();\n      showError('数据集连接失败', `${error.message}\\n\\n请检查网络连接和后端服务状态`);\n    }\n    \n    throw error;\n  }\n}\n\n/**\n * 自定义连接错误类\n */\nclass ConnectionError extends Error {\n  constructor(title, message, details = {}) {\n    super(message);\n    this.name = 'ConnectionError';\n    this.title = title;\n    this.details = details;\n  }\n}\n\n/**\n * 显示连接错误的专门处理\n */\nfunction showConnectionError(error) {\n  const errorMessage = `${error.title}\\n\\n${error.message}`;\n  const detailMessage = error.details.suggestion ? \n    `\\n\\n建议解决方案：\\n${error.details.suggestion}` : '';\n  \n  showError(\n    '后端服务连接失败', \n    errorMessage + detailMessage + '\\n\\n服务器地址: ' + (error.details.serverUrl || 'http://localhost:3003')\n  );\n  \n  // 添加重试按钮到错误模态框\n  addRetryButton();\n}\n\n/**\n * 添加重试按钮到错误模态框\n */\nfunction addRetryButton() {\n  const errorModal = document.getElementById('error-modal');\n  if (!errorModal) return;\n  \n  // 检查是否已存在重试按钮\n  if (errorModal.querySelector('.retry-button')) return;\n  \n  const retryButton = document.createElement('button');\n  retryButton.textContent = '重试连接';\n  retryButton.className = 'retry-button';\n  retryButton.style.cssText = `\n    margin-left: 10px;\n    padding: 8px 16px;\n    background-color: #007bff;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n  `;\n  \n  retryButton.onclick = async () => {\n    errorModal.style.display = 'none';\n    showFullscreenLoading();\n    \n    try {\n      await autoConnectDataset();\n    } catch (retryError) {\n      console.error('重试失败:', retryError);\n    }\n  };\n  \n  // 添加到错误模态框的按钮区域\n  const buttonArea = errorModal.querySelector('.error-buttons') || errorModal;\n  buttonArea.appendChild(retryButton);\n}\n\n// 🔧 NEW: Delete Plant Annotations Functionality\n\n/**\n * 🔧 NEW: Setup deletion scope options in the modal\n */\nasync function setupDeletionScopeOptions(plantId) {\n  const modal = document.getElementById('delete-plant-annotations-modal');\n  const futureImagesInfo = document.getElementById('future-images-info');\n  const futureImagesCount = document.getElementById('future-images-count');\n  \n  // Reset deletion scope to default\n  const plantAllOption = modal.querySelector('input[name=\"deletion-scope\"][value=\"plant-all\"]');\n  if (plantAllOption) {\n    plantAllOption.checked = true;\n  }\n  \n  // Hide future images info initially\n  if (futureImagesInfo) {\n    futureImagesInfo.style.display = 'none';\n  }\n  \n  // Check if there's a current image context for spreading deletion\n  if (appState.currentImage && appState.currentPlant && appState.currentPlant.id === plantId) {\n    try {\n      // Get future images for spreading deletion\n      const futureImages = await getFutureImagesForClearing();\n      const futureCount = futureImages ? futureImages.length : 0;\n      \n      if (futureCount > 0) {\n        // Show future images info\n        if (futureImagesInfo && futureImagesCount) {\n          futureImagesCount.textContent = futureCount;\n          futureImagesInfo.style.display = 'block';\n        }\n        \n        // Enable current+future option\n        const currentFutureOption = modal.querySelector('input[name=\"deletion-scope\"][value=\"current-and-future\"]');\n        if (currentFutureOption) {\n          currentFutureOption.disabled = false;\n          currentFutureOption.parentElement.style.opacity = '1';\n        }\n        \n        // Enable current-only option\n        const currentOnlyOption = modal.querySelector('input[name=\"deletion-scope\"][value=\"current-only\"]');\n        if (currentOnlyOption) {\n          currentOnlyOption.disabled = false;\n          currentOnlyOption.parentElement.style.opacity = '1';\n        }\n      } else {\n        // Disable current+future option if no future images\n        disableScopeOption('current-and-future', 'No future images available');\n        disableScopeOption('current-only', 'Current image only (basic clear)');\n      }\n    } catch (error) {\n      console.warn('Failed to check future images for deletion scope:', error);\n      disableScopeOption('current-and-future', 'Cannot determine future images');\n      disableScopeOption('current-only', 'Current image context unavailable');\n    }\n  } else {\n    // No current image context - disable spreading options\n    disableScopeOption('current-and-future', 'No current image selected');\n    disableScopeOption('current-only', 'No current image selected');\n  }\n  \n  // Add event listener for scope changes\n  const scopeOptions = modal.querySelectorAll('input[name=\"deletion-scope\"]');\n  scopeOptions.forEach(option => {\n    option.addEventListener('change', handleDeletionScopeChange);\n  });\n}\n\n/**\n * 🔧 NEW: Disable a deletion scope option with reason\n */\nfunction disableScopeOption(value, reason) {\n  const modal = document.getElementById('delete-plant-annotations-modal');\n  const option = modal.querySelector(`input[name=\"deletion-scope\"][value=\"${value}\"]`);\n  if (option) {\n    option.disabled = true;\n    option.parentElement.style.opacity = '0.5';\n    option.parentElement.title = reason;\n  }\n}\n\n/**\n * 🔧 NEW: Handle deletion scope change\n */\nfunction handleDeletionScopeChange() {\n  const selectedScope = document.querySelector('input[name=\"deletion-scope\"]:checked');\n  const confirmCheckbox = document.getElementById('delete-confirmation-checkbox');\n  const confirmButton = document.getElementById('delete-confirm-btn');\n  \n  if (selectedScope) {\n    const scope = selectedScope.value;\n    \n    // Update confirmation text based on scope\n    const confirmText = confirmCheckbox.parentElement.querySelector('span');\n    if (confirmText) {\n      switch (scope) {\n        case 'plant-all':\n          confirmText.textContent = 'I understand that this action is irreversible and will delete all annotation data for this plant';\n          break;\n        case 'current-and-future':\n          confirmText.textContent = 'I understand that this action is irreversible and will delete current and future annotations';\n          break;\n        case 'current-only':\n          confirmText.textContent = 'I understand that this action is irreversible and will delete the current image annotations';\n          break;\n      }\n    }\n    \n    // Update button text based on scope\n    if (confirmButton) {\n      switch (scope) {\n        case 'plant-all':\n          confirmButton.textContent = '🗑️ Delete All Plant Annotations';\n          break;\n        case 'current-and-future':\n          confirmButton.textContent = '⚡ Delete Current + Future';\n          break;\n        case 'current-only':\n          confirmButton.textContent = '🗑️ Delete Current Image';\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Handle delete plant annotations button click\n */\nasync function handleDeletePlantAnnotations() {\n  if (!appState.currentPlant) {\n    showError('删除失败', '请先选择植物');\n    return;\n  }\n  \n  console.log(`[Delete Plant] 开始删除植物 ${appState.currentPlant.id} 的标注`);\n  \n  // Show the confirmation modal and load statistics\n  await showDeletePlantAnnotationsModal(appState.currentPlant.id);\n}\n\n/**\n * Show delete plant annotations modal with statistics\n */\nasync function showDeletePlantAnnotationsModal(plantId) {\n  const modal = document.getElementById('delete-plant-annotations-modal');\n  const plantIdElement = document.getElementById('delete-plant-id');\n  const statsLoading = document.getElementById('stats-loading');\n  const statsContent = document.getElementById('stats-content');\n  const confirmCheckbox = document.getElementById('delete-confirmation-checkbox');\n  const confirmButton = document.getElementById('delete-confirm-btn');\n  \n  if (!modal) return;\n  \n  // Reset modal state\n  plantIdElement.textContent = plantId;\n  statsLoading.style.display = 'block';\n  statsContent.style.display = 'none';\n  confirmCheckbox.checked = false;\n  confirmButton.disabled = true;\n  \n  // 🔧 NEW: Setup deletion scope options\n  setupDeletionScopeOptions(plantId);\n  \n  // Show modal\n  modal.style.display = 'flex';\n  \n  try {\n    // Load plant annotation statistics\n    console.log(`[Delete Plant] 加载植物 ${plantId} 的统计信息`);\n    const response = await fetch(`http://localhost:3003/api/annotations/plant/${plantId}/stats`);\n    const result = await response.json();\n    \n    if (result.success) {\n      // Update statistics display\n      document.getElementById('annotation-files-count').textContent = result.statistics.annotationFiles;\n      document.getElementById('annotation-points-count').textContent = result.statistics.totalAnnotationPoints;\n      document.getElementById('related-files-count').textContent = result.statistics.relatedFiles;\n      document.getElementById('total-files-count').textContent = result.statistics.totalFiles;\n      \n      // Show statistics\n      statsLoading.style.display = 'none';\n      statsContent.style.display = 'block';\n      \n      console.log(`[Delete Plant] 统计加载完成: ${result.statistics.totalFiles} 个文件, ${result.statistics.totalAnnotationPoints} 个标注点`);\n      \n      // Store statistics for later use\n      modal.dataset.plantStats = JSON.stringify(result.statistics);\n    } else {\n      throw new Error(result.error || '获取统计信息失败');\n    }\n  } catch (error) {\n    console.error(`[Delete Plant] 加载统计信息失败:`, error);\n    statsLoading.innerHTML = `<span style=\"color: #dc2626;\">❌ 加载统计信息失败: ${error.message}</span>`;\n  }\n}\n\n/**\n * Hide delete plant annotations modal\n */\nfunction hideDeletePlantAnnotationsModal() {\n  const modal = document.getElementById('delete-plant-annotations-modal');\n  if (modal) {\n    modal.style.display = 'none';\n    \n    // Reset modal state\n    const confirmCheckbox = document.getElementById('delete-confirmation-checkbox');\n    const confirmButton = document.getElementById('delete-confirm-btn');\n    if (confirmCheckbox) confirmCheckbox.checked = false;\n    if (confirmButton) {\n      confirmButton.disabled = true;\n      // 🔧 FIX: Also restore button text to default when hiding modal\n      confirmButton.textContent = '🗑️ Delete All Annotations';\n    }\n  }\n}\n\n/**\n * Handle confirmation checkbox change\n */\nfunction handleDeleteConfirmationChange() {\n  const confirmCheckbox = document.getElementById('delete-confirmation-checkbox');\n  const confirmButton = document.getElementById('delete-confirm-btn');\n  \n  if (confirmCheckbox && confirmButton) {\n    confirmButton.disabled = !confirmCheckbox.checked;\n  }\n}\n\n/**\n * Confirm and execute plant annotations deletion\n */\nasync function confirmDeletePlantAnnotations() {\n  if (!appState.currentPlant) {\n    showError('删除失败', '未选择植物');\n    return;\n  }\n  \n  const plantId = appState.currentPlant.id;\n  const modal = document.getElementById('delete-plant-annotations-modal');\n  const confirmButton = document.getElementById('delete-confirm-btn');\n  \n  if (!modal || !confirmButton) return;\n  \n  // 🔧 NEW: Get selected deletion scope\n  const selectedScope = modal.querySelector('input[name=\"deletion-scope\"]:checked');\n  const deletionScope = selectedScope ? selectedScope.value : 'plant-all';\n  \n  try {\n    // Show loading state\n    const originalText = confirmButton.textContent;\n    confirmButton.textContent = '⏳ Deleting...';\n    confirmButton.disabled = true;\n    \n    console.log(`[Delete Plant] 开始删除植物 ${plantId} 的标注，范围: ${deletionScope}`);\n    \n    let result;\n    \n    switch (deletionScope) {\n      case 'plant-all':\n        // Execute full plant deletion via API\n        result = await executeFullPlantDeletion(plantId);\n        break;\n        \n      case 'current-and-future':\n        // Execute spreading deletion\n        result = await executeSpreadingDeletion(plantId);\n        break;\n        \n      case 'current-only':\n        // Execute current image only deletion\n        result = await executeCurrentImageDeletion(plantId);\n        break;\n        \n      default:\n        throw new Error(`Unknown deletion scope: ${deletionScope}`);\n    }\n    \n    if (result.success) {\n      console.log(`[Delete Plant] 删除成功:`, result.statistics);\n      \n      // 🔧 FIX: Restore button text before hiding modal\n      confirmButton.textContent = originalText;\n      \n      // Hide modal\n      hideDeletePlantAnnotationsModal();\n      \n      // Show success message with statistics\n      const stats = result.statistics;\n      const successMessage = createSuccessMessage(plantId, deletionScope, stats);\n      showSuccess('删除成功', successMessage);\n      \n      // Update progress and UI\n      updateProgressInfo(`植物 ${plantId} 的标注数据已删除 (${deletionScope})`);\n      \n      // Handle UI updates based on deletion scope\n      await handlePostDeletionUpdates(plantId, deletionScope);\n      \n    } else {\n      throw new Error(result.error || '删除操作失败');\n    }\n    \n  } catch (error) {\n    console.error(`[Delete Plant] 删除植物 ${plantId} 失败:`, error);\n    \n    // Restore button state\n    confirmButton.textContent = originalText;\n    confirmButton.disabled = false;\n    \n    showError('删除失败', `删除植物 ${plantId} 的标注数据时出错: ${error.message}`);\n  }\n}\n\n/**\n * 🔧 NEW: Execute full plant deletion via API\n */\nasync function executeFullPlantDeletion(plantId) {\n  const response = await fetch(`http://localhost:3003/api/annotations/plant/${plantId}`, {\n    method: 'DELETE',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  \n  return await response.json();\n}\n\n/**\n * 🔧 NEW: Execute spreading deletion (current + future images)\n */\nasync function executeSpreadingDeletion(plantId) {\n  if (!appState.currentImage || !appState.currentPlant) {\n    throw new Error('No current image context for spreading deletion');\n  }\n  \n  try {\n    // Get future images\n    const futureImages = await getFutureImagesForClearing();\n    const allImages = [appState.currentImage, ...futureImages];\n    \n    let deletedCount = 0;\n    let errors = [];\n    \n    // Delete annotations for each image\n    for (const image of allImages) {\n      try {\n        // 🔧 FIX: For current image, clear workspace FIRST to prevent auto-save interference\n        if (image.id === appState.currentImage.id && annotationTool) {\n          console.log(`[Spreading Delete] Clearing current image workspace: ${image.id}`);\n          annotationTool.clearKeypoints();\n          \n          // Update annotation status display immediately to reflect cleared state\n          if (typeof updateAnnotationStatusDisplay === 'function') {\n            setTimeout(updateAnnotationStatusDisplay, 100);\n          }\n        }\n        \n        // Clear annotation storage for this image\n        await clearAnnotationsForImage(image.id);\n        \n        deletedCount++;\n        updateProgressInfo(`已清除 ${deletedCount}/${allImages.length} 个图像...`);\n      } catch (error) {\n        console.error(`Failed to clear image ${image.id}:`, error);\n        errors.push(`${image.id}: ${error.message}`);\n      }\n    }\n    \n    // Update thumbnails\n    if (window.refreshThumbnailAnnotationStatus) {\n      for (const image of allImages) {\n        await window.refreshThumbnailAnnotationStatus(image.id);\n      }\n    }\n    \n    return {\n      success: true,\n      statistics: {\n        totalFilesDeleted: deletedCount,\n        totalFilesProcessed: allImages.length,\n        annotationFilesDeleted: deletedCount,\n        relatedFilesDeleted: 0,\n        backupPath: 'N/A (in-memory operation)',\n        errors: errors\n      }\n    };\n    \n  } catch (error) {\n    console.error('Spreading deletion failed:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\n\n/**\n * 🔧 NEW: Execute current image only deletion\n */\nasync function executeCurrentImageDeletion(plantId) {\n  if (!appState.currentImage) {\n    throw new Error('No current image selected');\n  }\n  \n  try {\n    await clearAnnotationsForImage(appState.currentImage.id);\n    \n    // Update thumbnail\n    if (window.refreshThumbnailAnnotationStatus) {\n      await window.refreshThumbnailAnnotationStatus(appState.currentImage.id);\n    }\n    \n    // Clear from annotation tool\n    if (annotationTool) {\n      annotationTool.clearKeypoints();\n    }\n    \n    return {\n      success: true,\n      statistics: {\n        totalFilesDeleted: 1,\n        totalFilesProcessed: 1,\n        annotationFilesDeleted: 1,\n        relatedFilesDeleted: 0,\n        backupPath: 'N/A (single image operation)'\n      }\n    };\n    \n  } catch (error) {\n    console.error('Current image deletion failed:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\n\n/**\n * 🔧 NEW: Create success message based on deletion scope\n */\nfunction createSuccessMessage(plantId, deletionScope, stats) {\n  let message = `植物 ${plantId} 的标注数据删除完成\\n\\n`;\n  \n  switch (deletionScope) {\n    case 'plant-all':\n      message += `删除文件: ${stats.totalFilesDeleted}/${stats.totalFilesProcessed}\\n`;\n      message += `标注文件: ${stats.annotationFilesDeleted}\\n`;\n      message += `相关文件: ${stats.relatedFilesDeleted}\\n`;\n      if (stats.backupPath) {\n        message += `备份已创建: ${stats.backupPath}`;\n      }\n      break;\n      \n    case 'current-and-future':\n      message += `传播删除完成\\n`;\n      message += `处理图像: ${stats.totalFilesDeleted}/${stats.totalFilesProcessed}\\n`;\n      if (stats.errors && stats.errors.length > 0) {\n        message += `错误: ${stats.errors.length} 个图像删除失败`;\n      }\n      break;\n      \n    case 'current-only':\n      message += `当前图像标注已清除\\n`;\n      message += `图像ID: ${appState.currentImage?.id || 'unknown'}`;\n      break;\n  }\n  \n  return message;\n}\n\n/**\n * 🔧 NEW: Handle post-deletion UI updates based on scope\n */\nasync function handlePostDeletionUpdates(plantId, deletionScope) {\n  switch (deletionScope) {\n    case 'plant-all':\n      // Clear current workspace if this was the current plant\n      if (appState.currentPlant && appState.currentPlant.id === plantId) {\n        initializeEmptyWorkspace();\n        \n        // Update plant status in the list\n        const plant = appState.plants.find(p => p.id === plantId);\n        if (plant) {\n          plant.status = 'pending'; // Reset to pending after deletion\n          \n          // Re-render the plant list item\n          const plantItem = document.querySelector(`[data-plant-id=\"${plantId}\"]`);\n          if (plantItem) {\n            const newItem = createPlantListItem(plant);\n            plantItem.parentNode.replaceChild(newItem, plantItem);\n          }\n        }\n      }\n      break;\n      \n    case 'current-and-future':\n    case 'current-only':\n      // Update annotation status display\n      if (typeof updateAnnotationStatusDisplay === 'function') {\n        await updateAnnotationStatusDisplay();\n      }\n      break;\n  }\n  \n  // Update statistics for all deletion scopes\n  if (typeof updateProgressStats === 'function') {\n    updateProgressStats();\n  }\n  \n  // Refresh note badges (since annotations are deleted, notes might be affected)\n  if (window.PlantAnnotationTool?.noteUI) {\n    await window.PlantAnnotationTool.noteUI.updateAllPlantNoteBadges();\n  }\n}\n\n/**\n * 🔧 NEW: Update complete plant button state based on current plant selection\n */\nfunction updateCompletePlantButtonState() {\n  const completeButton = document.getElementById('complete-plant-btn');\n  if (!completeButton) return;\n  \n  if (appState.currentPlant) {\n    const plant = appState.currentPlant;\n    \n    if (plant.status === 'completed') {\n      // Show as uncomplete button\n      completeButton.textContent = 'Uncomplete Plant';\n      completeButton.className = 'btn btn-warning';\n      completeButton.title = `撤销完成植株 ${plant.id}`;\n      completeButton.disabled = false;\n    } else if (plant.status === 'skipped') {\n      // Disable for skipped plants\n      completeButton.textContent = 'Complete Plant';\n      completeButton.className = 'btn btn-success';\n      completeButton.title = '无法完成已跳过的植株，请先撤销跳过';\n      completeButton.disabled = true;\n    } else {\n      // Show as complete button (pending/in-progress)\n      completeButton.textContent = 'Complete Plant';\n      completeButton.className = 'btn btn-success';\n      completeButton.title = `标记植株 ${plant.id} 为完成`;\n      completeButton.disabled = false;\n    }\n  } else {\n    // No plant selected\n    completeButton.textContent = 'Complete Plant';\n    completeButton.className = 'btn btn-success';\n    completeButton.title = '请先选择植物';\n    completeButton.disabled = true;\n  }\n}\n\n/**\n * Update delete button state based on current plant selection\n */\nfunction updateDeletePlantAnnotationsButtonState() {\n  const deleteButton = document.getElementById('delete-plant-annotations-btn');\n  if (!deleteButton) return;\n  \n  if (appState.currentPlant) {\n    deleteButton.disabled = false;\n    deleteButton.title = `删除植物 ${appState.currentPlant.id} 的所有标注数据`;\n  } else {\n    deleteButton.disabled = true;\n    deleteButton.title = '请先选择植物';\n  }\n}\n\n// 将删除按钮状态更新函数暴露到全局，供其他模块调用\nwindow.updateDeletePlantAnnotationsButtonState = updateDeletePlantAnnotationsButtonState;\n\n/**\n * 🔧 SIMPLIFIED: Handle clear all annotations - simple current image only\n */\nasync function handleClearAllAnnotations() {\n  if (!annotationTool) {\n    showError('清除失败', '标注工具未初始化');\n    return;\n  }\n  \n  const currentAnnotations = annotationTool.getAnnotationData();\n  if (currentAnnotations.keypoints.length === 0) {\n    showError('清除失败', '当前图像没有标注点');\n    return;\n  }\n  \n  // Simple confirmation dialog without spreading options\n  const message = `确定要清除当前图像的 ${currentAnnotations.keypoints.length} 个标注点吗？`;\n  \n  if (confirm(message)) {\n    // Clear current image only\n    annotationTool.clearKeypoints();\n    updateProgressInfo('已清除当前图像的标注');\n    \n    // Update thumbnail status\n    if (window.refreshThumbnailAnnotationStatus && appState.currentImage) {\n      await window.refreshThumbnailAnnotationStatus(appState.currentImage.id);\n    }\n    \n    // Update annotation status display\n    if (typeof updateAnnotationStatusDisplay === 'function') {\n      updateAnnotationStatusDisplay();\n    }\n  }\n}\n\n/**\n * 🔧 NEW: Handle SIFT matching\n */\nasync function handleSiftMatch() {\n  if (!annotationTool) {\n    showError('SIFT匹配失败', '标注工具未初始化');\n    return;\n  }\n  \n  if (!appState.currentPlant) {\n    showError('SIFT匹配失败', '请先选择植物');\n    return;\n  }\n  \n  // 禁用SIFT按钮防止重复点击\n  const siftBtn = document.getElementById('sift-match-btn');\n  if (siftBtn) {\n    siftBtn.disabled = true;\n    siftBtn.textContent = '⏳';\n  }\n  \n  try {\n    console.log('[SIFT] 开始执行SIFT匹配');\n    \n    // 调用AnnotationTool的SIFT匹配功能\n    await annotationTool.performSiftMatching();\n    \n  } catch (error) {\n    console.error('[SIFT] 匹配失败:', error);\n    showError('SIFT匹配失败', error.message || '执行SIFT匹配时发生错误');\n  } finally {\n    // 恢复SIFT按钮状态\n    if (siftBtn) {\n      siftBtn.disabled = false;\n      siftBtn.textContent = '🔍';\n    }\n  }\n}\n\n/**\n * 🔧 REMOVED: Handle spreading clear (Shift+Click) \n * This functionality has been moved to delete-plant-annotations-btn\n * to avoid duplication and user confusion.\n */\n// async function handleSpreadingClear() { ... } - REMOVED\n\n/**\n * 🔧 NEW: Get future images for clearing (simplified version)\n */\nasync function getFutureImagesForClearing() {\n  if (!appState.currentImage || !appState.currentPlant || !plantDataManager) {\n    return [];\n  }\n  \n  try {\n    // Get all images for current plant and view angle\n    const allImages = await plantDataManager.getPlantImages(\n      appState.currentPlant.id, \n      appState.currentPlant.selectedViewAngle\n    );\n    \n    if (!allImages || allImages.length === 0) {\n      return [];\n    }\n    \n    // Find current image index\n    const currentImageIndex = allImages.findIndex(img => img.id === appState.currentImage.id);\n    if (currentImageIndex === -1) {\n      return [];\n    }\n    \n    // Get current image date for comparison\n    const currentImage = allImages[currentImageIndex];\n    const currentDate = new Date(currentImage.dateTime);\n    \n    // Filter future images (images with later dates)\n    const futureImages = allImages.filter(img => {\n      const imgDate = new Date(img.dateTime);\n      return imgDate > currentDate;\n    });\n    \n    // Sort by date\n    futureImages.sort((a, b) => new Date(a.dateTime) - new Date(b.dateTime));\n    \n    return futureImages;\n    \n  } catch (error) {\n    console.error('Failed to get future images:', error);\n    return [];\n  }\n}\n\n/**\n * 🔧 NEW: Clear annotations for a specific image\n */\nasync function clearAnnotationsForImage(imageId) {\n  if (!plantDataManager) {\n    throw new Error('PlantDataManager not available');\n  }\n  \n  try {\n    // Save empty annotations (effectively clearing them)\n    await plantDataManager.saveImageAnnotations(imageId, []);\n    console.log(`Cleared annotations for image: ${imageId}`);\n  } catch (error) {\n    console.error(`Failed to clear annotations for image ${imageId}:`, error);\n    throw error;\n  }\n}\n\n/**\n * 🔧 NEW: Perform clear operation with optional spreading\n */\nasync function performClearOperation(options) {\n  if (!annotationTool || !appState.currentImage || !appState.currentPlant) {\n    showError('清除失败', '应用状态无效');\n    return;\n  }\n  \n  const { clearScope, clearAllPoints, clearAnnotationsOnly } = options;\n  \n  try {\n    // Always clear current image first\n    console.log('Clearing annotations for current image:', appState.currentImage.id);\n    \n    if (clearAllPoints) {\n      annotationTool.clearKeypoints();\n    } else if (clearAnnotationsOnly) {\n      // Clear only annotations but preserve UI state\n      annotationTool.clearKeypointsWithoutSave();\n    }\n    \n    let processedImages = 1; // Current image\n    let affectedImages = [appState.currentImage.id];\n    \n    // If spreading deletion is requested\n    if (clearScope === 'current-and-future' && annotationSpreadingManager) {\n      // Show progress modal\n      const progressModalId = spreadingModalManager.showSpreadProgress({\n        operationId: `clear-spread-${Date.now()}`,\n        totalImages: 0, // Will be updated\n        onCancel: () => {\n          console.log('User cancelled clear spreading operation');\n        }\n      });\n      \n      try {\n        // Get future images\n        const futureImages = await annotationSpreadingManager.getFutureImages(\n          appState.currentImage.id,\n          appState.currentPlant.id,\n          appState.currentPlant.selectedViewAngle\n        );\n        \n        if (futureImages.length > 0) {\n          // Update progress modal with actual count\n          spreadingModalManager.updateSpreadProgress(progressModalId, {\n            completed: 1,\n            total: futureImages.length + 1,\n            status: 'Clearing future images...'\n          });\n          \n          // Perform spreading deletion\n          const result = await annotationSpreadingManager.spreadDeletionToFuture(\n            appState.currentImage.id,\n            appState.currentPlant.id,\n            appState.currentPlant.selectedViewAngle,\n            {\n              clearAllPoints,\n              clearAnnotationsOnly,\n              batchSize: spreadingConfigManager?.getConfigValue('spreadBehavior.batchSize') || 10,\n              onProgress: (progress) => {\n                spreadingModalManager.updateSpreadProgress(progressModalId, {\n                  ...progress,\n                  completed: progress.completed + 1, // +1 for current image already processed\n                  total: futureImages.length + 1\n                });\n              }\n            }\n          );\n          \n          processedImages += result.processedImages || 0;\n          affectedImages = affectedImages.concat(result.affectedImages || []);\n        }\n        \n        // Close progress modal\n        spreadingModalManager.closeModal(progressModalId);\n        \n      } catch (error) {\n        console.error('Spreading deletion failed:', error);\n        spreadingModalManager.closeModal(progressModalId);\n        spreadingModalManager.showError(\n          'Spreading Deletion Failed',\n          `Failed to clear annotations from future images: ${error.message}`\n        );\n      }\n    }\n    \n    // Show success message\n    const message = clearScope === 'current-and-future' \n      ? `成功清除 ${processedImages} 个图像的标注`\n      : '成功清除当前图像的标注';\n    \n    updateProgressInfo(message);\n    \n    // Refresh thumbnails for affected images\n    if (affectedImages.length > 0) {\n      for (const imageId of affectedImages) {\n        await refreshThumbnailAnnotationStatus(imageId);\n      }\n    }\n    \n    // Update statistics\n    updateProgressStats();\n    \n    // Update annotation status display\n    updateAnnotationStatusDisplay();\n    \n    console.log(`Clear operation completed. Processed ${processedImages} images.`);\n    \n    // Show success modal for spreading operations\n    if (clearScope === 'current-and-future' && processedImages > 1) {\n      spreadingModalManager.showSuccess(\n        'Clear Complete',\n        `Successfully cleared annotations from ${processedImages} images in the time series.`\n      );\n    }\n    \n  } catch (error) {\n    console.error('Clear operation failed:', error);\n    showError('清除失败', `清除标注时出错: ${error.message}`);\n  }\n}"],"names":["HttpFileSystemManager","constructor","this","baseUrl","datasetPath","isInitialized","maxRetries","retryDelay","connectionTimeout","lastConnectionCheck","connectionCheckInterval","initialize","withRetry","async","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","signal","headers","clearTimeout","ok","Error","status","statusText","json","success","Date","now","console","log","error","name","isSupported","operation","operationName","lastError","attempt","delay","isConnectionError","warn","message","includes","ms","Promise","resolve","checkConnection","isConnected","getDatasetInfo","ensureConnection","result","data","traversePlantDirectories","length","readPlantImages","plantId","encodeURIComponent","imagesByView","totalImages","Object","values","reduce","total","images","getImageUrl","viewAngle","imageName","createImageURL","imageData","parts","id","split","slice","join","imageUrl","saveAnnotationFile","imageId","annotationData","method","body","JSON","stringify","loadAnnotationFile","annotations","getAllAnnotationFiles","deleteAnnotationFile","getDirectoryStats","dirPath","url","isImageFile","filename","ext","toLowerCase","substring","lastIndexOf","parseImageDateTime","match","dateStr","hourStr","formatImageTime","date","getFullYear","getMonth","getDate","getAllSkipInfo","getSkipInfo","saveSkipInfo","skipData","deleteSkipInfo","getPlantStatus","savePlantStatus","lastModified","toISOString","deletePlantStatus","cleanup","getAnnotationsDirectory","exists","ensureAnnotationsDirectory","AnnotationStorageManager","apiBaseUrl","Map","imageAnnotations","fileSystemManager","useFileSystem","setFileSystemManager","annotationsHandle","scanAnnotationFiles","loadAnnotationsFromServer","loadImageAnnotationsFromServer","serverError","loadFromLocalStorage","loadImageAnnotationsFromLocalStorage","entries","set","size","saveAnnotationsToServer","exportData","saveTime","totalPlants","saveToLocalStorage","localStorage","setItem","backup","getItem","parse","has","savePlantAnnotations","plantInfo","selectedImage","selectedImagePath","selectedViewAngle","imageDateTime","dateTime","keypointCount","timeSeriesData","isTimeSeriesEnabled","plantViewAngles","selectedViewAngleHistory","timeSeriesMetadata","getPlantAnnotations","get","getAnnotatedPlantIds","Array","from","keys","skipInfo","createdAt","skipReason","skipDate","apiError","fileName","fileHandle","getFileHandle","create","writable","createWritable","write","close","fsError","removeSkipInfo","delete","removeEntry","removeError","statusData","timestamp","loadPlantStatus","existingData","skipError","file","getFile","content","text","localData","parsed","localError","hasAnnotations","deletePlantAnnotations","getAnnotationStats","annotatedCount","completedCount","filter","annotated","completed","pending","completionRate","toFixed","exportAllAnnotations","exportTime","version","exportedAt","downloadAnnotationsAsJSON","blob","Blob","type","URL","createObjectURL","a","document","createElement","href","download","appendChild","click","removeChild","revokeObjectURL","exportPureImageAnnotations","pureImageAnnotations","map","annotation","x","y","direction","order","downloadPureImageAnnotationsAsJSON","pureAnnotations","stats","getPureAnnotationsStats","format","description","annotatedImages","totalKeypoints","averageKeypointsPerImage","setTimeSeriesManager","timeSeriesManager","clearAllAnnotations","clear","getSummary","summary","totalAnnotations","completedPlants","restoreTimeSeriesData","restorePlantTimeSeriesData","timeSequences","timeSeriesAnnotations","imageIds","item","viewAnnotations","metadata","isManualAdjustment","inheritedFrom","adjustmentKey","manualAdjustments","Set","add","getPlantViewAngleHistory","getPlantAnnotationSummary","availableViewAngles","currentImageInfo","timeSeriesStats","saveImageAnnotation","saveImageAnnotationToFileSystem","saveImageAnnotationsToLocalStorage","getImageAnnotation","exportAllImageAnnotations","getImageAnnotationStats","loadAnnotationsFromFileSystem","loadedCount","deleteImageAnnotationFromFileSystem","scanSkipInfoFiles","skipInfoData","skipFileCount","handle","kind","endsWith","TimeSeriesAnnotationManager","initializePlantTimeSeries","sort","b","img","firstImageId","lastImageId","saveAnnotations","plantAnnotations","timeSequence","currentImageIndex","indexOf","propagateAnnotations","savedImageId","propagatedCount","getPropagationCount","isFirstAnnotation","sourceImageId","sourceImageIndex","i","targetImageId","deepCloneAnnotations","getAnnotations","getAnnotationMetadata","imageIndex","isFirstImage","isLastImage","fromIndex","count","manual","inherited","coverage","clearPlantAnnotations","exportTimeSeriesData","push","allImageAnnotations","plantData","exportPlantImageAnnotations","plantImageAnnotations","getExportStats","plantStats","plantImages","plantAnnotatedImages","plantKeypoints","getDebugStatus","plantsCount","totalSequences","totalAnnotatedImages","plantDetails","plantDetail","viewAnglesCount","viewAngles","exportAllTimeSeriesDataDebug","debugData","managedPlants","allData","annotationCount","PlantDataManager","annotationStorage","plants","annotationStatus","loadingPlants","loadDataset","plantFolders","plantFolder","plant","createPlantData","restoreAnnotationStatus","localeCompare","restoreAnnotationStatusFromFileSystem","annotatedPlantIds","bulkAnnotationData","window","PlantAnnotationTool","annotationManager","getAllAnnotationsInBulk","restoreStatusFromBulkData","restoreStatusFromIndividualFiles","bulkData","startTime","performance","imageAnnotationsMap","plantAnnotationsMap","viewAngleStats","viewAnnotationCount","image","persistedStatus","endTime","allAnnotationFiles","annotationFileSet","path","imageCount","hasImages","loadedAt","loadPlantImageCount","view","emitPlantUpdated","getPlantList","getPlant","getPlantImages","checkLoading","updatePlantStatus","then","catch","skipPlant","reason","unskipPlant","newStatus","uncompletePlant","setSelectedViewAngle","setSelectedImage","initializeTimeSeriesIfNeeded","seriesInfo","options","currentImageId","findIndex","savedCount","saveAnnotationToFile","directionInfo","saveDirectionsOnly","finalAnnotations","mergeDirectionData","existingAnnotations","newAnnotations","merged","forEach","newAnnotation","existingIndex","existing","directionType","saveImageAnnotations","currentPlantId","appState","currentPlant","getCurrentPlantIdFromImage","getImageAnnotations","getCurrentImageAnnotationMetadata","getPlantTimeSeriesStats","shouldShowManualAdjustmentMode","getNextPendingPlant","find","currentIndex","getDetailedImageStats","completedImages","plantImageCount","plantStat","isCompleted","plantCompletionRate","pendingImages","getImageStats","detailed","getProgress","persistentStats","inProgress","skipped","totalCompleted","imageStats","Math","max","persistent","searchPlants","query","lowerQuery","filterPlantsByStatus","event","CustomEvent","detail","dispatchEvent","pureFormat","timeSeriesFormat","recommendation","debugTimeSeriesExport","timeSeriesStatus","storageAnnotations","comparison","timeSeriesManagerImages","pureExportImages","storageManagerPlants","storageData","saveAnnotationStatus","storageKey","savedData","savedAt","loadAnnotationStatus","saved","ensureAnnotationOrders","annotationsByType","annotationType","customTypeId","typeKey","totalFixed","typeAnnotations","hasOrderIssues","orders","kp","AnnotationTool","canvasId","canvas","getElementById","ctx","getContext","minZoom","maxZoom","zoomSpeed","baseKeypointRadius","minKeypointRadius","maxKeypointRadius","keypointScaleFactor","keypointLeftColor","keypointRightColor","keypointHoverColor","keypointSelectedColor","keypointBorderColor","keypointBorderWidth","labelThresholdScale","tinyThresholdScale","labelOffset","directionThreshold","directionArrowLength","state","scale","translateX","translateY","isDragging","isPanning","lastPanPoint","isDirectionDragging","dragStartPoint","currentDragPoint","previewKeypoint","selectedKeypoint","isDirectionSelectionMode","directionSelectionPoint","isAutoDirectionMode","autoDirectionIndex","autoDirectionKeypoints","isDirectionCountMode","currentDirectionCount","directionsSet","autoMoveToExpectedPosition","isCustomRegionDragging","customRegionStartPoint","customRegionCurrentPoint","currentImage","imageElement","imageLoaded","keypoints","hoveredKeypoint","draggedKeypoint","history","historyIndex","maxHistorySize","customAnnotationManager","customAnnotationRenderer","customAnnotationDragState","draggedAnnotation","startPosition","imageSwitchLock","isLocked","currentLoadingImageId","lockStartTime","autoDirectionMode","crossSectionalState","crossSectionalMap","bindEvents","initializeCanvas","initializeCustomAnnotationSystem","initializeAutoDirectionModeFromUI","modeSelector","value","resizeState","isResizing","lastResizeTime","debounceTimeout","dimensionsHistory","resizeCanvasWithRetry","style","cursor","addEventListener","debouncedResize","retryCount","rect","parentElement","getBoundingClientRect","width","height","render","resizeCanvas","debug","currentDimensions","recent","d","shift","fittingToScreen","safeFitToScreen","e","handleMouseDown","handleMouseMove","handleMouseUp","handleContextMenu","handleWheel","passive","handleKeyDown","handleKeyUp","preventDefault","loadImage","preserveView","setImageSwitchLock","interruptAllDirectionModes","plantDataManager","imageURL","Image","crossOrigin","reject","onload","onerror","src","fitToScreen","canvasWidth","canvasHeight","imageWidth","imageHeight","scaleX","scaleY","min","newScale","scaleChange","abs","updateZoomInfo","resetView","clearImage","clearKeypointsWithoutSave","clearKeypointLabels","clearRect","save","translate","drawImage","restore","calibrationPreviewState","isActive","renderCalibrationPreview","renderKeypoints","renderCustomAnnotations","renderPlaceholder","centerX","centerY","fillStyle","fillRect","font","textAlign","fillText","displayStrategy","getKeypointDisplayStrategy","keypoint","index","screenPos","imageToScreen","renderCustomKeypoint","fallback","previewPos","fillColor","globalAlpha","renderSingleKeypoint","renderDragIndicator","renderCustomRegionPreview","renderDirectionSelectionGuide","updateZoomIndicator","updateAnnotationSizeInfo","renderRegularKeypoint","isHovered","displayOrder","directions","renderMultipleDirections","renderDirectionIndicator","customType","getCustomType","alpha","renderCustomRegion","renderCustomPoint","beginPath","arc","radius","PI","color","fill","strokeStyle","lineWidth","borderWidth","stroke","showInternalLabel","fontSize","textBaseline","toString","showExternalLabel","renderCustomPointLabel","isDirectional","bottomRightScreen","screenWidth","screenHeight","strokeRect","renderCustomRegionLabel","labelY","labelText","textWidth","measureText","padding","startScreenPos","currentScreenPos","getCurrentCustomType","left","top","setLineDash","sizeText","round","label","strategy","createExternalLabel","showMinimalMode","createTooltip","startX","startY","currentX","currentY","deltaX","sqrt","moveTo","lineTo","midX","midY","imageX","imageY","screenToImage","screenX","screenY","getMousePos","clientX","clientY","getVisibleImageBounds","imageLeft","imageTop","visibleBounds","right","bottom","imageRight","imageBottom","random","imageSize","canvasSize","isPointInVisibleImage","bounds","isImageCoordinateValid","canCreateAnnotationAt","imagePos","canAnnotateAtSilent","debugBoundsAt","inVisibleArea","validCoords","finalResult","button","target","tagName","isTrusted","eventPhase","bubbles","cancelable","stackTrace","stack","mousePos","shiftKey","clickedCustomAnnotation","getCustomAnnotationAt","handleCustomAnnotationClick","startCustomAnnotationDrag","clickedKeypoint","getKeypointAt","isSameKeypoint","handleDirectionSelection","mouseDownTime","wasDraggedDuringSession","showError","isInCustomMode","handleCustomAnnotationMode","blankAreaClickStart","pauseAutoDirectionMode","cancelDirectionSelection","handleMiddleMouseButton","deltaY","notifyDraggedKeypointPreview","updateCustomAnnotationDrag","pow","startDirectionAnnotation","updateDirectionDragging","updateCustomRegionDrag","directionCursor","keypointScreen","hoveredCustomAnnotation","setHoveredAnnotation","newCursor","startPos","distance","currentTime","timeSinceMouseDown","wasDragged","handleKeypointClick","saveState","autoSaveCurrentImage","triggerRealTimeSync","restoreNormalPreview","currentType","addKeypointWithDirection","undefined","createNoDirectionKeypoint","finishCustomAnnotationDrag","finishDirectionAnnotation","finishCustomRegionDrag","defaultAngle","addCustomPointAnnotation","startUnifiedCustomRegionDrag","selectKeypoint","currentDirection","ensureMultiDirectionSupport","notifySelectedKeypointPreview","currentSelectedKeypoint","angle","atan2","normalizedAngle","clickData","keypointBefore","maxDirections","clickPosition","addDirectionToKeypoint","showMultiDirectionProgress","finishMultiDirectionSetting","oldDirection","directionClick","keypointId","newDirection","keypointAfter","handleCrossSectionalDirectionSet","selectNextAutoDirectionKeypoint","justCreatedNewPoint","moveToNextExpectedPosition","processCurrentCrossSectionalPoint","processedCount","totalCount","completeCrossSectionalMode","advanceCrossSectionalProgress","advanceError","exitAutoDirectionMode","forceExit","wasInDirectionMode","isAutoMode","startAutoDirectionMode","t","startCrossSectionalMode","resetAutoDirectionButton","startLongitudinalMode","buildCrossSectionalMap","showInfo","initializeCrossSectionalState","updateAutoDirectionModeUI","currentPoint","getCurrentCrossSectionalPoint","switchToImageForCrossSectional","updateCrossSectionalProgressUI","availableOrders","needDirectionKeypoints","isLegacy","isNoDirection","selectKeypointWithZoom","isDirectionMode","currentScale","targetScale","constrainView","scaleAction","showKeypointFocusHint","bind","pulseCount","pulse","maxTranslateX","minTranslateX","maxTranslateY","minTranslateY","totalUpgraded","tryAutoSwitchToNextImage","showSuccess","nextKeypoint","progress","showAutoModeCompletionHint","hint","className","textContent","cssText","head","canvasContainer","remove","setAutoDirectionMode","mode","autoDirectionBtn","classList","modeText","allImages","directionlessAnnotations","ann","imageAnnotationPairs","getAvailableOrderNumbers","getImagesWithOrder","currentOrder","getAllCrossSectionalPoints","allPoints","imagesWithCurrentOrder","allAnnotations","nextImageData","currentOrderIndex","nextOrder","nextOrderImages","targetImage","handleImageSelect","waitForImageLoad","loadedAnnotation","maxWaitTime","duration","updateProgressInfo","progressIndicator","progressCurrent","progressTotal","progressFill","progressModeInfo","display","progressPercentage","getAutoDirectionProgress","percentage","totalOrders","userModePreference","branchPointPreviewManager","showSpecificOrderPreview","removeCustomAnnotation","removeKeypoint","handleScrollWheel","zoomFactor","zoomAt","factor","key","setZoom","ctrlKey","metaKey","redo","undo","zoomElement","threshold","addKeypoint","findNextAvailableOrderForType","findNextAvailableOrder","normalizedDirection","syncBranchPointPreview","typeDesc","directionDesc","addCustomRegionAnnotation","customTypes","setCustomTypes","handleUnifiedCustomAnnotationMode","customRegionTypeId","finishUnifiedCustomRegionDrag","resetCustomRegionDrag","endPos","sameTypeKeypoints","existingOrders","regularKeypoints","removed","splice","clearKeypoints","reorderKeypoints","getAnnotationData","imageInfo","viewState","loadAnnotationData","ensureKeypointOrders","typeHasIssues","destroy","startsWith","resetDirectionDragging","actualRadius","textBasedRadius","maxRadiusForLargeScale","directionFontSize","container","labelElement","dataset","containerRect","offsetX","offsetY","labelOffsetY","existingTooltip","querySelector","tooltip","directionText","coordinateText","innerHTML","querySelectorAll","indicator","sizeInfo","currentKeypointCount","updateContext","validateCurrentImageConsistency","expectedImageId","isConsistent","refreshFunction","refreshThumbnailAnnotationStatus","refreshError","operationType","previousPosition","realTimeSyncManager","isRealTimeSyncEnabled","keypointInfo","isCustom","createSyncData","context","triggerCustomAnnotationSync","updateSyncData","positionChange","to","deleteSyncData","triggerKeypointAddSync","triggerKeypointMoveSync","triggerKeypointDeleteSync","triggerDirectionEditSync","angleDegrees","renderDirectionArrow","angleRadians","arrowLength","endX","cos","endY","sin","lineCap","headAngle1","headAngle2","textX","textY","textHeight","guideX","guideY","angleText","upgradeLegacyDirections","upgraded","setAutoMoveToExpectedPosition","enabled","getTargetScale","getZoomLockSettings","zoomSettings","lockValue","moveToHighestKeypoint","highestKeypoint","highest","current","moveToExpectedPosition","isImageSwitch","handleImageSwitchAutoMove","newImageAnnotations","moveToPosition1","some","moveToAnnotationsCenter","position1","getExpectedPosition","sumX","sumY","centerX_img","centerY_img","expectedPosition","navigateToNextImage","restartAutoDirectionMode","rightArrowEvent","stopPropagation","_pauseHandler","removeEventListener","handleAutoDirectionSelection","remaining","startDrag","updateDrag","finishDrag","moved","saveToStorage","triggerEvent","triggerCustomAnnotationUpdateSync","getAppState","cancelCustomAnnotationDrag","cancelDrag","CustomAnnotationManager","__vitePreload","module","import","setRealTimeSyncManager","typeId","CustomAnnotationRenderer","customAnnotationSystemReady","onCustomAnnotationSystemReady","bottomRight","customAnnotation","startCustomRegionDrag","currentCustomType","getCustomAnnotationManager","getCustomAnnotationRenderer","exitDirectionCountMode","enterDirectionCountMode","showDirectionCountPrompt","hideDirectionCountPrompt","startMultiDirectionSetting","newCount","updateDirectionCountDisplay","prompt","actualDirections","progressPrompt","hideMultiDirectionProgress","removeDirectionFromKeypoint","removedDirection","isComplete","interruptDirectionCountMode","interruptMultiDirectionSetting","canHaveMultipleDirections","enhanceDirectionData","clickX","clickY","enhanceMultiDirectionData","clickDataArray","enhancedDirections","handleDirectionSelectionClick","screenCoords","getEventCoordinates","imageCoords","validateDirectionClick","calculateAngleFromClick","isClickWithinImageBounds","isClickWithinCanvasBounds","handleMultiDirectionClick","serializeAnnotationData","deserializeAnnotationData","performSiftMatching","validation","validateMatchingPreconditions","isValid","errors","showSiftError","currentAnnotations","previousAnnotations","getPreviousFrameAnnotations","currentImageData","getCurrentImageData","previousImageData","getPreviousImageData","SiftMatcher","siftMatcher","calibratedAnnotations","calibrateAnnotations","quality","calculateMatchingQuality","原始标注","校准标注","平均置信度","averageConfidence","平均偏移","averageOffset","成功匹配","successfulMatches","showCalibrationPreview","hasPreviousFrame","hasCurrentImage","hasPreviousImage","hasCurrentAnnotations","hasPreviousAnnotations","hasPreviousFrameAnnotations","getPreviousFrameId","previousFrameId","complete","tempCanvas","tempCtx","getImageData","previousImage","originalAnnotations","showOriginal","showCalibrated","showArrows","showNonBlockingNotification","bindCalibrationKeyboardEvents","notification","qualityScore","acceptBtn","rejectBtn","applyCalibrationResults","cancelCalibration","calibrationNotification","notificationTimeout","calibrationKeyboardHandler","toggleCalibrationPreview","cleanupCalibrationPreview","autoSave","showSiftSuccess","showSiftInfo","title","alert","createMatchingVisualizations","visualizations","calibrationData","originalX","originalY","offset","renderCalibrationPoint","originalPos","calibratedPos","renderCalibrationArrow","x1","y1","x2","y2","dx","dy","headAngle","BranchPointPreviewManager","previewWindow","previewCanvas","previewCtx","previewTitle","previewLoading","noPreview","zoomSlider","zoomValue","isVisible","dragStartX","dragStartY","windowStartX","windowStartY","zoomLevel","isShowingSpecificOrder","specificTargetOrder","currentViewAngle","cachedImageElement","initializeElements","updateCanvasSize","resizeObserver","ResizeObserver","renderPreview","observe","bindZoomControls","bindDragEvents","renderCachedPreview","getNextOrderToAnnotate","targetAnnotation","showNoPreview","baseCropSize","cropSize","cropX","cropY","actualCropWidth","actualCropHeight","pointX","pointY","renderLocalizedAnnotation","otherX","otherY","renderZoomInfo","header","drag","endDrag","userSelect","newX","newY","maxX","innerWidth","offsetWidth","maxY","innerHeight","offsetHeight","constrainedX","constrainedY","setPlantDataManager","toggleVisibility","show","updatePreview","showLoading","getPreviousImage","updatePreviewTitle","timeString","annotationTool","fallbackOrder","previewMessage","hideLoading","hideNoPreview","File","handleError","isTarget","headLength","zoomText","highlightCorrespondingPoints","targetOrder","sourceImage","reset","getStatus","hasPreviousData","parseFloat","updateSpecificPreviewTitle","renderSpecificOrderPreview","renderDraggedAnnotation","NoteManager","httpFileSystemManager","httpManager","notes","cacheTimestamps","cacheExpiration","requestQueue","noteCounts","bulkNoteData","bulkDataTimestamp","performanceMetrics","requestCount","bulkRequestCount","cacheHits","networkTime","addPlantNote","noteData","clearCache","noteId","addImageNote","getPlantNotes","cacheKey","isBulkDataExpired","plantNotes","isCacheExpired","emptyResult","setCache","fetchError","getImageNotes","imageNotes","updateNote","updates","deleteNote","getNote","searchNotes","filters","searchParams","URLSearchParams","append","noteType","author","searchUrl","getStats","invalidateCache","plantKey","imageKey","getCacheStats","cacheSize","cacheKeys","validateNoteData","trim","tags","isArray","formatNoteForDisplay","note","formattedTimestamp","toLocaleString","formattedLastModified","shortContent","tagsText","cleanupTimer","clearInterval","startAutoCleanup","setInterval","cleanupExpiredCache","withRequestDeduplication","requestFn","requestPromise","getNoteCount","countKey","loadNotesAsync","preloadNotes","promises","allSettled","getAllNotesInBulk","statistics","updateIndividualCacheFromBulk","plantCount","getQuickNoteStats","plantNotesCount","imageNotesCount","getPerformanceMetrics","hasBulkData","bulkDataAge","averageRequestTime","resetPerformanceMetrics","refreshBulkData","expiredKeys","NoteUI","noteManager","currentNote","isEditMode","initializeUI","createNoteModal","createNoteListModal","setupEventListeners","createNoteButtons","injectNoteStyles","updateAllPlantNoteBadges","modal","createPlantNoteButton","createImageNoteButton","toolbarSection","createFallbackPlantNoteContainer","existingBtn","noteContainer","noteBtn","annotationControls","createFallbackImageNoteContainer","setupModalEventListeners","setupButtonEventListeners","setupInputEventListeners","noteModalClose","closeNoteModal","noteCancelBtn","noteSaveBtn","saveNote","noteListModalClose","closeNoteListModal","addNoteBtn","showNoteModal","noteSearchBtn","noteSearch","plantNoteBtn","showPlantNotes","imageNoteBtn","showImageNotes","noteTitle","updateCharCounter","noteContent","showUserError","loadNoteList","globalAppState","fallbackPlantId","fallbackImageId","effectivePlantId","effectiveImageId","listContainer","renderNoteList","html","renderNoteItems","bindNoteActionEvents","noteScope","formattedNote","scopeIndicator","escapeHtml","getNoteTypeText","tag","btn","editNote","styleId","backwardPropagationGroup","isNewImageNote","checkbox","checked","titleInput","focus","getLaterDatedImages","laterImages","applyNoteToMultipleImages","targetImages","results","failed","backwardPropagationCheckbox","enableBackwardPropagation","propagationResults","listModal","updatePlantNoteBadge","updatePlantNoteButton","directUpdateThumbnailBadge","updateImageNoteButton","confirm","errorMessage","typeFilter","matchesQuery","matchesType","inputId","counterId","maxLength","input","counter","currentLength","setCurrentPlant","plantNoteContainer","setCurrentImage","refreshThumbnailNoteBadge","imageNoteContainer","shouldShow","contains","plantNoteCountElement","bulkStats","actualCount","validationError","plantError","imageNoteCountElement","loadImageNoteCount","totalNotes","updateBadgeWithStats","validationResults","actualTotal","totalImageNotes","p","viewError","imagePromises","badge","badgeText","visibility","opacity","updateAllPlantNoteBadgesFromBulk","plantItems","quickStats","metrics","general","observation","div","noteCount","fallbackError","element","AnnotationManager","replace","calculateTotalAnnotations","getSinglePlantAnnotations","getSingleImageAnnotations","getQuickAnnotationStats","imageAnnotationCount","BulkLoadingPerformanceMonitor","loadingStartTime","loadingEndTime","totalLoadingTime","plantsLoaded","annotationsLoaded","notesLoaded","networkRequests","bulkRequests","individualRequests","totalDataTransferred","cacheMisses","fallbacksUsed","timeToFirstInteraction","timeToFullyLoaded","isMonitoring","checkpoints","startMonitoring","addCheckpoint","details","checkpoint","relativeTime","recordDataLoaded","dataSize","recordNetworkRequest","isBulk","recordCacheHit","recordCacheMiss","recordError","recordFallback","totalFallbacks","endMonitoring","report","generatePerformanceReport","cacheHitRate","bulkRequestRatio","dataLoaded","dataTransferred","networkPerformance","totalRequests","averageRequestSize","cachePerformance","hits","misses","hitRate","reliability","errorDetails","timeline","performanceGrade","calculatePerformanceGrade","optimizationSuggestions","generateOptimizationSuggestions","score","requestEfficiency","suggestions","category","suggestion","priority","impact","exportMetrics","RealTimeSyncManager","annotationStorageManager","isEnabled","isSyncing","syncQueue","OPERATION_TYPES","ADD_KEYPOINT","MOVE_KEYPOINT","DELETE_KEYPOINT","EDIT_DIRECTION","CUSTOM_ANNOTATION_CREATE","CUSTOM_ANNOTATION_UPDATE","CUSTOM_ANNOTATION_DELETE","CUSTOM_TYPE_CREATE","eventListeners","setEnabled","Boolean","emit","isSyncInProgress","on","listener","off","listeners","getFutureImages","currentDate","futureImages","syncKeypointAddition","synced","syncedCount","addKeypointToImage","syncKeypointMovement","moveKeypointInImage","syncKeypointDeletion","payload","deleteKeypointFromImage","existingKeypoint","orderMatch","typeMatch","customTypeMatch","newKeypoint","matchingIndex","removedKeypoint","queueSyncOperation","processSyncQueue","queueLength","executeOperation","syncData","syncDirectionEdit","syncCustomAnnotationCreate","syncCustomAnnotationUpdate","syncCustomAnnotationDelete","syncCustomTypeCreate","editDirectionInImage","addCustomAnnotationToImage","updateCustomAnnotationInImage","deleteCustomAnnotationFromImage","existingCustomAnnotation","assign","removedAnnotation","getSyncStats","clearSyncQueue","CustomAnnotationToolbarController","settingsController","updateDisplay","customModeIndicator","customTypeIndicator","toolbarCustomTypeSelect","switchCustomModeBtn","normalModeBtn","customSettingsBtn","onCustomTypeSelected","selectedTypeId","setCustomAnnotationMode","showModeChangeNotification","setNormalMode","openSettings","refreshCustomTypeSelector","getAllCustomTypes","currentSelection","option","updateButtonStates","switchToCustomMode","switchToNormalMode","updateModeIndicators","currentMode","selectedType","fontWeight","typeBadge","hasCustomTypes","disabled","hideNoTypesMessage","showNoTypesMessage","parentNode","typeIcon","animation","forceRefresh","getSelectedCustomTypeId","setSelectedCustomType","getStatusSummary","totalTypes","totalCustomTypes","CustomAnnotationSettingsController","currentEditingTypeId","currentTab","closeBtn","tabButtons","tabContents","customTypesList","noCustomTypesMessage","addTypeBtn","typeFormSection","typeForm","formTitle","formSubmitText","cancelFormBtn","typeNameInput","typeIdInput","typeTypeSelect","typeColorInput","typeColorTextInput","typeDescriptionInput","typeCategoryInput","typeDefaultAngleGroup","typeDefaultAngleInput","typeIsDirectionalInput","currentModeValue","currentTypeValue","switchToNormalBtn","selectCustomTypeSelect","switchToCustomBtn","exportTypesCount","exportAnnotationsCount","exportCustomDataBtn","selectImportFileBtn","importFileInput","importFileInfo","importFileName","importExecuteBtn","importResults","importResultsContent","hide","tabName","tab","switchTab","showAddTypeForm","hideTypeForm","handleFormSubmit","test","generateIdFromName","updateAngleVisibility","updateModeDisplay","exportCustomData","handleFileSelection","executeImport","refreshAllData","refreshTabData","refreshCustomTypesList","updateExportStats","typesList","createTypeItemHTML","bindTypeActionButtons","typeLabel","action","editCustomType","deleteCustomType","formData","FormData","typeData","rawAngle","Number","isNaN","updateCustomType","createCustomType","prefix","builtin","builtinIdx","opt","isPoint","updateCurrentImageStats","currentImageStatsDiv","exportSection","statsHtml","orderRange","gaps","typeStats","byType","info","typeColor","typeName","files","importData","customAnnotations","promise","lineno","colno","app","loadingScreen","mainApp","errorModal","noteUI","performanceMonitor","currentDataset","customAnnotationToolbarController","customAnnotationSettingsController","hasBackendAccess","currentDatasetPath","navigation","isNavigating","lastNavigationTime","throttleDelay","initializeCustomAnnotationControllers","initializeApp","updateFullscreenLoading","hideError","unsupportedAPIs","check","indexedDB","Worker","IntersectionObserver","api","missingAPIs","checkBrowserCompatibility","selectDatasetBtn","handleSelectDataset","errorCloseBtn","resetZoomBtn","fitScreenBtn","renderImageThumbnails","handleViewAngleSelect","undoBtn","redoBtn","clearAllBtn","handleClearAllAnnotations","siftMatchBtn","handleSiftMatch","togglePreviewBtn","autoDirectionModeSelector","handleAutoDirectionModeChange","zoomLockCheckbox","zoomLockValue","handleZoomLockChange","handleZoomLockValueChange","autoMoveCheckbox","handleAutoMoveChange","realTimeChangeCheckbox","handleRealTimeChangeChange","skipModalClose","skipCancelBtn","skipConfirmBtn","hideSkipPlantModal","confirmSkipPlant","skipModal","statusFilter","handleStatusFilterChange","plantSearch","handlePlantSearchInput","saveAnnotationBtn","handleSaveAnnotation","saveAnnotationCancelBtn","hideSaveAnnotationModal","saveAnnotationConfirmBtn","selectedMode","directionSaveMode","saveResult","updateAnnotationStatusDisplay","updateProgressStats","affectedImages","performSaveAnnotation","completePlantBtn","handleCompletePlant","exportDataBtn","handleExportData","deletePlantAnnotationsBtn","handleDeletePlantAnnotations","deleteModalClose","deleteCancelBtn","deleteConfirmBtn","deleteConfirmationCheckbox","hideDeletePlantAnnotationsModal","confirmDeletePlantAnnotations","handleDeleteConfirmationChange","deleteModal","handleKeyboardShortcuts","handlePlantUpdated","saveAnnotationModal","unskipModalClose","unskipCancelBtn","unskipConfirmBtn","hideUnskipPlantModal","confirmUnskipPlant","uncompleteModalClose","uncompleteCancelBtn","uncompleteConfirmBtn","hideUncompletePlantModal","confirmUncompletePlant","unskipModal","uncompleteModal","bindEventListeners","loadingTexts","loadingP","simulateLoading","autoConnectDataset","hideFullscreenLoading","selectBtn","datasetInfo","validateDatasetStructure","renderPlantList","plantDirectories","firstPlant","progressStatsElement","hideProgressStats","progressStats","completedImagesCount","totalImagesCount","completionPercentage","completedPlantsCount","totalPlantsCount","progressBarFill","skippedText","background","plantItem","createPlantListItem","bulkError","statusIcon","getStatusIcon","imageCountText","viewAnglesText","selectedViewText","isSkipped","skipReasonHtml","stateButtonsHtml","getStatusText","handlePlantSelect","arguments","directError","initializeEmptyWorkspace","clearWorkspaceState","viewAngleSection","updateDeletePlantAnnotationsButtonState","updateCompletePlantButtonState","hideAnnotationStatusDisplay","thumbnailContainer","titleElement","updateCurrentPlantTitle","selectedPlantId","selectedItem","updatePlantItemSelection","allImageIds","flat","viewAngleInfo","availableViews","buttonText","selectedButton","showViewAngleSelection","thumbnail","createImageThumbnail","isFirst","annotationBadge","statusElement","thumbnailElement","imgElement","loadingElement","loadThumbnailImage","imageToSave","isFirstImageForPlant","selectedImageId","thumb","selectedThumb","thumbnailRect","thumbnailOffsetTop","scrollTop","offsetTop","containerHeight","targetScrollTop","scrollTo","behavior","scrollToThumbnail","updateImageThumbnailSelection","shouldPreserveView","getAutoMoveSettings","syncAnnotationsFromKeypoints","statusSection","annotationSource","manualAdjustmentNotice","savedAnnotations","showSaveAnnotationModal","plantIdElement","showUncompletePlantModal","confirmMessage","newItem","replaceChild","nextPlant","modalHTML","existingModal","insertAdjacentHTML","statsContent","calculateExportStats","getDirectExportData","generateExportPreview","finalExportData","skippedPlants","performExport","showExportOptionsModal","inferPlantIdFromImageId","statusTextElement","imageCountElement","viewAnglesElement","plantViewInfo","selectedViewElement","previousIndex","navigateToPreviousImage","progressText","previewContainer","previewHTML","skippedCount","generateSimplePreviewHTML","togglePlantPreview","toggle","renderPreviewCanvases","toggleViewPreview","showImageDetail","getImageDataFromId","maxWidth","maxHeight","drawWidth","drawHeight","renderImageDetail","closeImageDetailModal","showImageDetailModal","isElementVisible","renderAnnotationPreview","rendered","targetWidth","targetHeight","devicePixelRatio","imgAspect","autoMode","nextIndex","nextImage","pauseHandler","reasonTextarea","searchInput","applyPlantsFilter","searchQuery","filteredPlants","subtitle","loadingSubtitle","loadingDetails","fullscreenLoading","connectionError","ConnectionError","originalError","serverUrl","loadingTasks","loadingResults","bulkAnnotations","bulkNotes","loadedComponents","loadedMessage","performanceReport","lastPerformanceReport","gradeMsg","detailMessage","retryButton","onclick","showFullscreenLoading","retryError","addRetryButton","showConnectionError","toggleBranchPointPreview","showSkipPlantModal","plantNameElement","handleUnskipPlant","skipReasonElement","newStatusElement","showUnskipPlantModal","super","disableScopeOption","handleDeletionScopeChange","selectedScope","confirmCheckbox","confirmButton","scope","confirmText","statsLoading","futureImagesInfo","futureImagesCount","plantAllOption","getFutureImagesForClearing","futureCount","currentFutureOption","currentOnlyOption","setupDeletionScopeOptions","annotationFiles","totalAnnotationPoints","relatedFiles","totalFiles","showDeletePlantAnnotationsModal","deletionScope","originalText","executeFullPlantDeletion","deletedCount","clearAnnotationsForImage","totalFilesDeleted","totalFilesProcessed","annotationFilesDeleted","relatedFilesDeleted","backupPath","executeSpreadingDeletion","executeCurrentImageDeletion","successMessage","createSuccessMessage","handlePostDeletionUpdates","completeButton","deleteButton","siftBtn"],"mappings":"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"}