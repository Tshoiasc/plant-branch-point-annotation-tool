System.register([],function(t,e){"use strict";return{execute:function(){t("SiftMatcher",class{constructor(){this.searchConfigs=[{boxSize:30,searchRadius:40},{boxSize:40,searchRadius:60},{boxSize:50,searchRadius:80},{boxSize:60,searchRadius:100}],this.qualityThreshold=.7,this.ratioThreshold=.7,this.minMatches=3}async calibrateAnnotations(t,e,n,o){if(!(t&&e&&n&&o))throw new Error("缺少必要的参数：需要基准标注、目标标注和图像数据");console.log("[SIFT] 开始标注点校准",{referenceCount:t.length,targetCount:e.length});const a=[...t].sort((t,e)=>(t.order||0)-(e.order||0)),r=[...e].sort((t,e)=>(t.order||0)-(e.order||0)),i=[],c=new Map(a.map(t=>[t.order,t]));for(const h of r){const t=c.get(h.order);if(t)try{const e=await this.adaptiveMatching(n,t.x,t.y,o,t.x,t.y),a={...h,x:e.x,y:e.y,calibrationData:{originalX:h.x,originalY:h.y,confidence:e.confidence,method:e.method,offset:Math.sqrt(Math.pow(e.x-h.x,2)+Math.pow(e.y-h.y,2))}};i.push(a),console.log(`[SIFT] 校准点 ${h.order||"unknown"}:`,{original:`(${h.x.toFixed(1)}, ${h.y.toFixed(1)})`,calibrated:`(${e.x.toFixed(1)}, ${e.y.toFixed(1)})`,offset:`${a.calibrationData.offset.toFixed(2)}px`,confidence:`${(100*e.confidence).toFixed(1)}%`,method:e.method})}catch(s){console.warn(`[SIFT] 校准点 ${h.order||"unknown"} 失败:`,s.message),i.push({...h,calibrationData:{originalX:h.x,originalY:h.y,confidence:0,method:"none",offset:0,error:s.message}})}else console.log(`[SIFT] 保留新标注点 #${h.order}（上一帧不存在）`),i.push({...h,calibrationData:{originalX:h.x,originalY:h.y,confidence:1,method:"preserve",offset:0,note:"New annotation not in previous frame"}})}return i}async adaptiveMatching(t,e,n,o,a,r){let i={x:a,y:r,confidence:0,method:"none"},c=0;for(const h of this.searchConfigs)try{const s=await this.findBestMatch(t,e,n,o,a,r,h.boxSize,h.searchRadius);if(s.confidence>c&&(c=s.confidence,i=s),s.confidence>this.qualityThreshold)break}catch(s){console.warn(`[SIFT] 配置 ${JSON.stringify(h)} 匹配失败:`,s.message);continue}return i}async findBestMatch(t,e,n,o,a,r,i,c){const s=this.extractRegion(t,e,n,i),h=this.extractRegion(o,a,r,2*c);if(!s||!h)return{x:a,y:r,confidence:0,method:"none"};const l=[];try{const t=await this.templateMatching(s,h,a-c,r-c);l.push(t)}catch(d){console.warn("[SIFT] 模板匹配失败:",d.message)}try{const t=await this.simplifiedSiftMatching(s,h,a-c,r-c);l.push(t)}catch(d){console.warn("[SIFT] 简化SIFT匹配失败:",d.message)}return 0===l.length?{x:a,y:r,confidence:0,method:"none"}:l.reduce((t,e)=>e.confidence>t.confidence?e:t)}extractRegion(t,e,n,o){const{width:a,height:r,data:i}=t,c=Math.floor(o/2),s=Math.max(0,Math.floor(e-c)),h=Math.max(0,Math.floor(n-c)),l=Math.min(a,Math.floor(e+c))-s,d=Math.min(r,Math.floor(n+c))-h;if(l<5||d<5)return null;const f=new Uint8ClampedArray(l*d*4);for(let g=0;g<d;g++)for(let t=0;t<l;t++){const e=4*((h+g)*a+(s+t)),n=4*(g*l+t);f[n]=i[e],f[n+1]=i[e+1],f[n+2]=i[e+2],f[n+3]=i[e+3]}return{x:s,y:h,width:l,height:d,data:f}}async templateMatching(t,e,n,o){const a=this.toGrayscale(t),r=this.toGrayscale(e),i=this.normalizedCorrelation(a,r);return i?{x:i.x+t.width/2+n,y:i.y+t.height/2+o,confidence:i.confidence,method:"template"}:{x:n+e.width/2,y:o+e.height/2,confidence:0,method:"template"}}async simplifiedSiftMatching(t,e,n,o){const a=this.toGrayscale(t),r=this.toGrayscale(e),i=this.detectHarrisCorners(a),c=this.detectHarrisCorners(r);if(i.length<3||c.length<3)return this.templateMatching(t,e,n,o);const s=this.matchCorners(i,c);if(s.length<this.minMatches)return this.templateMatching(t,e,n,o);const h=this.calculateTransformation(s);return{x:t.width/2+h.dx+n,y:t.height/2+h.dy+o,confidence:Math.min(h.confidence,1),method:"sift"}}toGrayscale(t){const{width:e,height:n,data:o}=t,a=new Uint8Array(e*n);for(let r=0;r<e*n;r++){const t=o[4*r],e=o[4*r+1],n=o[4*r+2];a[r]=Math.round(.299*t+.587*e+.114*n)}return{width:e,height:n,data:a}}normalizedCorrelation(t,e){const{width:n,height:o,data:a}=t,{width:r,height:i,data:c}=e;if(n>r||o>i)return null;let s=-1,h=0,l=0;for(let d=0;d<=i-o;d++)for(let t=0;t<=r-n;t++){const e=this.calculateNCC(a,c,n,o,t,d,r);e>s&&(s=e,h=t,l=d)}return{x:h,y:l,confidence:Math.max(0,Math.min(s,.9))}}calculateNCC(t,e,n,o,a,r,i){let c=0,s=0,h=0,l=0,d=0;const f=n*o;for(let x=0;x<o;x++)for(let o=0;o<n;o++){const f=t[x*n+o],g=e[(r+x)*i+(a+o)];c+=f,s+=g,h+=f*g,l+=f*f,d+=g*g}const g=c/f,u=s/f,m=h-f*g*u,y=Math.sqrt((l-f*g*g)*(d-f*u*u));return y>0?m/y:0}detectHarrisCorners(t){const{width:e,height:n,data:o}=t,a=[];for(let r=1;r<n-1;r++)for(let t=1;t<e-1;t++){const i=this.calculateHarrisResponse(o,t,r,e,n);i>.01&&a.push({x:t,y:r,response:i})}return a.sort((t,e)=>e.response-t.response).slice(0,20)}calculateHarrisResponse(t,e,n,o,a){let r=0,i=0,c=0;for(let h=-1;h<=1;h++)for(let a=-1;a<=1;a++){const s=(n+h)*o+(e+a),l=t[s+1]-t[s-1],d=t[s+o]-t[s-o];r+=l*l,i+=d*d,c+=l*d}const s=r+i;return r*i-c*c-.04*s*s}matchCorners(t,e){const n=[];for(let o=0;o<t.length;o++){const a=t[o];let r=null,i=1/0;for(let t=0;t<e.length;t++){const n=e[t],o=Math.sqrt(Math.pow(a.x-n.x,2)+Math.pow(a.y-n.y,2));o<i&&(i=o,r={corner1:a,corner2:n,distance:o})}r&&i<50&&n.push(r)}return n}calculateTransformation(t){if(0===t.length)return{dx:0,dy:0,confidence:0};const e=t.map(t=>t.corner2.x-t.corner1.x),n=t.map(t=>t.corner2.y-t.corner1.y),o=this.median(e),a=this.median(n),r=Math.min(refCorners.length,searchCorners.length),i=r>0?t.length/r*.8:0;return{dx:o,dy:a,confidence:Math.min(i,.8)}}median(t){const e=[...t].sort((t,e)=>t-e),n=Math.floor(e.length/2);return e.length%2==0?(e[n-1]+e[n])/2:e[n]}calculateMatchingQuality(t){if(!t||0===t.length)return{averageConfidence:0,averageOffset:0,successfulMatches:0,totalAnnotations:0,qualityScore:0};const e=t.filter(t=>t.calibrationData&&t.calibrationData.confidence>0),n=e.reduce((t,e)=>t+e.calibrationData.confidence,0),o=e.reduce((t,e)=>t+e.calibrationData.offset,0),a=e.length>0?n/e.length:0,r=e.length>0?o/e.length:0,i=a*(e.length/t.length);return{averageConfidence:a,averageOffset:r,successfulMatches:e.length,totalAnnotations:t.length,qualityScore:i}}})}}});
//# sourceMappingURL=SiftMatcher-legacy-OvzYr5fk.js.map
