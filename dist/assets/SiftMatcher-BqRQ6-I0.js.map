{"version":3,"file":"SiftMatcher-BqRQ6-I0.js","sources":["../../src/core/SiftMatcher.js"],"sourcesContent":["/**\n * SIFT 图像匹配算法\n * \n * 基于JavaScript的SIFT特征匹配实现，用于标注点精确匹配\n * 支持SIFT特征检测、模板匹配和自适应匹配策略\n */\n\nexport class SiftMatcher {\n  constructor() {\n    this.searchConfigs = [\n      { boxSize: 30, searchRadius: 40 },\n      { boxSize: 40, searchRadius: 60 },\n      { boxSize: 50, searchRadius: 80 },\n      { boxSize: 60, searchRadius: 100 }\n    ];\n    \n    this.qualityThreshold = 0.7;\n    this.ratioThreshold = 0.7;\n    this.minMatches = 3;\n  }\n\n  /**\n   * 校准标注点位置\n   * @param {Array} referenceAnnotations - 基准标注点\n   * @param {Array} targetAnnotations - 目标标注点\n   * @param {ImageData} referenceImageData - 基准图像数据\n   * @param {ImageData} targetImageData - 目标图像数据\n   * @returns {Array} 校准后的标注点\n   */\n  async calibrateAnnotations(referenceAnnotations, targetAnnotations, referenceImageData, targetImageData) {\n    if (!referenceAnnotations || !targetAnnotations || !referenceImageData || !targetImageData) {\n      throw new Error('缺少必要的参数：需要基准标注、目标标注和图像数据');\n    }\n\n    console.log('[SIFT] 开始标注点校准', {\n      referenceCount: referenceAnnotations.length,\n      targetCount: targetAnnotations.length\n    });\n\n    // 按order排序\n    const refAnnotations = [...referenceAnnotations].sort((a, b) => (a.order || 0) - (b.order || 0));\n    const targetAnnotationsSorted = [...targetAnnotations].sort((a, b) => (a.order || 0) - (b.order || 0));\n\n    const calibratedAnnotations = [];\n    \n    // 🔧 FIX: 按order创建映射，保留目标图像中上一帧没有的新标注点\n    const refAnnotationMap = new Map(refAnnotations.map(ann => [ann.order, ann]));\n    \n    for (const targetAnn of targetAnnotationsSorted) {\n      const refAnn = refAnnotationMap.get(targetAnn.order);\n      \n      if (!refAnn) {\n        // 🔧 FIX: 上一帧没有的标注点，直接保留原位置\n        console.log(`[SIFT] 保留新标注点 #${targetAnn.order}（上一帧不存在）`);\n        calibratedAnnotations.push({\n          ...targetAnn,\n          calibrationData: {\n            originalX: targetAnn.x,\n            originalY: targetAnn.y,\n            confidence: 1.0,\n            method: 'preserve',\n            offset: 0,\n            note: 'New annotation not in previous frame'\n          }\n        });\n        continue;\n      }\n\n      try {\n        // 🔧 FIX: 使用参考点位置作为搜索中心（而非当前目标点位置）\n        // 这是正确的SIFT匹配算法：在目标图像中围绕参考点位置搜索\n        const matchResult = await this.adaptiveMatching(\n          referenceImageData,\n          refAnn.x,\n          refAnn.y,\n          targetImageData,\n          refAnn.x,  // 🔧 FIX: 使用参考点位置作为搜索中心\n          refAnn.y   // 🔧 FIX: 而非目标点当前位置\n        );\n\n        // 复制目标标注的所有属性\n        const calibratedAnn = {\n          ...targetAnn,\n          x: matchResult.x,\n          y: matchResult.y,\n          calibrationData: {\n            originalX: targetAnn.x,\n            originalY: targetAnn.y,\n            confidence: matchResult.confidence,\n            method: matchResult.method,\n            offset: Math.sqrt(Math.pow(matchResult.x - targetAnn.x, 2) + Math.pow(matchResult.y - targetAnn.y, 2))\n          }\n        };\n\n        calibratedAnnotations.push(calibratedAnn);\n\n        console.log(`[SIFT] 校准点 ${targetAnn.order || 'unknown'}:`, {\n          original: `(${targetAnn.x.toFixed(1)}, ${targetAnn.y.toFixed(1)})`,\n          calibrated: `(${matchResult.x.toFixed(1)}, ${matchResult.y.toFixed(1)})`,\n          offset: `${calibratedAnn.calibrationData.offset.toFixed(2)}px`,\n          confidence: `${(matchResult.confidence * 100).toFixed(1)}%`,\n          method: matchResult.method\n        });\n\n      } catch (error) {\n        console.warn(`[SIFT] 校准点 ${targetAnn.order || 'unknown'} 失败:`, error.message);\n        // 保持原始位置\n        calibratedAnnotations.push({\n          ...targetAnn,\n          calibrationData: {\n            originalX: targetAnn.x,\n            originalY: targetAnn.y,\n            confidence: 0,\n            method: 'none',\n            offset: 0,\n            error: error.message\n          }\n        });\n      }\n    }\n\n    return calibratedAnnotations;\n  }\n\n  /**\n   * 自适应匹配算法\n   * @param {ImageData} refImageData - 基准图像数据\n   * @param {number} refX - 基准X坐标\n   * @param {number} refY - 基准Y坐标\n   * @param {ImageData} targetImageData - 目标图像数据\n   * @param {number} searchCenterX - 搜索中心X坐标（通常是参考点位置）\n   * @param {number} searchCenterY - 搜索中心Y坐标（通常是参考点位置）\n   * @returns {Object} 匹配结果\n   */\n  async adaptiveMatching(refImageData, refX, refY, targetImageData, searchCenterX, searchCenterY) {\n    let bestResult = { x: searchCenterX, y: searchCenterY, confidence: 0.0, method: 'none' };\n    let bestQuality = 0.0;\n\n    for (const config of this.searchConfigs) {\n      try {\n        const result = await this.findBestMatch(\n          refImageData, refX, refY,\n          targetImageData, searchCenterX, searchCenterY,\n          config.boxSize, config.searchRadius\n        );\n\n        if (result.confidence > bestQuality) {\n          bestQuality = result.confidence;\n          bestResult = result;\n        }\n\n        // 如果质量足够好，停止搜索\n        if (result.confidence > this.qualityThreshold) {\n          break;\n        }\n      } catch (error) {\n        console.warn(`[SIFT] 配置 ${JSON.stringify(config)} 匹配失败:`, error.message);\n        continue;\n      }\n    }\n\n    return bestResult;\n  }\n\n  /**\n   * 寻找最佳匹配\n   * @param {ImageData} refImageData - 基准图像数据\n   * @param {number} refX - 基准X坐标\n   * @param {number} refY - 基准Y坐标\n   * @param {ImageData} targetImageData - 目标图像数据\n   * @param {number} searchCenterX - 搜索中心X坐标\n   * @param {number} searchCenterY - 搜索中心Y坐标\n   * @param {number} boxSize - 匹配框大小\n   * @param {number} searchRadius - 搜索半径\n   * @returns {Object} 匹配结果\n   */\n  async findBestMatch(refImageData, refX, refY, targetImageData, searchCenterX, searchCenterY, boxSize, searchRadius) {\n    const refBox = this.extractRegion(refImageData, refX, refY, boxSize);\n    const searchRegion = this.extractRegion(targetImageData, searchCenterX, searchCenterY, searchRadius * 2);\n\n    if (!refBox || !searchRegion) {\n      return { x: searchCenterX, y: searchCenterY, confidence: 0.0, method: 'none' };\n    }\n\n    // 尝试多种匹配方法\n    const results = [];\n\n    // 1. 模板匹配\n    try {\n      const templateResult = await this.templateMatching(\n        refBox, searchRegion,\n        searchCenterX - searchRadius, searchCenterY - searchRadius\n      );\n      results.push(templateResult);\n    } catch (error) {\n      console.warn('[SIFT] 模板匹配失败:', error.message);\n    }\n\n    // 2. 简化的SIFT匹配（使用Harris角点检测）\n    try {\n      const siftResult = await this.simplifiedSiftMatching(\n        refBox, searchRegion,\n        searchCenterX - searchRadius, searchCenterY - searchRadius\n      );\n      results.push(siftResult);\n    } catch (error) {\n      console.warn('[SIFT] 简化SIFT匹配失败:', error.message);\n    }\n\n    // 选择最佳结果\n    if (results.length === 0) {\n      return { x: searchCenterX, y: searchCenterY, confidence: 0.0, method: 'none' };\n    }\n\n    const bestResult = results.reduce((best, current) => \n      current.confidence > best.confidence ? current : best\n    );\n\n    return bestResult;\n  }\n\n  /**\n   * 提取图像区域\n   * @param {ImageData} imageData - 图像数据\n   * @param {number} centerX - 中心X坐标\n   * @param {number} centerY - 中心Y坐标\n   * @param {number} size - 区域大小\n   * @returns {Object} 提取的区域数据\n   */\n  extractRegion(imageData, centerX, centerY, size) {\n    const { width, height, data } = imageData;\n    const halfSize = Math.floor(size / 2);\n    \n    const x1 = Math.max(0, Math.floor(centerX - halfSize));\n    const y1 = Math.max(0, Math.floor(centerY - halfSize));\n    const x2 = Math.min(width, Math.floor(centerX + halfSize));\n    const y2 = Math.min(height, Math.floor(centerY + halfSize));\n    \n    const regionWidth = x2 - x1;\n    const regionHeight = y2 - y1;\n    \n    if (regionWidth < 5 || regionHeight < 5) {\n      return null;\n    }\n\n    const regionData = new Uint8ClampedArray(regionWidth * regionHeight * 4);\n    \n    for (let y = 0; y < regionHeight; y++) {\n      for (let x = 0; x < regionWidth; x++) {\n        const srcIndex = ((y1 + y) * width + (x1 + x)) * 4;\n        const dstIndex = (y * regionWidth + x) * 4;\n        \n        regionData[dstIndex] = data[srcIndex];     // R\n        regionData[dstIndex + 1] = data[srcIndex + 1]; // G\n        regionData[dstIndex + 2] = data[srcIndex + 2]; // B\n        regionData[dstIndex + 3] = data[srcIndex + 3]; // A\n      }\n    }\n\n    return {\n      x: x1,\n      y: y1,\n      width: regionWidth,\n      height: regionHeight,\n      data: regionData\n    };\n  }\n\n  /**\n   * 模板匹配\n   * @param {Object} refBox - 基准框\n   * @param {Object} searchRegion - 搜索区域\n   * @param {number} searchX - 搜索区域X偏移\n   * @param {number} searchY - 搜索区域Y偏移\n   * @returns {Object} 匹配结果\n   */\n  async templateMatching(refBox, searchRegion, searchX, searchY) {\n    const refGray = this.toGrayscale(refBox);\n    const searchGray = this.toGrayscale(searchRegion);\n    \n    // 使用归一化相关匹配\n    const result = this.normalizedCorrelation(refGray, searchGray);\n    \n    if (!result) {\n      return { \n        x: searchX + searchRegion.width / 2, \n        y: searchY + searchRegion.height / 2, \n        confidence: 0.0, \n        method: 'template' \n      };\n    }\n\n    const centerX = result.x + refBox.width / 2 + searchX;\n    const centerY = result.y + refBox.height / 2 + searchY;\n\n    return {\n      x: centerX,\n      y: centerY,\n      confidence: result.confidence,\n      method: 'template'\n    };\n  }\n\n  /**\n   * 简化的SIFT匹配（使用Harris角点检测）\n   * @param {Object} refBox - 基准框\n   * @param {Object} searchRegion - 搜索区域\n   * @param {number} searchX - 搜索区域X偏移\n   * @param {number} searchY - 搜索区域Y偏移\n   * @returns {Object} 匹配结果\n   */\n  async simplifiedSiftMatching(refBox, searchRegion, searchX, searchY) {\n    const refGray = this.toGrayscale(refBox);\n    const searchGray = this.toGrayscale(searchRegion);\n    \n    // 检测Harris角点\n    const refCorners = this.detectHarrisCorners(refGray);\n    const searchCorners = this.detectHarrisCorners(searchGray);\n    \n    if (refCorners.length < 3 || searchCorners.length < 3) {\n      // 回退到模板匹配\n      return this.templateMatching(refBox, searchRegion, searchX, searchY);\n    }\n\n    // 简化的描述子匹配\n    const matches = this.matchCorners(refCorners, searchCorners);\n    \n    if (matches.length < this.minMatches) {\n      return this.templateMatching(refBox, searchRegion, searchX, searchY);\n    }\n\n    // 计算变换\n    const transformation = this.calculateTransformation(matches);\n    \n    const centerX = refBox.width / 2 + transformation.dx + searchX;\n    const centerY = refBox.height / 2 + transformation.dy + searchY;\n\n    return {\n      x: centerX,\n      y: centerY,\n      confidence: Math.min(transformation.confidence, 1.0),\n      method: 'sift'\n    };\n  }\n\n  /**\n   * 转换为灰度图\n   * @param {Object} imageRegion - 图像区域\n   * @returns {Object} 灰度图像数据\n   */\n  toGrayscale(imageRegion) {\n    const { width, height, data } = imageRegion;\n    const grayData = new Uint8Array(width * height);\n    \n    for (let i = 0; i < width * height; i++) {\n      const r = data[i * 4];\n      const g = data[i * 4 + 1];\n      const b = data[i * 4 + 2];\n      grayData[i] = Math.round(0.299 * r + 0.587 * g + 0.114 * b);\n    }\n    \n    return { width, height, data: grayData };\n  }\n\n  /**\n   * 归一化相关匹配\n   * @param {Object} template - 模板图像\n   * @param {Object} image - 搜索图像\n   * @returns {Object} 匹配结果\n   */\n  normalizedCorrelation(template, image) {\n    const { width: tWidth, height: tHeight, data: tData } = template;\n    const { width: iWidth, height: iHeight, data: iData } = image;\n    \n    if (tWidth > iWidth || tHeight > iHeight) {\n      return null;\n    }\n    \n    let bestScore = -1;\n    let bestX = 0;\n    let bestY = 0;\n    \n    for (let y = 0; y <= iHeight - tHeight; y++) {\n      for (let x = 0; x <= iWidth - tWidth; x++) {\n        const score = this.calculateNCC(tData, iData, tWidth, tHeight, x, y, iWidth);\n        \n        if (score > bestScore) {\n          bestScore = score;\n          bestX = x;\n          bestY = y;\n        }\n      }\n    }\n    \n    return {\n      x: bestX,\n      y: bestY,\n      confidence: Math.max(0, Math.min(bestScore, 0.9)) // 🔧 FIX: 限制最大置信度，避免虚假的100%\n    };\n  }\n\n  /**\n   * 计算归一化相关系数\n   * @param {Uint8Array} template - 模板数据\n   * @param {Uint8Array} image - 图像数据\n   * @param {number} tWidth - 模板宽度\n   * @param {number} tHeight - 模板高度\n   * @param {number} x - 图像中的X位置\n   * @param {number} y - 图像中的Y位置\n   * @param {number} iWidth - 图像宽度\n   * @returns {number} 相关系数\n   */\n  calculateNCC(template, image, tWidth, tHeight, x, y, iWidth) {\n    let sumT = 0, sumI = 0, sumTI = 0, sumT2 = 0, sumI2 = 0;\n    const n = tWidth * tHeight;\n    \n    for (let dy = 0; dy < tHeight; dy++) {\n      for (let dx = 0; dx < tWidth; dx++) {\n        const tVal = template[dy * tWidth + dx];\n        const iVal = image[(y + dy) * iWidth + (x + dx)];\n        \n        sumT += tVal;\n        sumI += iVal;\n        sumTI += tVal * iVal;\n        sumT2 += tVal * tVal;\n        sumI2 += iVal * iVal;\n      }\n    }\n    \n    const meanT = sumT / n;\n    const meanI = sumI / n;\n    \n    const numerator = sumTI - n * meanT * meanI;\n    const denominator = Math.sqrt((sumT2 - n * meanT * meanT) * (sumI2 - n * meanI * meanI));\n    \n    return denominator > 0 ? numerator / denominator : 0;\n  }\n\n  /**\n   * 检测Harris角点\n   * @param {Object} grayImage - 灰度图像\n   * @returns {Array} 角点列表\n   */\n  detectHarrisCorners(grayImage) {\n    const { width, height, data } = grayImage;\n    const corners = [];\n    const threshold = 0.01;\n    \n    // 简化的Harris角点检测\n    for (let y = 1; y < height - 1; y++) {\n      for (let x = 1; x < width - 1; x++) {\n        const response = this.calculateHarrisResponse(data, x, y, width, height);\n        \n        if (response > threshold) {\n          corners.push({ x, y, response });\n        }\n      }\n    }\n    \n    // 返回最强的角点\n    return corners.sort((a, b) => b.response - a.response).slice(0, 20);\n  }\n\n  /**\n   * 计算Harris响应\n   * @param {Uint8Array} data - 图像数据\n   * @param {number} x - X坐标\n   * @param {number} y - Y坐标\n   * @param {number} width - 图像宽度\n   * @param {number} height - 图像高度\n   * @returns {number} Harris响应值\n   */\n  calculateHarrisResponse(data, x, y, width, height) {\n    // 简化的Harris响应计算\n    const k = 0.04;\n    let Ixx = 0, Iyy = 0, Ixy = 0;\n    \n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        const idx = (y + dy) * width + (x + dx);\n        const Ix = data[idx + 1] - data[idx - 1]; // 简化的梯度计算\n        const Iy = data[idx + width] - data[idx - width];\n        \n        Ixx += Ix * Ix;\n        Iyy += Iy * Iy;\n        Ixy += Ix * Iy;\n      }\n    }\n    \n    const det = Ixx * Iyy - Ixy * Ixy;\n    const trace = Ixx + Iyy;\n    \n    return det - k * trace * trace;\n  }\n\n  /**\n   * 匹配角点\n   * @param {Array} corners1 - 第一组角点\n   * @param {Array} corners2 - 第二组角点\n   * @returns {Array} 匹配结果\n   */\n  matchCorners(corners1, corners2) {\n    const matches = [];\n    \n    for (let i = 0; i < corners1.length; i++) {\n      const c1 = corners1[i];\n      let bestMatch = null;\n      let bestDistance = Infinity;\n      \n      for (let j = 0; j < corners2.length; j++) {\n        const c2 = corners2[j];\n        const distance = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));\n        \n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = { corner1: c1, corner2: c2, distance };\n        }\n      }\n      \n      if (bestMatch && bestDistance < 50) { // 距离阈值\n        matches.push(bestMatch);\n      }\n    }\n    \n    return matches;\n  }\n\n  /**\n   * 计算变换\n   * @param {Array} matches - 匹配结果\n   * @returns {Object} 变换参数\n   */\n  calculateTransformation(matches) {\n    if (matches.length === 0) {\n      return { dx: 0, dy: 0, confidence: 0 };\n    }\n    \n    // 计算平均偏移\n    const dxList = matches.map(m => m.corner2.x - m.corner1.x);\n    const dyList = matches.map(m => m.corner2.y - m.corner1.y);\n    \n    const dx = this.median(dxList);\n    const dy = this.median(dyList);\n    \n    // 🔧 FIX: 改进置信度计算，避免虚假的高置信度\n    const maxExpectedMatches = Math.min(refCorners.length, searchCorners.length);\n    const confidence = maxExpectedMatches > 0 ? (matches.length / maxExpectedMatches) * 0.8 : 0; // 限制最大置信度为0.8\n    \n    return { dx, dy, confidence: Math.min(confidence, 0.8) }; // 确保置信度不超过0.8\n  }\n\n  /**\n   * 计算中位数\n   * @param {Array} values - 数值数组\n   * @returns {number} 中位数\n   */\n  median(values) {\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    \n    return sorted.length % 2 === 0 ? \n      (sorted[mid - 1] + sorted[mid]) / 2 : \n      sorted[mid];\n  }\n\n  /**\n   * 计算匹配质量\n   * @param {Array} calibrationResults - 校准结果\n   * @returns {Object} 质量指标\n   */\n  calculateMatchingQuality(calibrationResults) {\n    if (!calibrationResults || calibrationResults.length === 0) {\n      return {\n        averageConfidence: 0,\n        averageOffset: 0,\n        successfulMatches: 0,\n        totalAnnotations: 0,\n        qualityScore: 0\n      };\n    }\n\n    const successfulMatches = calibrationResults.filter(r => r.calibrationData && r.calibrationData.confidence > 0);\n    const totalConfidence = successfulMatches.reduce((sum, r) => sum + r.calibrationData.confidence, 0);\n    const totalOffset = successfulMatches.reduce((sum, r) => sum + r.calibrationData.offset, 0);\n\n    const averageConfidence = successfulMatches.length > 0 ? totalConfidence / successfulMatches.length : 0;\n    const averageOffset = successfulMatches.length > 0 ? totalOffset / successfulMatches.length : 0;\n    const qualityScore = averageConfidence * (successfulMatches.length / calibrationResults.length);\n\n    return {\n      averageConfidence,\n      averageOffset,\n      successfulMatches: successfulMatches.length,\n      totalAnnotations: calibrationResults.length,\n      qualityScore\n    };\n  }\n}"],"names":["SiftMatcher","referenceAnnotations","targetAnnotations","referenceImageData","targetImageData","refAnnotations","a","b","targetAnnotationsSorted","calibratedAnnotations","refAnnotationMap","ann","targetAnn","refAnn","matchResult","calibratedAnn","error","refImageData","refX","refY","searchCenterX","searchCenterY","bestResult","bestQuality","config","result","boxSize","searchRadius","refBox","searchRegion","results","templateResult","siftResult","best","current","imageData","centerX","centerY","size","width","height","data","halfSize","x1","y1","x2","y2","regionWidth","regionHeight","regionData","x","srcIndex","dstIndex","searchX","searchY","refGray","searchGray","refCorners","searchCorners","matches","transformation","imageRegion","grayData","i","r","g","template","image","tWidth","tHeight","tData","iWidth","iHeight","iData","bestScore","bestX","bestY","y","score","sumT","sumI","sumTI","sumT2","sumI2","n","dy","dx","tVal","iVal","meanT","meanI","numerator","denominator","grayImage","corners","threshold","response","Ixx","Iyy","Ixy","idx","Ix","Iy","det","trace","corners1","corners2","c1","bestMatch","bestDistance","j","c2","distance","dxList","m","dyList","maxExpectedMatches","confidence","values","sorted","mid","calibrationResults","successfulMatches","totalConfidence","sum","totalOffset","averageConfidence","averageOffset","qualityScore"],"mappings":"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"}