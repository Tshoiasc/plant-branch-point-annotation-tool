System.register([],function(t,e){"use strict";return{execute:function(){t("CustomAnnotationManager",class{constructor(){if(this.customTypes=new Map,this.customAnnotations=new Map,this.isEnabled=!0,this.currentMode="normal",this.selectedCustomType=null,this.config={maxCustomTypes:20,maxAnnotationsPerImage:100,minRegionSize:10,defaultPointRadius:8,defaultRegionStrokeWidth:2},this.realTimeSyncManager=null,this.eventHandlers={onAnnotationCreate:[],onAnnotationUpdate:[],onAnnotationDelete:[],onModeChange:[],onTypeCreate:[],onTypeUpdate:[],onTypeDelete:[]},this.loadFromStorage(),this.ensureBuiltinRegularType(),"normal"===this.currentMode&&!this.selectedCustomType&&this.customTypes.has("builtin-regular-keypoint"))try{this.setCustomAnnotationMode("builtin-regular-keypoint")}catch(t){console.warn("Failed to set default builtin type mode:",t)}console.log("CustomAnnotationManager initialized")}ensureBuiltinRegularType(){const t="builtin-regular-keypoint";if(!this.customTypes.has(t)){const e={id:t,name:"Regular (Builtin)",type:"point",color:"#22c55e",description:"Default keypoint type migrated from regular",metadata:{builtin:!0,defaultAngle:0,isDirectional:!0},createdAt:(new Date).toISOString(),updatedAt:(new Date).toISOString()};this.customTypes.set(t,e),this.triggerEvent("onTypeCreate",{type:e}),console.log("[CustomAnnotationManager] Registered builtin type:",t)}}createCustomType(t){const{id:e,name:n,type:o,color:s,description:a="",metadata:i={}}=t;if(!(e&&n&&o&&s))throw new Error("Missing required fields: id, name, type, color");if(!["point","region"].includes(o))throw new Error('Invalid type: must be "point" or "region"');if(this.customTypes.has(e))throw new Error(`Custom type with id "${e}" already exists`);if(this.customTypes.size>=this.config.maxCustomTypes)throw new Error(`Maximum number of custom types (${this.config.maxCustomTypes}) reached`);const r={id:e,name:n,type:o,color:s,description:a,metadata:i,createdAt:(new Date).toISOString(),updatedAt:(new Date).toISOString()};return this.customTypes.set(e,r),this.triggerEvent("onTypeCreate",{type:r}),this.triggerCustomTypeCreateSync(r,{timestamp:(new Date).toISOString()}),this.saveToStorage(),this.triggerDatabaseAutoSave(),console.log(`Created custom type: ${e} (${n})`),r}updateCustomType(t,e){const n=this.customTypes.get(t);if(!n)throw new Error(`Custom type with id "${t}" not found`);const{id:o,type:s,...a}=e;o&&o!==t&&console.warn("Cannot change custom type ID"),s&&s!==n.type&&console.warn("Cannot change custom type type");const i={...n,...a,updatedAt:(new Date).toISOString()};return this.customTypes.set(t,i),this.triggerEvent("onTypeUpdate",{type:i}),console.log(`Updated custom type: ${t}`),i}deleteCustomType(t){return!!this.customTypes.has(t)&&(this.deleteAnnotationsByTypeId(t),this.customTypes.delete(t),this.triggerEvent("onTypeDelete",{typeId:t}),this.selectedCustomType===t&&this.setNormalMode(),console.log(`Deleted custom type: ${t}`),!0)}getAllCustomTypes(){return Array.from(this.customTypes.values())}getCustomType(t){return this.customTypes.get(t)||null}createCustomAnnotation(t){const{typeId:e,x:n,y:o,width:s,height:a,imageId:i,metadata:r={},parentAnnotationType:c,parentAnnotationId:d}=t;if(!e||!i||void 0===n||void 0===o)throw new Error("Missing required fields: typeId, imageId, x, y");const l=this.customTypes.get(e);if(!l)throw new Error(`Custom type with id "${e}" not found`);if("region"===l.type){if(void 0===s||void 0===a)throw new Error("Width and height are required for region annotations");if(s<this.config.minRegionSize||a<this.config.minRegionSize)throw new Error(`Region size must be at least ${this.config.minRegionSize}px`)}this.customAnnotations.has(i)||this.customAnnotations.set(i,[]);const m=this.customAnnotations.get(i);if(m.length>=this.config.maxAnnotationsPerImage)throw new Error(`Maximum number of annotations per image (${this.config.maxAnnotationsPerImage}) reached`);const u=this.getNextOrderNumber(i,e),g={id:this.generateAnnotationId(),typeId:e,x:n,y:o,..."region"===l.type&&{width:s,height:a},imageId:i,order:u,metadata:r,...c&&d&&{parentAnnotationType:c,parentAnnotationId:d},createdAt:(new Date).toISOString(),updatedAt:(new Date).toISOString()};return m.push(g),this.triggerEvent("onAnnotationCreate",g),this.triggerCustomAnnotationCreateSync(g,{imageId:i,typeId:e,timestamp:(new Date).toISOString()}),this.saveToStorage(),this.triggerDatabaseAutoSave(),console.log(`Created custom annotation: ${g.id} (type: ${e}, order: ${u})`),g}getAnnotationsByImageId(t){return this.customAnnotations.get(t)||[]}deleteCustomAnnotation(t){for(const[e,n]of this.customAnnotations.entries()){const o=n.findIndex(e=>e.id===t);if(-1!==o){const s=n.splice(o,1)[0];return 0===n.length&&this.customAnnotations.delete(e),this.triggerEvent("onAnnotationDelete",s),this.triggerCustomAnnotationDeleteSync(s,{imageId:e,typeId:s.typeId,timestamp:(new Date).toISOString()}),this.saveToStorage(),this.triggerDatabaseAutoSave(),console.log(`Deleted custom annotation: ${t}`),!0}}return!1}deleteAnnotationsByTypeId(t){let e=0;for(const[n,o]of this.customAnnotations.entries()){const s=o.length,a=o.filter(e=>e.typeId!==t);a.length!==s&&(e+=s-a.length,0===a.length?this.customAnnotations.delete(n):this.customAnnotations.set(n,a))}e>0&&console.log(`Deleted ${e} annotations of type ${t}`)}setCustomAnnotationMode(t){const e=this.customTypes.get(t);if(!e)throw new Error(`Custom type with id "${t}" not found`);this.currentMode="custom",this.selectedCustomType=t,this.triggerEvent("onModeChange",{mode:"custom",typeId:t,customType:e}),console.log(`Switched to custom annotation mode: ${t}`)}setNormalMode(){this.currentMode="normal",this.selectedCustomType=null,this.triggerEvent("onModeChange",{mode:"normal",typeId:null,customType:null}),console.log("Switched to normal annotation mode")}isInCustomMode(){return"custom"===this.currentMode&&null!==this.selectedCustomType}getCurrentCustomType(){return this.selectedCustomType?this.customTypes.get(this.selectedCustomType):null}handleCanvasClick(t){if(!this.isInCustomMode())return{success:!1,reason:"Not in custom mode"};const e=this.getCurrentCustomType();if(!e)return{success:!1,reason:"No custom type selected"};if("point"!==e.type)return{success:!1,reason:"Selected type is not a point type"};if(!t.imageId||"number"!=typeof t.x||"number"!=typeof t.y)return{success:!1,reason:"Invalid click data"};try{return{success:!0,annotation:this.createCustomAnnotation({typeId:e.id,x:t.x,y:t.y,imageId:t.imageId})}}catch(n){return{success:!1,reason:n.message}}}handleRegionDrag(t){if(!this.isInCustomMode())return{success:!1,reason:"Not in custom mode"};const e=this.getCurrentCustomType();if(!e)return{success:!1,reason:"No custom type selected"};if("region"!==e.type)return{success:!1,reason:"Selected type is not a region type"};const{startX:n,startY:o,endX:s,endY:a,imageId:i}=t,r=Math.min(n,s),c=Math.min(o,a),d=Math.abs(s-n),l=Math.abs(a-o);try{return{success:!0,annotation:this.createCustomAnnotation({typeId:e.id,x:r,y:c,width:d,height:l,imageId:i})}}catch(m){return{success:!1,reason:m.message}}}getNextOrderNumber(t,e=null){const n=this.getAnnotationsByImageId(t),o=e?n.filter(t=>t.typeId===e):n;return 0===o.length?1:Math.max(...o.map(t=>t.order||0))+1}reorderAnnotations(t,e=null){const n=this.getAnnotationsByImageId(t);if(e){const o=n.filter(t=>t.typeId===e);o.sort((t,e)=>(t.order||0)-(e.order||0)),o.forEach((t,e)=>{t.order=e+1,t.updatedAt=(new Date).toISOString()}),console.log(`Reordered ${o.length} annotations of type ${e} for image ${t}`)}else n.sort((t,e)=>(t.order||0)-(e.order||0)),n.forEach((t,e)=>{t.order=e+1,t.updatedAt=(new Date).toISOString()}),console.log(`Reordered ${n.length} annotations for image ${t}`);this.saveToStorage(),this.triggerDatabaseAutoSave(),this.triggerEvent("onAnnotationUpdate",{imageId:t,typeId:e})}getAnnotationStats(t){const e=this.getAnnotationsByImageId(t),n={total:e.length,byType:{},orderRange:{min:0,max:0},gaps:[]};if(0===e.length)return n;e.forEach(t=>{const e=t.typeId;if(!n.byType[e]){const t=this.getCustomType(e);n.byType[e]={count:0,typeName:t?.name||"Unknown",typeColor:t?.color||"#000000",annotationType:t?.type||"unknown"}}n.byType[e].count++});const o=e.map(t=>t.order||0).filter(t=>t>0).sort((t,e)=>t-e);if(o.length>0){n.orderRange.min=o[0],n.orderRange.max=o[o.length-1];for(let t=o[0];t<=o[o.length-1];t++)o.includes(t)||n.gaps.push(t)}return n}findAnnotationByOrder(t,e){return this.getAnnotationsByImageId(t).find(t=>t.order===e)||null}updateAnnotationOrder(t,e){for(const[n,o]of this.customAnnotations.entries()){const s=o.find(e=>e.id===t);if(s){const a=o.find(n=>n.id!==t&&n.order===e);if(a)return console.warn(`Order ${e} is already used by annotation ${a.id}`),!1;const i=s.order;return s.order=e,s.updatedAt=(new Date).toISOString(),this.triggerEvent("onAnnotationUpdate",s),this.triggerCustomAnnotationUpdateSync(s,{imageId:n,orderChange:{from:i,to:e},timestamp:(new Date).toISOString()}),this.saveToStorage(),this.triggerDatabaseAutoSave(),console.log(`Updated annotation ${t} order from ${i} to ${e}`),!0}}return!1}generateAnnotationId(){return`custom_ann_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}exportData(){const t=Array.from(this.customTypes.values()),e=[];for(const[n,o]of this.customAnnotations.entries())e.push(...o);return{version:"1.0",exportTime:(new Date).toISOString(),customTypes:t,customAnnotations:e}}importData(t){try{const{version:e,customTypes:n=[],customAnnotations:o=[]}=t;"1.0"!==e&&console.warn(`Importing data with version ${e}, expected 1.0`);for(const t of n)this.customTypes.has(t.id)||this.customTypes.set(t.id,t);for(const t of o){this.customAnnotations.has(t.imageId)||this.customAnnotations.set(t.imageId,[]);const e=this.customAnnotations.get(t.imageId);e.find(e=>e.id===t.id)||e.push(t)}return console.log(`Imported ${n.length} custom types and ${o.length} annotations`),{success:!0}}catch(e){return console.error("Import failed:",e),{success:!1,error:e.message}}}addEventListener(t,e){this.eventHandlers[t]||(this.eventHandlers[t]=[]),this.eventHandlers[t].push(e)}removeEventListener(t,e){if(this.eventHandlers[t]){const n=this.eventHandlers[t].indexOf(e);n>-1&&this.eventHandlers[t].splice(n,1)}}triggerEvent(t,e){this.eventHandlers[t]&&this.eventHandlers[t].forEach(n=>{try{n(e)}catch(o){console.error(`Error in event handler for ${t}:`,o)}})}setRealTimeSyncManager(t){this.realTimeSyncManager=t,console.log("Real-time sync manager set for custom annotations")}triggerCustomAnnotationCreateSync(t,e={}){if(this.realTimeSyncManager&&this.realTimeSyncManager.isRealTimeSyncEnabled())try{const n=window.PlantAnnotationTool?.appState;if(!n?.currentPlant||!n?.currentImage)return void console.warn("🔄 缺少当前植株或图像信息，跳过自定义标注同步");const o={type:"CUSTOM_ANNOTATION_CREATE",annotation:t,context:{...e,plantId:n.currentPlant.id,imageId:n.currentImage.id,viewAngle:n.currentPlant.selectedViewAngle,appState:n},timestamp:(new Date).toISOString()};console.log("🔄 Triggering custom annotation create sync:",o),"function"==typeof this.realTimeSyncManager.triggerCustomAnnotationSync?this.realTimeSyncManager.triggerCustomAnnotationSync(o):console.warn("🔄 Real-time sync manager does not support custom annotation sync")}catch(n){console.error("🔄 Failed to trigger custom annotation create sync:",n)}else console.log("🔄 Custom annotation real-time sync disabled, skipping create sync")}triggerCustomAnnotationUpdateSync(t,e={}){if(this.realTimeSyncManager&&this.realTimeSyncManager.isRealTimeSyncEnabled())try{const n=window.PlantAnnotationTool?.appState;if(!n?.currentPlant||!n?.currentImage)return void console.warn("🔄 缺少当前植株或图像信息，跳过自定义标注更新同步");const o={type:"CUSTOM_ANNOTATION_UPDATE",annotation:t,context:{...e,plantId:n.currentPlant.id,imageId:n.currentImage.id,viewAngle:n.currentPlant.selectedViewAngle,appState:n},timestamp:(new Date).toISOString()};console.log("🔄 Triggering custom annotation update sync:",o),"function"==typeof this.realTimeSyncManager.triggerCustomAnnotationSync?this.realTimeSyncManager.triggerCustomAnnotationSync(o):console.warn("🔄 Real-time sync manager does not support custom annotation sync")}catch(n){console.error("🔄 Failed to trigger custom annotation update sync:",n)}else console.log("🔄 Custom annotation real-time sync disabled, skipping update sync")}triggerCustomAnnotationDeleteSync(t,e={}){if(this.realTimeSyncManager&&this.realTimeSyncManager.isRealTimeSyncEnabled())try{const n=window.PlantAnnotationTool?.appState;if(!n?.currentPlant||!n?.currentImage)return void console.warn("🔄 缺少当前植株或图像信息，跳过自定义标注删除同步");const o={type:"CUSTOM_ANNOTATION_DELETE",annotation:t,context:{...e,plantId:n.currentPlant.id,imageId:n.currentImage.id,viewAngle:n.currentPlant.selectedViewAngle,appState:n},timestamp:(new Date).toISOString()};console.log("🔄 Triggering custom annotation delete sync:",o),"function"==typeof this.realTimeSyncManager.triggerCustomAnnotationSync?this.realTimeSyncManager.triggerCustomAnnotationSync(o):console.warn("🔄 Real-time sync manager does not support custom annotation sync")}catch(n){console.error("🔄 Failed to trigger custom annotation delete sync:",n)}else console.log("🔄 Custom annotation real-time sync disabled, skipping delete sync")}triggerCustomTypeCreateSync(t,e={}){if(this.realTimeSyncManager&&this.realTimeSyncManager.isRealTimeSyncEnabled())try{const n={type:"CUSTOM_TYPE_CREATE",customType:t,context:e,timestamp:(new Date).toISOString()};console.log("🔄 Triggering custom type create sync:",n),"function"==typeof this.realTimeSyncManager.triggerCustomAnnotationSync?this.realTimeSyncManager.triggerCustomAnnotationSync(n):console.warn("🔄 Real-time sync manager does not support custom annotation sync")}catch(n){console.error("🔄 Failed to trigger custom type create sync:",n)}else console.log("🔄 Custom type real-time sync disabled, skipping create sync")}getStats(){const t=this.customTypes.size;let e=0,n=0;for(const[o,s]of this.customAnnotations.entries())s.length>0&&(n++,e+=s.length);return{totalTypes:t,totalAnnotations:e,annotatedImages:n,averageAnnotationsPerImage:n>0?(e/n).toFixed(2):0}}saveToStorage(){try{const t={customTypes:Array.from(this.customTypes.entries()),customAnnotations:Array.from(this.customAnnotations.entries()),version:"1.0",savedAt:(new Date).toISOString()};localStorage.setItem("customAnnotationData",JSON.stringify(t)),console.log("Custom annotation data saved to localStorage")}catch(t){console.error("Failed to save custom annotation data:",t)}}loadFromStorage(){try{const t=localStorage.getItem("customAnnotationData");if(!t)return void console.log("No saved custom annotation data found");const e=JSON.parse(t);e.customTypes&&(this.customTypes.clear(),e.customTypes.forEach(([t,e])=>{this.customTypes.set(t,e)})),e.customAnnotations&&(this.customAnnotations.clear(),e.customAnnotations.forEach(([t,e])=>{this.customAnnotations.set(t,e)})),console.log(`Loaded custom annotation data from localStorage (version: ${e.version})`),e.customTypes&&e.customTypes.length>0&&(console.log(`Triggering type events for ${e.customTypes.length} loaded types`),setTimeout(()=>{e.customTypes.forEach(([t,e])=>{this.triggerEvent("onTypeCreate",{type:e})})},100))}catch(t){console.error("Failed to load custom annotation data:",t)}}clearStorage(){try{localStorage.removeItem("customAnnotationData"),console.log("Custom annotation data cleared from localStorage")}catch(t){console.error("Failed to clear custom annotation data:",t)}}async triggerDatabaseAutoSave(){try{const t=window.PlantAnnotationTool?.annotationTool;t&&"function"==typeof t.autoSaveCurrentImage?(await t.autoSaveCurrentImage(),console.log("Custom annotation database auto-save triggered")):console.warn("AnnotationTool auto-save not available")}catch(t){console.error("Failed to trigger database auto-save:",t)}}getCustomAnnotationsForSave(t){return this.getAnnotationsByImageId(t).map(t=>{const e=this.getCustomType(t.typeId);return{...t,customType:e?{id:e.id,name:e.name,type:e.type,color:e.color,description:e.description}:null}})}loadCustomAnnotationsFromSave(t,e){if(!e||!Array.isArray(e))return;this.customAnnotations.has(t)||this.customAnnotations.set(t,[]);const n=this.customAnnotations.get(t);e.forEach(t=>{if(!n.find(e=>e.id===t.id)){const{customType:e,...o}=t;n.push(o)}}),console.log(`Loaded ${e.length} custom annotations for image ${t}`)}syncAnnotationsFromKeypoints(t,e){if(!t||!e||0===e.length)return;this.customAnnotations.has(t)||this.customAnnotations.set(t,[]);const n=this.customAnnotations.get(t);e.forEach(t=>{const e=n.findIndex(e=>e.id===t.id);if(-1===e){const e={...t};n.push(e),console.log(`[同步] 添加自定义标注到内部状态: ${t.id} (类型: ${t.customTypeId})`)}else n[e]={...t},console.log(`[同步] 更新自定义标注在内部状态: ${t.id} (类型: ${t.customTypeId})`)}),this.saveToStorage(),console.log(`[同步] 同步了 ${e.length} 个自定义标注到图像 ${t}`)}handleCustomAnnotationCreateFromSync(t){try{if(!t.annotation)return void console.warn("🔄 Invalid sync data for custom annotation create");const{annotation:e,context:n}=t,o=this.getAnnotationsByImageId(n.imageId);if(o.find(t=>t.id===e.id))return void console.log("🔄 Custom annotation already exists, skipping");if(!this.customTypes.has(e.typeId))return void console.warn(`🔄 Custom type ${e.typeId} not found for synced annotation`);this.customAnnotations.has(n.imageId)||this.customAnnotations.set(n.imageId,[]),this.customAnnotations.get(n.imageId).push(e),this.triggerEvent("onAnnotationCreate",e),this.saveToStorage(),console.log("🔄 Custom annotation created from sync:",e.id)}catch(e){console.error("🔄 Failed to handle custom annotation create from sync:",e)}}handleCustomAnnotationUpdateFromSync(t){try{if(!t.annotation)return void console.warn("🔄 Invalid sync data for custom annotation update");const{annotation:e,context:n}=t,o=this.getAnnotationsByImageId(n.imageId),s=o.findIndex(t=>t.id===e.id);if(-1===s)return void console.warn("🔄 Custom annotation not found for update from sync:",e.id);o[s]={...o[s],...e},this.triggerEvent("onAnnotationUpdate",e),this.saveToStorage(),console.log("🔄 Custom annotation updated from sync:",e.id)}catch(e){console.error("🔄 Failed to handle custom annotation update from sync:",e)}}handleCustomAnnotationDeleteFromSync(t){try{if(!t.annotation)return void console.warn("🔄 Invalid sync data for custom annotation delete");const{annotation:e,context:n}=t,o=this.getAnnotationsByImageId(n.imageId),s=o.findIndex(t=>t.id===e.id);if(-1===s)return void console.warn("🔄 Custom annotation not found for delete from sync:",e.id);o.splice(s,1),0===o.length&&this.customAnnotations.delete(n.imageId),this.triggerEvent("onAnnotationDelete",e),this.saveToStorage(),console.log("🔄 Custom annotation deleted from sync:",e.id)}catch(e){console.error("🔄 Failed to handle custom annotation delete from sync:",e)}}handleCustomTypeCreateFromSync(t){try{if(!t.customType)return void console.warn("🔄 Invalid sync data for custom type create");const{customType:e}=t;if(this.customTypes.has(e.id))return void console.log("🔄 Custom type already exists, skipping");this.customTypes.set(e.id,e),this.triggerEvent("onTypeCreate",{type:e}),this.saveToStorage(),console.log("🔄 Custom type created from sync:",e.id)}catch(e){console.error("🔄 Failed to handle custom type create from sync:",e)}}handleSyncEvent(t){if(t&&t.type)switch(console.log("🔄 Processing custom annotation sync event:",t.type),t.type){case"CUSTOM_ANNOTATION_CREATE":this.handleCustomAnnotationCreateFromSync(t);break;case"CUSTOM_ANNOTATION_UPDATE":this.handleCustomAnnotationUpdateFromSync(t);break;case"CUSTOM_ANNOTATION_DELETE":this.handleCustomAnnotationDeleteFromSync(t);break;case"CUSTOM_TYPE_CREATE":this.handleCustomTypeCreateFromSync(t);break;default:console.warn("🔄 Unknown custom annotation sync event type:",t.type)}else console.warn("🔄 Invalid sync data received")}})}}});
//# sourceMappingURL=CustomAnnotationManager-legacy-BxESFapd.js.map
