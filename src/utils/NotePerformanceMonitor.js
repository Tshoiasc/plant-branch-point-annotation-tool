/**\n * Performance monitoring utility for the note system\n * \n * Features:\n * - Track network requests and timing\n * - Monitor cache hit rates\n * - Compare bulk vs individual request performance\n * - Generate performance reports\n */\n\nexport class NotePerformanceMonitor {\n  constructor() {\n    this.sessions = [];\n    this.currentSession = null;\n    this.isMonitoring = false;\n  }\n\n  /**\n   * Start a new monitoring session\n   */\n  startSession(sessionName = `Session_${Date.now()}`) {\n    this.currentSession = {\n      name: sessionName,\n      startTime: performance.now(),\n      endTime: null,\n      requests: [],\n      bulkRequests: [],\n      cacheHits: 0,\n      errors: [],\n      plantCount: 0,\n      imageCount: 0\n    };\n    this.isMonitoring = true;\n    console.log(`[Performance] Started monitoring session: ${sessionName}`);\n  }\n\n  /**\n   * End the current monitoring session\n   */\n  endSession() {\n    if (!this.currentSession) return null;\n    \n    this.currentSession.endTime = performance.now();\n    this.currentSession.duration = this.currentSession.endTime - this.currentSession.startTime;\n    this.isMonitoring = false;\n    \n    const report = this.generateSessionReport(this.currentSession);\n    this.sessions.push(this.currentSession);\n    \n    console.log(`[Performance] Session ended: ${this.currentSession.name}`);\n    console.log(report);\n    \n    this.currentSession = null;\n    return report;\n  }\n\n  /**\n   * Record a network request\n   */\n  recordRequest(type, url, duration, success = true, cached = false) {\n    if (!this.isMonitoring || !this.currentSession) return;\n    \n    const request = {\n      type, // 'individual' or 'bulk'\n      url,\n      duration,\n      success,\n      cached,\n      timestamp: performance.now()\n    };\n    \n    if (type === 'bulk') {\n      this.currentSession.bulkRequests.push(request);\n    } else {\n      this.currentSession.requests.push(request);\n    }\n    \n    if (cached) {\n      this.currentSession.cacheHits++;\n    }\n  }\n\n  /**\n   * Record an error\n   */\n  recordError(error, context) {\n    if (!this.isMonitoring || !this.currentSession) return;\n    \n    this.currentSession.errors.push({\n      error: error.message,\n      context,\n      timestamp: performance.now()\n    });\n  }\n\n  /**\n   * Update plant and image counts\n   */\n  updateCounts(plantCount, imageCount) {\n    if (!this.isMonitoring || !this.currentSession) return;\n    \n    this.currentSession.plantCount = plantCount;\n    this.currentSession.imageCount = imageCount;\n  }\n\n  /**\n   * Generate a performance report for a session\n   */\n  generateSessionReport(session) {\n    const totalRequests = session.requests.length + session.bulkRequests.length;\n    const successfulRequests = session.requests.filter(r => r.success).length + \n                              session.bulkRequests.filter(r => r.success).length;\n    const totalNetworkTime = session.requests.reduce((sum, r) => sum + r.duration, 0) +\n                             session.bulkRequests.reduce((sum, r) => sum + r.duration, 0);\n    const avgRequestTime = totalRequests > 0 ? totalNetworkTime / totalRequests : 0;\n    const cacheHitRate = totalRequests > 0 ? (session.cacheHits / totalRequests) * 100 : 0;\n    \n    const efficiency = this.calculateEfficiency(session);\n    \n    return {\n      sessionName: session.name,\n      duration: Math.round(session.duration),\n      performance: {\n        totalRequests,\n        individualRequests: session.requests.length,\n        bulkRequests: session.bulkRequests.length,\n        successfulRequests,\n        failedRequests: totalRequests - successfulRequests,\n        successRate: totalRequests > 0 ? (successfulRequests / totalRequests) * 100 : 0\n      },\n      timing: {\n        totalNetworkTime: Math.round(totalNetworkTime),\n        avgRequestTime: Math.round(avgRequestTime),\n        sessionDuration: Math.round(session.duration)\n      },\n      cache: {\n        hits: session.cacheHits,\n        hitRate: Math.round(cacheHitRate * 100) / 100\n      },\n      data: {\n        plantCount: session.plantCount,\n        imageCount: session.imageCount,\n        expectedIndividualRequests: session.plantCount + session.imageCount\n      },\n      efficiency,\n      errors: session.errors.length,\n      grade: this.calculateGrade(efficiency, cacheHitRate, session.errors.length)\n    };\n  }\n\n  /**\n   * Calculate efficiency score\n   */\n  calculateEfficiency(session) {\n    const expectedIndividualRequests = session.plantCount + session.imageCount;\n    const actualRequests = session.requests.length + session.bulkRequests.length;\n    \n    if (expectedIndividualRequests === 0) return 100;\n    \n    const efficiency = ((expectedIndividualRequests - actualRequests) / expectedIndividualRequests) * 100;\n    return Math.max(0, Math.round(efficiency * 100) / 100);\n  }\n\n  /**\n   * Calculate performance grade\n   */\n  calculateGrade(efficiency, cacheHitRate, errorCount) {\n    let score = 0;\n    \n    // Efficiency scoring (40%)\n    if (efficiency >= 95) score += 40;\n    else if (efficiency >= 80) score += 30;\n    else if (efficiency >= 60) score += 20;\n    else if (efficiency >= 40) score += 10;\n    \n    // Cache hit rate scoring (30%)\n    if (cacheHitRate >= 80) score += 30;\n    else if (cacheHitRate >= 60) score += 20;\n    else if (cacheHitRate >= 40) score += 15;\n    else if (cacheHitRate >= 20) score += 10;\n    \n    // Error rate scoring (30%)\n    if (errorCount === 0) score += 30;\n    else if (errorCount <= 2) score += 20;\n    else if (errorCount <= 5) score += 10;\n    \n    if (score >= 90) return 'A+';\n    if (score >= 80) return 'A';\n    if (score >= 70) return 'B+';\n    if (score >= 60) return 'B';\n    if (score >= 50) return 'C';\n    return 'D';\n  }\n\n  /**\n   * Compare two sessions\n   */\n  compareSessions(session1Name, session2Name) {\n    const session1 = this.sessions.find(s => s.name === session1Name);\n    const session2 = this.sessions.find(s => s.name === session2Name);\n    \n    if (!session1 || !session2) {\n      console.error('One or both sessions not found');\n      return null;\n    }\n    \n    const report1 = this.generateSessionReport(session1);\n    const report2 = this.generateSessionReport(session2);\n    \n    return {\n      session1: report1,\n      session2: report2,\n      improvements: {\n        requestReduction: report1.performance.totalRequests - report2.performance.totalRequests,\n        timeImprovement: report1.timing.totalNetworkTime - report2.timing.totalNetworkTime,\n        efficiencyGain: report2.efficiency - report1.efficiency,\n        cacheImprovement: report2.cache.hitRate - report1.cache.hitRate\n      }\n    };\n  }\n\n  /**\n   * Get all session reports\n   */\n  getAllReports() {\n    return this.sessions.map(session => this.generateSessionReport(session));\n  }\n\n  /**\n   * Export performance data\n   */\n  exportData() {\n    return {\n      sessions: this.sessions,\n      reports: this.getAllReports(),\n      exportTime: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Clear all monitoring data\n   */\n  clearData() {\n    this.sessions = [];\n    this.currentSession = null;\n    this.isMonitoring = false;\n    console.log('[Performance] All monitoring data cleared');\n  }\n\n  /**\n   * Get real-time statistics\n   */\n  getRealTimeStats() {\n    if (!this.currentSession) return null;\n    \n    const currentTime = performance.now();\n    const elapsed = currentTime - this.currentSession.startTime;\n    const totalRequests = this.currentSession.requests.length + this.currentSession.bulkRequests.length;\n    \n    return {\n      sessionName: this.currentSession.name,\n      elapsed: Math.round(elapsed),\n      totalRequests,\n      individualRequests: this.currentSession.requests.length,\n      bulkRequests: this.currentSession.bulkRequests.length,\n      cacheHits: this.currentSession.cacheHits,\n      errors: this.currentSession.errors.length,\n      requestsPerSecond: elapsed > 0 ? Math.round((totalRequests / elapsed) * 1000 * 100) / 100 : 0\n    };\n  }\n}\n\n// Global instance\nexport const notePerformanceMonitor = new NotePerformanceMonitor();\n\n// Development utilities\nif (typeof window !== 'undefined') {\n  window.notePerformanceMonitor = notePerformanceMonitor;\n  window.debugNotePerformance = () => {\n    console.log('=== Note System Performance Debug ===');\n    console.log('Current session:', notePerformanceMonitor.getRealTimeStats());\n    console.log('All reports:', notePerformanceMonitor.getAllReports());\n    \n    if (window.PlantAnnotationTool?.noteManager) {\n      console.log('NoteManager metrics:', window.PlantAnnotationTool.noteManager.getPerformanceMetrics());\n    }\n  };\n}