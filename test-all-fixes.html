<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>所有修复验证测试</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .test-section { margin: 30px 0; border: 1px solid #ddd; padding: 20px; border-radius: 8px; }
        button { padding: 10px 20px; margin: 10px 5px; cursor: pointer; }
        .test-image { max-width: 150px; max-height: 150px; border: 2px solid #ccc; margin: 5px; }
        .fix-summary { background: #f8f9fa; padding: 15px; border-left: 4px solid #007bff; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>🎉 所有修复验证测试</h1>
    
    <div class="fix-summary">
        <h3>修复摘要</h3>
        <ul>
            <li>✅ <strong>问题1</strong>: 修复了特定编号预览的渲染错误</li>
            <li>✅ <strong>问题2</strong>: 优化了右侧操作区布局，避免挤压</li>
            <li>✅ <strong>问题3</strong>: 添加了全屏加载指示器和自动连接功能</li>
        </ul>
    </div>
    
    <div class="test-section">
        <h2>🔧 修复1: 预览图渲染测试</h2>
        <p>测试BranchPointPreviewManager中的renderSpecificOrderPreview方法</p>
        <button onclick="testPreviewRendering()">测试预览图渲染</button>
        <div id="preview-results"></div>
    </div>
    
    <div class="test-section">
        <h2>📐 修复2: 布局测试</h2>
        <p>验证CSS布局优化，确保操作区内容不会挤压</p>
        <button onclick="testLayoutOptimization()">检查布局设置</button>
        <div id="layout-results"></div>
    </div>
    
    <div class="test-section">
        <h2>🚀 修复3: 自动连接测试</h2>
        <p>验证全屏加载指示器和自动连接功能</p>
        <button onclick="testAutoConnection()">测试自动连接逻辑</button>
        <div id="autoconnect-results"></div>
    </div>
    
    <div class="test-section">
        <h2>🌐 后端状态检查</h2>
        <button onclick="checkBackendStatus()">检查后端服务</button>
        <div id="backend-status"></div>
    </div>

    <script type="module">
        import { HttpFileSystemManager } from './src/core/HttpFileSystemManager.js';
        import { PlantDataManager } from './src/core/PlantDataManager.js';
        
        window.fileSystemManager = new HttpFileSystemManager();
        window.plantDataManager = new PlantDataManager();
        
        window.testPreviewRendering = async function() {
            const resultsDiv = document.getElementById('preview-results');
            resultsDiv.innerHTML = '<div class="status info">测试预览图渲染逻辑...</div>';
            
            try {
                await window.plantDataManager.initialize();
                
                // 获取植物数据
                const plants = await window.plantDataManager.fileSystemManager.traversePlantDirectories();
                if (plants.length === 0) {
                    throw new Error('未找到植物数据');
                }
                
                const firstPlant = plants[0];
                const imagesByView = await window.plantDataManager.fileSystemManager.readPlantImages(firstPlant.id);
                
                let testResults = '<div class="status success">✅ 成功获取植物图像数据</div>';
                
                // 测试图像URL生成（这是预览渲染的核心）
                for (const [viewAngle, images] of Object.entries(imagesByView)) {
                    if (images.length > 0) {
                        const testImage = images[0];
                        
                        try {
                            // 模拟BranchPointPreviewManager中的URL生成逻辑
                            let imageURL;
                            
                            // 测试新的优先级顺序
                            if (testImage.url) {
                                imageURL = testImage.url;
                                testResults += '<div class="status success">✅ 方式1: 使用现有URL</div>';
                            } else {
                                imageURL = await window.fileSystemManager.createImageURL(testImage);
                                testResults += '<div class="status success">✅ 方式2: 通过FileSystemManager创建URL</div>';
                            }
                            
                            testResults += `<div class="status info">生成的URL: ${imageURL}</div>`;
                            
                            // 验证URL可访问性
                            const response = await fetch(imageURL, { method: 'HEAD' });
                            if (response.ok) {
                                testResults += '<div class="status success">✅ 预览图URL可访问，渲染错误已修复</div>';
                            } else {
                                testResults += `<div class="status error">❌ URL不可访问 (${response.status})</div>`;
                            }
                            
                        } catch (error) {
                            testResults += `<div class="status error">❌ URL生成失败: ${error.message}</div>`;
                        }
                        break;
                    }
                }
                
                resultsDiv.innerHTML = testResults;
                
            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">❌ 预览渲染测试失败: ${error.message}</div>`;
            }
        };
        
        window.testLayoutOptimization = function() {
            const resultsDiv = document.getElementById('layout-results');
            
            // 检查CSS类是否正确应用
            const checks = [
                {
                    name: 'instruction-panel 压缩间距',
                    selector: '.instruction-panel',
                    property: 'padding',
                    expected: /var\(--spacing-sm\)|8px|0.5rem/,
                    description: '操作面板应使用压缩间距'
                },
                {
                    name: 'instructions-section 弹性布局',
                    selector: '.instructions-section',
                    property: 'flex',
                    expected: /0 1 auto/,
                    description: '指令部分应允许收缩避免挤压'
                },
                {
                    name: 'direction-legend 固定位置',
                    selector: '.direction-legend',
                    property: 'margin-top',
                    expected: /auto/,
                    description: '图例应推到可用空间底部'
                },
                {
                    name: '全屏加载器样式',
                    selector: '.fullscreen-loading',
                    property: 'position',
                    expected: /fixed/,
                    description: '全屏加载器应覆盖整个屏幕'
                }
            ];
            
            let results = '<div class="status info">检查CSS布局优化...</div>';
            let passCount = 0;
            
            checks.forEach(check => {
                try {
                    // 创建临时元素来测试样式
                    const tempElement = document.createElement('div');
                    tempElement.className = check.selector.replace('.', '');
                    document.body.appendChild(tempElement);
                    
                    const computedStyle = window.getComputedStyle(tempElement);
                    const actualValue = computedStyle.getPropertyValue(check.property);
                    
                    const passed = check.expected.test(actualValue) || actualValue.includes('var(--spacing-sm)');
                    
                    if (passed) {
                        results += `<div class="status success">✅ ${check.name}: ${actualValue}</div>`;
                        passCount++;
                    } else {
                        results += `<div class="status error">❌ ${check.name}: 期望 ${check.expected}, 实际 ${actualValue}</div>`;
                    }
                    
                    document.body.removeChild(tempElement);
                } catch (error) {
                    results += `<div class="status error">❌ ${check.name}: 检查失败 - ${error.message}</div>`;
                }
            });
            
            const successRate = (passCount / checks.length * 100).toFixed(0);
            results += `<div class="status info">布局优化检查完成: ${passCount}/${checks.length} 项通过 (${successRate}%)</div>`;
            
            if (passCount === checks.length) {
                results += '<div class="status success">🎉 所有布局优化均已正确应用！</div>';
            }
            
            resultsDiv.innerHTML = results;
        };
        
        window.testAutoConnection = function() {
            const resultsDiv = document.getElementById('autoconnect-results');
            
            let results = '<div class="status info">检查自动连接功能...</div>';
            
            // 检查全屏加载器元素
            const fullscreenLoader = document.getElementById('fullscreen-loading');
            if (fullscreenLoader) {
                results += '<div class="status success">✅ 全屏加载器元素存在</div>';
                
                // 检查CSS样式
                const style = window.getComputedStyle(fullscreenLoader);
                if (style.position === 'fixed') {
                    results += '<div class="status success">✅ 全屏加载器样式正确</div>';
                } else {
                    results += '<div class="status error">❌ 全屏加载器样式不正确</div>';
                }
            } else {
                results += '<div class="status error">❌ 全屏加载器元素不存在</div>';
            }
            
            // 检查header-controls是否被隐藏
            const headerControls = document.querySelector('.header-controls');
            if (headerControls) {
                const style = window.getComputedStyle(headerControls);
                if (style.display === 'none') {
                    results += '<div class="status success">✅ 数据集选择按钮已隐藏</div>';
                } else {
                    results += '<div class="status error">❌ 数据集选择按钮未隐藏</div>';
                }
            }
            
            // 检查必要的JavaScript函数
            const functions = ['updateFullscreenLoading', 'hideFullscreenLoading', 'autoConnectDataset'];
            functions.forEach(funcName => {
                if (typeof window[funcName] === 'function') {
                    results += `<div class="status success">✅ ${funcName} 函数存在</div>`;
                } else {
                    results += `<div class="status error">❌ ${funcName} 函数不存在</div>`;
                }
            });
            
            results += '<div class="status info">💡 在主应用中，页面将自动连接数据集并显示加载进度</div>';
            
            resultsDiv.innerHTML = results;
        };
        
        window.checkBackendStatus = async function() {
            const resultsDiv = document.getElementById('backend-status');
            resultsDiv.innerHTML = '<div class="status info">检查后端服务状态...</div>';
            
            try {
                const endpoints = [
                    { name: '健康检查', url: 'http://localhost:3003/api/health' },
                    { name: '植物目录', url: 'http://localhost:3003/api/plant-directories' },
                    { name: '跳过信息', url: 'http://localhost:3003/api/skip-info' },
                    { name: '数据集信息', url: 'http://localhost:3003/api/dataset-info' }
                ];
                
                let results = '';
                let successCount = 0;
                
                for (const endpoint of endpoints) {
                    try {
                        const response = await fetch(endpoint.url);
                        const data = await response.json();
                        
                        if (data.success) {
                            results += `<div class="status success">✅ ${endpoint.name}: 正常</div>`;
                            successCount++;
                        } else {
                            results += `<div class="status error">❌ ${endpoint.name}: ${data.error}</div>`;
                        }
                    } catch (error) {
                        results += `<div class="status error">❌ ${endpoint.name}: 连接失败</div>`;
                    }
                }
                
                const healthRate = (successCount / endpoints.length * 100).toFixed(0);
                results += `<div class="status info">后端健康状态: ${successCount}/${endpoints.length} 端点正常 (${healthRate}%)</div>`;
                
                if (successCount === endpoints.length) {
                    results += '<div class="status success">🎉 后端服务完全正常，所有修复功能可用！</div>';
                }
                
                resultsDiv.innerHTML = results;
                
            } catch (error) {
                resultsDiv.innerHTML = `<div class="status error">❌ 后端状态检查失败: ${error.message}</div>`;
            }
        };
    </script>
</body>
</html>